/**
 * The global CONSTANTS object
 * @type {Object}
 */
const CONST = {
	vtt: 'Foundry VTT',
	VTT: 'Foundry Virtual Tabletop',
};

/**
 * Define the string name used for the base entity type when specific sub-types are not defined by the system
 * @type {String}
 */
CONST.BASE_ENTITY_TYPE = 'base';

/**
 * Valid Chat Message types
 * @type {Object}
 */
CONST.CHAT_MESSAGE_TYPES = {
	OTHER: 0,
	OOC: 1,
	IC: 2,
	EMOTE: 3,
	WHISPER: 4,
	ROLL: 5,
};

/**
 * The allowed Entity types which may exist within a Compendium pack
 * This is a subset of ENTITY_TYPES
 * @type {Array}
 */
CONST.COMPENDIUM_ENTITY_TYPES = [
	'Actor',
	'Item',
	'Scene',
	'JournalEntry',
	'RollTable',
	'Playlist',
];

/**
 * The default artwork used for Token images if none is provided
 * @type {String}
 */
CONST.DEFAULT_TOKEN = 'icons/svg/mystery-man.svg';

/**
 * The default artwork used for Note placeables if none is provided
 * @type {String}
 */
CONST.DEFAULT_NOTE_ICON = 'icons/svg/book.svg';

/**
 * The allowed Drawing types which may be saved
 * @type {Object}
 */
CONST.DRAWING_TYPES = {
	RECTANGLE: 'r',
	ELLIPSE: 'e',
	TEXT: 't',
	POLYGON: 'p',
	FREEHAND: 'f',
};

/**
 * The allowed fill types which a Drawing object may display
 * NONE: The drawing is not filled
 * SOLID: The drawing is filled with a solid color
 * PATTERN: The drawing is filled with a tiled image pattern
 * @type {Object}
 */
CONST.DRAWING_FILL_TYPES = {
	NONE: 0,
	SOLID: 1,
	PATTERN: 2,
};

/**
 * Define the allowed Entity class types
 * @type {Array}
 */
CONST.ENTITY_TYPES = [
	'Actor',
	'ChatMessage',
	'Combat',
	'Item',
	'Folder',
	'JournalEntry',
	'Macro',
	'Playlist',
	'RollTable',
	'Scene',
	'User',
];

/**
 * EULA version number
 * @type {String}
 */
CONST.EULA_VERSION = '0.3.8';

/**
 * Define the allowed permission levels for a non-user Entity.
 * Each level is assigned a value in ascending order. Higher levels grant more permissions.
 * @type {Object}
 */
CONST.ENTITY_PERMISSIONS = {
	NONE: 0,
	LIMITED: 1,
	OBSERVER: 2,
	OWNER: 3,
};

/**
 * The maximum allowed level of depth for Folder nesting
 * @type {Number}
 */
CONST.FOLDER_MAX_DEPTH = 3;

/**
 * Define the allowed Entity types which Folders may contain
 * @type {Array}
 */
CONST.FOLDER_ENTITY_TYPES = [
	'Actor',
	'Item',
	'Scene',
	'JournalEntry',
	'RollTable',
];

/**
 * Define the allowed Entity types which may be dynamically linked in chat
 * @type {Array}
 */
CONST.ENTITY_LINK_TYPES = [
	'Actor',
	'Item',
	'Scene',
	'JournalEntry',
	'RollTable',
];

/**
 * The allowed Grid types which are supported by the software
 * @type {Object}
 */
CONST.GRID_TYPES = {
	GRIDLESS: 0,
	SQUARE: 1,
	HEXODDR: 2,
	HEXEVENR: 3,
	HEXODDQ: 4,
	HEXEVENQ: 5,
};

/**
 * The minimum allowed grid size which is supported by the software
 * @type {Number}
 */
CONST.GRID_MIN_SIZE = 50;

/**
 * An Array of valid MacroAction scope values
 * @type {Array.<string>}
 */
CONST.MACRO_SCOPES = ['global', 'actors', 'actor'];

/**
 * The allowed playback modes for an audio Playlist
 * DISABLED: The playlist does not play on its own, only individual Sound tracks played as a soundboard
 * SEQUENTIAL: The playlist plays sounds one at a time in sequence
 * SHUFFLE: The playlist plays sounds one at a time in randomized order
 * SIMULTANEOUS: The playlist plays all contained sounds at the same time
 * @type {Object}
 */
CONST.PLAYLIST_MODES = {
	DISABLED: -1,
	SEQUENTIAL: 0,
	SHUFFLE: 1,
	SIMULTANEOUS: 2,
};

/**
 * Define the threshold version which packages must support as their minimumCoreVersion in order to be usable
 * @type {string}
 */
CONST.REQUIRED_PACKAGE_CORE_VERSION = '0.4.4';

/**
 * Encode the reasons why a package may be available or unavailable for use
 * @type {Object}
 */
CONST.PACKAGE_AVAILABILITY_CODES = {
	AVAILABLE: 0,
	REQUIRES_UPDATE: 1,
	REQUIRES_SYSTEM: 2,
	REQUIRES_DEPENDENCY: 3,
	REQUIRES_CORE: 4,
};

/**
 * The default sorting density for manually ordering child objects within a parent
 * @type {Number}
 */
CONST.SORT_INTEGER_DENSITY = 100000;

/**
 * The allowed types of a TableResult document
 * @type {Object}
 */
CONST.TABLE_RESULT_TYPES = {
	TEXT: 0,
	ENTITY: 1,
	COMPENDIUM: 2,
};

/**
 * Define the valid anchor locations for a Tooltip displayed on a Placeable Object
 * @type {Object}
 */
CONST.TEXT_ANCHOR_POINTS = {
	CENTER: 0,
	BOTTOM: 1,
	TOP: 2,
	LEFT: 3,
	RIGHT: 4,
};

/**
 * Describe the various thresholds of token control upon which to show certain pieces of information
 * NONE - no information is displayed
 * CONTROL - displayed when the token is controlled
 * OWNER HOVER - displayed when hovered by a GM or a user who owns the actor
 * HOVER - displayed when hovered by any user
 * OWNER - always displayed for a GM or for a user who owns the actor
 * ALWAYS - always displayed for everyone
 * @type {Object}
 */
CONST.TOKEN_DISPLAY_MODES = {
	NONE: 0,
	CONTROL: 10,
	OWNER_HOVER: 20,
	HOVER: 30,
	OWNER: 40,
	ALWAYS: 50,
};

/**
 * The allowed Token disposition types
 * HOSTILE - Displayed as an enemy with a red border
 * NEUTRAL - Displayed as neutral with a yellow border
 * FRIENDLY - Displayed as an ally with a cyan border
 */
CONST.TOKEN_DISPOSITIONS = {
	HOSTILE: -1,
	NEUTRAL: 0,
	FRIENDLY: 1,
};

/**
 * Define the allowed User permission levels.
 * Each level is assigned a value in ascending order. Higher levels grant more permissions.
 * @type {Object}
 */
CONST.USER_ROLES = {
	NONE: 0,
	PLAYER: 1,
	TRUSTED: 2,
	ASSISTANT: 3,
	GAMEMASTER: 4,
};

/**
 * Define the named set of abilities for which each User may be granted or denied permission
 * Each key of this Object denotes an ability for which permission may be granted or withheld
 * Each value of this Object denotes the minimum User Role for which the permission is granted by default
 * @type {Object}
 */
CONST.USER_PERMISSIONS = {
	broadcastAudio: CONST.USER_ROLES.TRUSTED,
	broadcastVideo: CONST.USER_ROLES.TRUSTED,
	browseFiles: CONST.USER_ROLES.TRUSTED,
	uploadFiles: CONST.USER_ROLES.TRUSTED,
};

/**
 * The allowed directions of effect that a Wall can have
 * BOTH: The wall collides from both directions
 * LEFT: The wall collides only when a ray strikes its left side
 * RIGHT: The wall collides only when a ray strikes its right side
 * @type {Object}
 */
CONST.WALL_DIRECTIONS = {
	BOTH: 0,
	LEFT: 1,
	RIGHT: 2,
};

/**
 * The allowed door types which a Wall may contain
 * NONE: The wall does not contain a door
 * DOOR: The wall contains a regular door
 * SECRET: The wall contains a secret door
 * @type {Object}
 */
CONST.WALL_DOOR_TYPES = {
	NONE: 0,
	DOOR: 1,
	SECRET: 2,
};

/**
 * The allowed door states which may describe a Wall that contains a door
 * CLOSED: The door is closed
 * OPEN: The door is open
 * LOCKED: The door is closed and locked
 * @type {Object}
 */
CONST.WALL_DOOR_STATES = {
	CLOSED: 0,
	OPEN: 1,
	LOCKED: 2,
};

/**
 * The types of movement collision which a Wall may impose
 * NONE: Movement does not collide with this wall
 * NORMAL: Movement collides with this wall
 * @type {Object}
 */
CONST.WALL_MOVEMENT_TYPES = {
	NONE: 0,
	NORMAL: 1,
};

/**
 * The types of sensory collision which a Wall may impose
 * NONE: Senses do not collide with this wall
 * NORMAL: Senses collide with this wall
 * LIMITED: Senses collide with the second intersection, bypassing the first
 * @type {Object}
 */
CONST.WALL_SENSE_TYPES = {
	NONE: 0,
	NORMAL: 1,
	LIMITED: 2,
};

/**
 * The supported file extensions for image-type files
 * @type {Array}
 */
CONST.IMAGE_FILE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'svg', 'webp'];

/**
 * The supported file extensions for video-type files
 * @type {Array}
 */
CONST.VIDEO_FILE_EXTENSIONS = ['mp4', 'ogg', 'webm'];

/**
 * The supported file extensions for audio-type files
 * @type {Array}
 */
CONST.AUDIO_FILE_EXTENSIONS = ['flac', 'mp3', 'ogg', 'wav', 'webm'];

// Freeze the CONST object to prevent changes
Object.freeze(CONST);

try {
	module.exports = CONST;
} catch (err) {}

/* -------------------------------------------- */
/*  Math Functions                              */
/* -------------------------------------------- */

Math.clamped = function(x, min, max) {
	return Math.min(max, Math.max(x, min));
};

Math.decimals = function(number, places) {
	let scl = Math.pow(10, places);
	return Math.round(number * scl) / scl;
};

toDegrees = function(angle) {
	return angle * (180 / Math.PI);
};

normalizeDegrees = function(degrees) {
	let nd = (degrees + 360) % 360;
	return nd > 180 ? nd - 360 : nd;
};

toRadians = function(degree) {
	return (Math.round(degree) % 360) * (Math.PI / 180);
};

normalizeRadians = function(rad) {
	let pi2 = 2 * Math.PI;
	let nr = (rad + pi2) % pi2;
	return nr > Math.PI ? nr - pi2 : nr;
};

/* -------------------------------------------- */
/* String Methods                               */
/* -------------------------------------------- */

String.prototype.capitalize = function() {
	if (!this.length) return this;
	return this.charAt(0).toUpperCase() + this.slice(1);
};

String.prototype.titleCase = function() {
	if (!this.length) return this;
	return this.toLowerCase()
		.split(' ')
		.map(function(word) {
			return word.replace(word[0], word[0].toUpperCase());
		})
		.join(' ');
};

/**
 * Strip any <script> tags which were included within a provided string
 * @return {String|*}
 */
String.prototype.stripScripts = function() {
	let el = document.createElement('div');
	el.innerHTML = this;
	for (let s of el.getElementsByTagName('script')) {
		s.parentNode.removeChild(s);
	}
	return el.innerHTML;
};

/* -------------------------------------------- */
/* Number Methods                               */
/* -------------------------------------------- */

Number.prototype.ordinalString = function() {
	let s = ['th', 'st', 'nd', 'rd'],
		v = this % 100;
	return this + (s[(v - 20) % 10] || s[v] || s[0]);
};

Number.prototype.paddedString = function(digits) {
	let s = '000000000' + this;
	return s.substr(s.length - digits);
};

Number.prototype.signedString = function() {
	return (this < 0 ? '' : '+') + this;
};

Number.prototype.between = function(a, b, inclusive = true) {
	let min = Math.min(a, b);
	let max = Math.max(a, b);
	return inclusive ? this >= min && this <= max : this > min && this < max;
};

/**
 * A faster numeric between check which avoids type coercion to the Number object
 * Since this avoids coercion, if non-numbers are passed in unpredictable results will occur. Use with caution.
 * @param {number} num
 * @param {number} a
 * @param {number} b
 * @param {boolean} inclusive
 * @return {boolean}
 */
Number.between = function(num, a, b, inclusive = true) {
	let min = Math.min(a, b);
	let max = Math.max(a, b);
	return inclusive ? num >= min && num <= max : num > min && num < max;
};

/**
 * Test whether a value is numeric
 * This is the highest performing algorithm currently available
 * https://jsperf.com/isnan-vs-typeof/5
 * @param {*} n       A value to test
 * @return {Boolean}  Is it a number?
 */
Number.isNumeric = function(n) {
	if (n instanceof Array) return false;
	else if (n === null) return false;
	return +n === +n;
};

/* -------------------------------------------- */
/* Array Methods                                */
/* -------------------------------------------- */

Array.fromRange = function(n) {
	return Array.from(new Array(parseInt(n)).keys());
};

Array.prototype.deepFlatten = function() {
	return this.reduce(
		(acc, val) =>
			Array.isArray(val)
				? acc.concat(val.deepFlatten())
				: acc.concat(val),
		[]
	);
};

/**
 * Test equality of the values of this array against the values of some other Array
 * @param {Array} other
 */
Array.prototype.equals = function(other) {
	if (!(other instanceof Array) || other.length !== this.length) return false;
	return this.every((v, i) => other[i] === v);
};

/**
 * Partition an original array into two children array based on a logical test
 * Elements which test as false go into the first result while elements testing as true appear in the second
 * @param rule {Function}
 * @return {Array}    An Array of length two whose elements are the partitioned pieces of the original
 */
Array.prototype.partition = function(rule) {
	return this.reduce(
		(acc, val) => {
			let test = rule(val);
			acc[Number(test)].push(val);
			return acc;
		},
		[[], []]
	);
};

/**
 * Join an Array using a string separator, first filtering out any parts which return a false-y value
 * @param {string} sep    The separator string
 * @return {string}       The joined string, filtered of any false values
 */
Array.prototype.filterJoin = function(sep) {
	return this.filter(p => !!p).join(sep);
};

/**
 * Find an element within the Array and remove it from the array
 * @param {Function} find   A function to use as input to findIndex
 * @return {*|null}         The removed item or null if none was found
 */
Array.prototype.findSplice = function(find) {
	const idx = this.findIndex(find);
	if (idx === -1) return null;
	const item = this[idx];
	this.splice(idx, 1);
	return item;
};

/* -------------------------------------------- */
/* Object Methods                               */
/* -------------------------------------------- */

/**
 * A cheap data duplication trick, surprisingly relatively performant
 * @param {Object} original   Some sort of data
 */
function duplicate(original) {
	return JSON.parse(JSON.stringify(original));
}

/* -------------------------------------------- */

/**
 * Learn the named type of a token - extending the functionality of typeof to recognize some core Object types
 * @param {*} token     Some passed token
 * @return {string}     The named type of the token
 */
function getType(token) {
	const tof = typeof token;
	if (tof === 'object') {
		if (token === null) return 'null';
		let cn = token.constructor.name;
		if (['String', 'Number', 'Boolean', 'Array', 'Set'].includes(cn))
			return cn;
		else return 'Object';
	}
	return tof;
}

/* -------------------------------------------- */

/**
 * A temporary shim to invert an object, flipping keys and values
 * @param {Object} obj    Some object where the values are unique
 * @return {Object}       An inverted object where the values of the original object are the keys of the new object
 */
function invertObject(obj) {
	return Object.entries(obj).reduce((inverted, entry) => {
		let [k, v] = entry;
		inverted[v] = k;
		return inverted;
	}, {});
}

/* -------------------------------------------- */

/**
 * Filter the contents of some source object using the structure of a template object.
 * Only keys which exist in the template are preserved in the source object.
 *
 * @param {Object} source           An object which contains the data you wish to filter
 * @param {Object} template         An object which contains the structure you wish to preserve
 * @param {boolean} keepSpecial     Whether to keep special tokens like deletion keys
 * @param {boolean} templateValues  Instead of keeping values from the source, instead draw values from the template
 *
 * @example
 * const source = {foo: {number: 1, name: "Tim", topping: "olives"}, bar: "baz"};
 * const template = {foo: {number: 0, name: "Mit", style: "bold"}, other: 72};
 * filterObject(source, template); // {foo: {number: 1, name: "Tim"}};
 * filterObject(source, template, {templateValues: true}); // {foo: {number: 0, name: "Mit"}};
 */
function filterObject(
	source,
	template,
	{ keepSpecial = false, templateValues = false } = {}
) {
	// Validate input
	const ts = getType(source);
	const tt = getType(template);
	if (ts !== 'Object' || tt !== 'Object')
		throw new Error('One of source or template are not Objects!');

	// Define recursive filtering function
	const _filter = function(s, t, filtered) {
		for (let [k, v] of Object.entries(s)) {
			let has = t.hasOwnProperty(k);
			let x = t[k];

			// Case 1 - inner object
			if (has && getType(v) === 'Object' && getType(x) === 'Object') {
				filtered[k] = _filter(v, x, {});
			}

			// Case 2 - inner key
			else if (has) {
				filtered[k] = templateValues ? x : v;
			}

			// Case 3 - special key
			else if (keepSpecial && k.startsWith('-=')) {
				filtered[k] = v;
			}
		}
		return filtered;
	};

	// Begin filtering at the outer-most layer
	return _filter(source, template, {});
}

/* -------------------------------------------- */

/**
 * Flatten a possibly multi-dimensional object to a one-dimensional one by converting all nested keys to dot notation
 * @param {Object} obj  The object to flatten
 * @param {Number} _d   Recursion depth, to prevent overflow
 * @return {Object}     A flattened object
 */
function flattenObject(obj, _d = 0) {
	const flat = {};
	if (_d > 10) throw new Error('Maximum depth exceeded');
	for (let [k, v] of Object.entries(obj)) {
		let t = getType(v);

		// Inner objects
		if (t === 'Object') {
			if (isObjectEmpty(v)) flat[k] = v;
			let inner = flattenObject(v, _d + 1);
			for (let [ik, iv] of Object.entries(inner)) {
				flat[`${k}.${ik}`] = iv;
			}
		}

		// Inner values
		else flat[k] = v;
	}
	return flat;
}

/* -------------------------------------------- */

/**
 * Expand a flattened object to be a standard multi-dimensional nested Object by converting all dot-notation keys to
 * inner objects.
 *
 * @param {Object} obj  The object to expand
 * @param {Number} _d   Recursion depth, to prevent overflow
 * @return {Object}     An expanded object
 */
function expandObject(obj, _d = 0) {
	const expanded = {};
	if (_d > 10) throw new Error('Maximum depth exceeded');
	for (let [k, v] of Object.entries(obj)) {
		if (v instanceof Object && !Array.isArray(v))
			v = expandObject(v, _d + 1);
		setProperty(expanded, k, v);
	}
	return expanded;
}

/* -------------------------------------------- */

/**
 * A simple function to test whether or not an Object is empty
 * @param {Object} obj    The object to test
 * @return {Boolean}      Is the object empty?
 */
function isObjectEmpty(obj) {
	if (getType(obj) !== 'Object')
		throw new Error('The provided data is not an object!');
	return Object.keys(obj).length === 0;
}

/* -------------------------------------------- */

/**
 * Update a source object by replacing its keys and values with those from a target object.
 *
 * @param {Object} original     The initial object which should be updated with values from the target
 * @param {Object} other        A new object whose values should replace those in the source
 * @param {boolean} insert      Control whether to insert new parent objects in the structure which did not previously
 *                              exist in the source object.
 * @param {boolean} overwrite   Control whether to replace existing values in the source, or only merge values which
 *                              do not exist in the source.
 * @param {boolean} inplace     Update the values of original inplace? Otherwise duplicate the original and return a
 *                              safe copy.
 * @param {boolean} enforceTypes  Enforce that the type of an inner value in the source object match the type of the
 *                              new value. Default is false for now, but should be true in the future.
 * @param {number} _d           A privately used parameter to track recursion depth
 *
 * @returns {Object}            The original source object including updated, inserted, or overwritten records.
 */
function mergeObject(
	original,
	other = {},
	{
		insertKeys = true,
		insertValues = true,
		overwrite = true,
		inplace = true,
		enforceTypes = false,
	} = {},
	_d = 0
) {
	other = other || {};
	if (!(original instanceof Object) || !(other instanceof Object)) {
		throw new Error('One of original or other are not Objects!');
	}
	let depth = _d + 1;

	// Maybe copy the original data at depth 0
	if (!inplace && _d === 0) original = duplicate(original);

	// Enforce object expansion at depth 0
	if (_d === 0 && Object.keys(original).some(k => /\./.test(k)))
		original = expandObject(original);
	if (_d === 0 && Object.keys(other).some(k => /\./.test(k)))
		other = expandObject(other);

	// Iterate over the other object
	for (let [k, v] of Object.entries(other)) {
		let tv = getType(v);

		// Prepare to delete
		let toDelete = false;
		if (k.startsWith('-=')) {
			k = k.slice(2);
			toDelete = v === null;
		}

		// Get the existing object
		let x = original[k];
		let has = original.hasOwnProperty(k);
		let tx = getType(x);

		// Ensure that inner objects exist
		if (!has && tv === 'Object') {
			x = original[k] = {};
			has = true;
			tx = 'Object';
		}

		// Case 1 - Key exists
		if (has) {
			// 1.1 - Recursively merge an inner object
			if (tv === 'Object' && tx === 'Object') {
				mergeObject(
					x,
					v,
					{
						insertKeys: insertValues,
						insertValues: true,
						overwrite: overwrite,
						inplace: true,
						enforceTypes: enforceTypes,
					},
					depth
				);
			}

			// 1.2 - Remove an existing key
			else if (toDelete) {
				delete original[k];
			}

			// 1.3 - Overwrite existing value
			else if (overwrite) {
				if (tx && tv !== tx && enforceTypes) {
					throw new Error(
						`Mismatched data types encountered during object merge.`
					);
				}
				original[k] = v;
			}

			// 1.4 - Insert new value
			else if (x === undefined && insertValues) {
				original[k] = v;
			}
		}

		// Case 2 - Key does not exist
		else if (!toDelete) {
			let canInsert =
				(depth === 1 && insertKeys) || (depth > 1 && insertValues);
			if (canInsert) original[k] = v;
		}
	}

	// Return the object for use
	return original;
}

/* -------------------------------------------- */

/**
 * Deeply difference an object against some other, returning the update keys and values
 * @param {Object} original
 * @param {Object} other
 * @return {Object}
 */
function diffObject(original, other) {
	function _difference(v0, v1) {
		let t0 = getType(v0);
		let t1 = getType(v1);
		if (t0 !== t1) return [true, v1];
		if (t0 === 'Array') return [!v0.equals(v1), v1];
		if (t0 === 'Object') {
			if (isObjectEmpty(v0) !== isObjectEmpty(v1)) return [true, v1];
			let d = diffObject(v0, v1);
			return [!isObjectEmpty(d), d];
		}
		return [v0 !== v1, v1];
	}

	// Recursively call the _difference function
	return Object.keys(other).reduce((obj, key) => {
		let [isDifferent, difference] = _difference(original[key], other[key]);
		if (isDifferent) obj[key] = difference;
		return obj;
	}, {});
}

/* -------------------------------------------- */

/**
 * A helper function which tests whether an object has a property or nested property given a string key.
 * The string key supports the notation a.b.c which would return true if object[a][b][c] exists
 * @param object {Object}   The object to traverse
 * @param key {String}      An object property with notation a.b.c
 *
 * @return {Boolean}        An indicator for whether the property exists
 */
function hasProperty(object, key) {
	if (!key) return false;
	let target = object;
	for (let p of key.split('.')) {
		if (target.hasOwnProperty(p)) target = target[p];
		else return false;
	}
	return true;
}

/* -------------------------------------------- */

/**
 * A helper function which searches through an object to retrieve a value by a string key.
 * The string key supports the notation a.b.c which would return object[a][b][c]
 * @param object {Object}   The object to traverse
 * @param key {String}      An object property with notation a.b.c
 *
 * @return {*}              The value of the found property
 */
function getProperty(object, key) {
	if (!key) return undefined;
	let target = object;
	for (let p of key.split('.')) {
		if (p in target) target = target[p];
		else return undefined;
	}
	return target;
}

/* -------------------------------------------- */

/**
 * A helper function which searches through an object to assign a value using a string key
 * This string key supports the notation a.b.c which would target object[a][b][c]
 *
 * @param object {Object}   The object to update
 * @param key {String}      The string key
 * @param value             The value to be assigned
 *
 * @return {Boolean}        A flag for whether or not the object was updated
 */
function setProperty(object, key, value) {
	let target = object;
	let changed = false;

	// Convert the key to an object reference if it contains dot notation
	if (key.indexOf('.') !== -1) {
		let parts = key.split('.');
		key = parts.pop();
		target = parts.reduce((o, i) => {
			if (!o.hasOwnProperty(i)) o[i] = {};
			return o[i];
		}, object);
	}

	// Update the target
	if (target[key] !== value) {
		changed = true;
		target[key] = value;
	}

	// Return changed status
	return changed;
}

/* -------------------------------------------- */
/*  Form Methods                                */
/* -------------------------------------------- */

RegExp.escape = function(string) {
	return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};

/* -------------------------------------------- */

validateForm = function(formElement) {
	const form = new FormData(formElement);
	const formData = {};

	// Always include Boolean checkboxes
	for (let box of formElement.querySelectorAll('input[type="checkbox"]')) {
		if (box.disabled) continue;
		formData[box.name] = Boolean(box.checked) || false;
	}

	// Grab images which are editable
	for (let img of formElement.querySelectorAll('img[data-edit]')) {
		if (img.getAttribute('disabled')) continue;
		formData[img.dataset.edit] = img.src.replace(
			window.location.origin + '/',
			''
		);
	}

	// Grab divs which are editable
	for (let div of formElement.querySelectorAll('div[data-edit]')) {
		if (div.getAttribute('disabled')) continue;
		formData[div.dataset.edit] = div.innerHTML.trim();
	}

	// Iterate over form elements, validating and converting type
	form.forEach((v, k) => {
		let input = formElement[k];

		// Skip checkboxes which have already been handled
		if (input.type === 'checkbox') return;

		// Skip fields which are set as disabled
		if (input.disabled) return;

		// Cast the input to a specific dtype
		let dtype = input.dataset.dtype || 'String';
		if (dtype !== 'String' && v !== '') {
			formData[k] =
				window[dtype] instanceof Function ? window[dtype](v) : v;
		} else formData[k] = v;
	});
	return formData;
};

/* -------------------------------------------- */

/**
 * Express a timestamp as a relative string
 * @param timeStamp {Date}
 * @return {string}
 */
timeSince = function(timeStamp) {
	timeStamp = new Date(timeStamp);
	let now = new Date(),
		secondsPast = (now - timeStamp) / 1000,
		since = '';

	// Format the time
	if (secondsPast < 60) {
		since = parseInt(secondsPast);
		if (since <= 0) return 'Now';
		else since = since + 's';
	} else if (secondsPast < 3600) since = parseInt(secondsPast / 60) + 'm';
	else if (secondsPast <= 86400) since = parseInt(secondsPast / 3600) + 'h';
	else {
		let hours = parseInt(secondsPast / 3600),
			days = parseInt(hours / 24);
		since = `${days}d ${hours % 24}h`;
	}

	// Return the string
	return since + ' ago';
};

/* -------------------------------------------- */
/*  Colors
/* -------------------------------------------- */

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 1] and
 * returns h, s, and v in the set [0, 1].
 *
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSV representation
 */
function rgbToHsv(r, g, b) {
	let max = Math.max(r, g, b),
		min = Math.min(r, g, b);
	let h,
		s,
		v = max;
	let d = max - min;
	s = max == 0 ? 0 : d / max;
	if (max == min) {
		h = 0; // achromatic
	} else {
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, v];
}

/* -------------------------------------------- */

/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 1].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  v       The value
 * @return  Array           The RGB representation
 */
function hsvToRgb(h, s, v) {
	let r, g, b;
	let i = Math.floor(h * 6);
	let f = h * 6 - i;
	let p = v * (1 - s);
	let q = v * (1 - f * s);
	let t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0:
			(r = v), (g = t), (b = p);
			break;
		case 1:
			(r = q), (g = v), (b = p);
			break;
		case 2:
			(r = p), (g = v), (b = t);
			break;
		case 3:
			(r = p), (g = q), (b = v);
			break;
		case 4:
			(r = t), (g = p), (b = v);
			break;
		case 5:
			(r = v), (g = p), (b = q);
			break;
	}
	return [r, g, b];
}

/**
 * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
 * @param {Array.<Number>} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
 * @return {Number} Number in hexadecimal.
 */
function rgbToHex(rgb) {
	return (
		((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + ((rgb[2] * 255) | 0)
	);
}

/* ----------------------------------------- */

/**
 * Convert a hex color code to an RGB array
 * @param {number} hex    A hex color number
 * @return {Array}        An array of [r,g,b] colors normalized on the range of [0,1]
 */
function hexToRGB(hex) {
	return [
		((hex >> 16) & 0xff) / 255,
		((hex >> 8) & 0xff) / 255,
		(hex & 0xff) / 255,
	];
}

/* ----------------------------------------- */

/**
 * Convert a hex color code to an RGBA color string which can be used for CSS styling
 * @param {number} hex    A hex color number
 * @param {number} alpha  A level of transparency
 * @return {string}       An rgba style string
 */
function hexToRGBAString(hex, alpha = 1.0) {
	const rgb = hexToRGB(hex).map(h => h * 255);
	rgb.push(alpha);
	return `rgba(${rgb.join(', ')})`;
}

/* ----------------------------------------- */

/**
 * Convert a string color to a hex integer
 * @param {String} color    The string color
 * @return {Number}         The hexidecimal color code
 */
function colorStringToHex(color) {
	if (!color) return null;
	color = color.startsWith('#') ? color.substr(1) : color;
	return parseInt(color, 16);
}

/* -------------------------------------------- */
/*  Version Checking
/* -------------------------------------------- */

/**
 * Return whether or not a version (v1) is more advanced than some other version (v0)
 * Supports numeric or string version numbers
 * @param {Number|String} v0
 * @param {Number|String} v1
 * @return {Boolean}
 */
function isNewerVersion(v1, v0) {
	// Handle numeric versions
	if (typeof v1 === 'number' && typeof v0 === 'number') return v1 > v0;

	// Handle string parts
	let v1Parts = String(v1).split('.');
	let v0Parts = String(v0).split('.');

	// Iterate over version parts
	for (let [i, p1] of v1Parts.entries()) {
		let p0 = v0Parts[i];

		// If the prior version doesn't have a part, v1 wins
		if (p0 === undefined) return true;

		// If both parts are numbers, use numeric comparison to avoid cases like "12" < "5"
		if (Number.isNumeric(p0) && Number.isNumeric(p1)) {
			if (Number(p1) !== Number(p0)) return Number(p1) > Number(p0);
		}

		// Otherwise, compare as strings
		else if (p1 < p0) return false;
	}

	// If there are additional parts to v0, it is not newer
	if (v0Parts.length > v1Parts.length) return false;

	// If we have not returned false by now, its either newer or the same
	return !v1Parts.equals(v0Parts);
}

/* -------------------------------------------- */

/**
 * Generate a random ID
 * Generate random number and convert it to base 36 and remove the '0.' at the beginning
 * As long as the string is not long enough, generate more random data into it
 * Use substring in case we generated a string with a length higher than the requested length
 *
 * @param {number} length    The length of the random ID to generate
 * @return {string}          Return a string containing random letters and numbers
 */
function randomID(length = 10) {
	const rnd = () =>
		Math.random()
			.toString(36)
			.substr(2);
	let id = '';
	while (id.length < length) id += rnd();
	return id.substr(0, length);
}

try {
	module.exports = {
		duplicate,
		diffObject,
		filterObject,
		flattenObject,
		expandObject,
		invertObject,
		isObjectEmpty,
		mergeObject,
		hasProperty,
		getProperty,
		setProperty,
		validateForm,
		hsvToRgb,
		rgbToHsv,
		rgbToHex,
		colorStringToHex,
		isNewerVersion,
		randomID,
	};
} catch (err) {}

/* -------------------------------------------- */

const CONFIG = {
	/**
	 * Configure debugging flags to display additional information
	 */
	debug: {
		hooks: false,
		sight: false,
		av: false,
		avclient: false,
	},

	/**
	 * Configuration for the default Actor entity class
	 * @private
	 */
	Actor: {
		entityClass: null,
		collection: null,
		sheetClasses: {},
		sidebarIcon: 'fas fa-user',
	},

	/**
	 * Configuration for the default Item entity class
	 */
	Item: {
		entityClass: null,
		collection: null,
		sheetClass: null,
		sheetClasses: {},
		sidebarIcon: 'fas fa-suitcase',
	},

	/**
	 * Configuration for the JournalEntry entity
	 */
	JournalEntry: {
		entityClass: null,
		sheetClass: null,
		noteIcons: {
			Anchor: 'icons/svg/anchor.svg',
			Book: 'icons/svg/book.svg',
			Bridge: 'icons/svg/bridge.svg',
			Cave: 'icons/svg/cave.svg',
			Castle: 'icons/svg/castle.svg',
			City: 'icons/svg/city.svg',
			'Hanging Sign': 'icons/svg/hanging-sign.svg',
			House: 'icons/svg/house.svg',
			Mountain: 'icons/svg/mountain.svg',
			'Oak Tree': 'icons/svg/oak.svg',
			Obelisk: 'icons/svg/obelisk.svg',
			Ruins: 'icons/svg/ruins.svg',
			Temple: 'icons/svg/temple.svg',
			Tower: 'icons/svg/tower.svg',
			Skull: 'icons/svg/skull.svg',
			Statue: 'icons/svg/statue.svg',
			Sword: 'icons/svg/sword.svg',
			Village: 'icons/svg/village.svg',
			Waterfall: 'icons/svg/waterfall.svg',
			Windmill: 'icons/svg/windmill.svg',
		},
		sidebarIcon: 'fas fa-book-open',
	},

	Macro: {
		entityClass: null,
		collection: null,
		sheetClass: null,
		sidebarIcon: 'fas fa-terminal',
	},

	/**
	 * Configuration for the default Scene entity class
	 * @private
	 */
	Scene: {
		entityClass: null,
		collection: null,
		sheetClass: null,
		notesClass: null,
		sidebarIcon: 'fas fa-map',
	},

	/**
	 * Configuration for the default Playlist entity class
	 * @private
	 */
	Playlist: {
		entityClass: null,
		collection: null,
		sheetClass: null,
		sidebarIcon: 'fas fa-music',
	},

	/**
	 * Configuration for RollTable random draws
	 * @private
	 */
	RollTable: {
		entityClass: null,
		collection: null,
		sheetClass: null,
		sidebarIcon: 'fas fa-th-list',
		resultIcon: 'icons/svg/d20-black.svg',
	},

	/**
	 * Configure the default Token text style so that it may be reused and overridden by modules
	 * @type {PIXI.TextStyle}
	 */
	canvasTextStyle: new PIXI.TextStyle({
		fontFamily: 'Signika',
		fontSize: 36,
		fill: '#FFFFFF',
		stroke: '#111111',
		strokeThickness: 1,
		dropShadow: true,
		dropShadowColor: '#000000',
		dropShadowBlur: 4,
		dropShadowAngle: 0,
		dropShadowDistance: 0,
		align: 'center',
		wordWrap: false,
	}),

	/**
	 * The control icons used for rendering common HUD operations
	 * @type {Object}
	 */
	controlIcons: {
		combat: 'icons/svg/combat.svg',
		visibility: 'icons/svg/cowled.svg',
		effects: 'icons/svg/aura.svg',
		lock: 'icons/svg/padlock.svg',
		up: 'icons/svg/up.svg',
		down: 'icons/svg/down.svg',
		defeated: 'icons/svg/skull.svg',
	},

	/**
	 * Suggested font families that are displayed wherever a choice is presented
	 * @type {Array}
	 */
	fontFamilies: [
		'Arial',
		'Arial Black',
		'Comic Sans MS',
		'Courier New',
		'Times New Roman',
		'Signika',
	],

	/**
	 * The default font family used for text labels on the PIXI Canvas
	 * @type {String}
	 */
	defaultFontFamily: 'Signika',

	/**
	 * Available Weather Effects implemntations
	 * @type {Array}
	 */
	weatherEffects: {},

	/**
	 * An array of status effect icons which can be applied to Tokens
	 * @type {Array}
	 */
	statusEffects: [
		'icons/svg/skull.svg',
		'icons/svg/unconscious.svg',
		'icons/svg/sleep.svg',
		'icons/svg/daze.svg',

		'icons/svg/falling.svg',
		'icons/svg/blind.svg',
		'icons/svg/deaf.svg',
		'icons/svg/stoned.svg',

		'icons/svg/target.svg',
		'icons/svg/eye.svg',
		'icons/svg/net.svg',
		'icons/svg/blood.svg',

		'icons/svg/terror.svg',
		'icons/svg/radiation.svg',
		'icons/svg/biohazard.svg',
		'icons/svg/poison.svg',

		'icons/svg/regen.svg',
		'icons/svg/degen.svg',
		'icons/svg/sun.svg',
		'icons/svg/angel.svg',

		'icons/svg/fire.svg',
		'icons/svg/frozen.svg',
		'icons/svg/lightning.svg',
		'icons/svg/acid.svg',

		'icons/svg/fire-shield.svg',
		'icons/svg/ice-shield.svg',
		'icons/svg/mage-shield.svg',
		'icons/svg/holy-shield.svg',
	],

	/**
	 * A mapping of core audio effects used which can be replaced by systems or mods
	 * @type {Object}
	 */
	sounds: {
		dice: 'sounds/dice.wav',
		lock: 'sounds/lock.wav',
		notification: 'sounds/notify.wav',
		combat: 'sounds/drums.wav',
	},

	/**
	 * Define the set of supported languages for localization
	 * @type {Object}
	 */
	supportedLanguages: {
		en: 'English',
	},

	/**
	 * Maximum canvas zoom scale
	 * @type {Number}
	 */
	maxCanvasZoom: 3.0,

	/**
	 * Default configuration options for TinyMCE editors
	 */
	TinyMCE: {
		css: ['/css/mce.css'],
		plugins: 'lists image table hr code save',
		toolbar:
			'styleselect bullist numlist image table hr removeformat code save',
	},

	/**
	 * Configuration for the WebRTC implementation class
	 * @type {Object}
	 */
	WebRTC: {
		clientClass: null,
		emitVolumeInterval: 50,
		speakingThresholdEvents: 2,
		speakingHistoryLength: 10,
	},
};

/**
 * A helper class to provide common functionality for working with HTML5 audio and Howler instances
 * A singleton instance of this class is available as ``game.audio``
 *
 * Audio playback in Foundry VTT is managed by Howler.js (https://howlerjs.com/). Several methods and
 * attributes in this API return :class:`Howl` instances. See the Howler documentation for details
 * and example usage of the Howl API.
 */
class AudioHelper {
	constructor() {
		if (game.audio instanceof this.constructor) {
			throw new Error(
				'You may not re-initialize the singleton AudioHelper. Use game.audio instead.'
			);
		}

		/**
		 * The set of Howl instances which have been created for different audio paths
		 * @type {Object}
		 */
		this.sounds = {};

		/**
		 * A user gesture must be registered before audio can be played.
		 * This Array contains the Howl instances which are requested for playback prior to a gesture.
		 * Once a gesture is observed, we begin playing all elements of this Array.
		 * @type {Array}
		 */
		this.pending = [];

		/**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {Boolean}
		 */
		this.locked = true;

		/**
		 * Audio Context singleton used for analysing audio levels of each stream
		 * Only created if necessary to listen to audio streams.
		 *
		 * @type {AudioContext}
		 */
		this._audioContext = null;

		/**
		 * Map of all streams that we listen to for determining the decibel levels.
		 * Used for analyzing audio levels of each stream.
		 * Format of the object stored is :
		 * {id:
		 *   {
		 *     stream: MediaStream,
		 *     analyser: AudioAnalyser,
		 *     interval: Number,
		 *     callback: Function
		 *   }
		 * }
		 *
		 * @type {Object}
		 */
		this._analyserStreams = {};

		/**
		 * Interval ID as returned by setInterval for analysing the volume of streams
		 * When set to 0, means no timer is set.
		 * @type {Number}
		 */
		this._analyserInterval = 0;

		/**
		 * Fast Fourrier Transform Array.
		 * Used for analysing the decibel level of streams. The array is allocated only once
		 * then filled by the analyser repeatedly. We only generate it when we need to listen to
		 * a stream's level, so we initialize it to null.
		 * @type {Float32Array}
		 */
		this._fftArray = null;
	}

	/* -------------------------------------------- */

	/**
	 * Register client-level settings for global volume overrides
	 */
	static registerSettings() {
		// Playlist Volume
		game.settings.register('core', 'globalPlaylistVolume', {
			name: 'Global Playlist Volume',
			hint: 'Define a global playlist volume modifier',
			scope: 'client',
			config: false,
			default: 1.0,
			type: Number,
			onChange: volume => {
				for (let p of game.playlists.entities) {
					p.sounds
						.filter(s => s.playing)
						.forEach(s => p.playSound(s));
				}
			},
		});

		// Ambient Volume
		game.settings.register('core', 'globalAmbientVolume', {
			name: 'Global Ambient Volume',
			hint: 'Define a global ambient volume modifier',
			scope: 'client',
			config: false,
			default: 1.0,
			type: Number,
			onChange: volume => {
				if (canvas.ready) {
					if (canvas.background.isVideo)
						canvas.background.source.volume = volume;
					canvas.sounds.update();
				}
			},
		});

		// UI Volume
		game.settings.register('core', 'globalInterfaceVolume', {
			name: 'Global Interface Volume',
			hint: 'Define a global interface volume modifier',
			scope: 'client',
			config: false,
			default: 0.5,
			type: Number,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create a Howl instance
	 * @param src
	 * @param preload
	 * @param autoplay
	 * @return {Howl}
	 */
	create({
		src,
		preload = false,
		autoplay = false,
		volume = 0.0,
		loop = false,
	} = {}) {
		// Return an existing howl if one already exists for the source
		if (src in this.sounds) {
			return this.sounds[src].howl;
		}

		// Create the Howl instance
		let howl = new Howl({
			src: src,
			preload: preload,
			autoplay: autoplay,
			volume: volume,
			loop: loop,
			html5: true,
			onload: () => (this.sounds[src].loaded = true),
			onplay: id => this.sounds[src].ids.push(id),
		});

		// Record the Howl instance for later use
		this.sounds[src] = {
			howl: howl,
			loaded: false,
			ids: [],
		};
		return howl;
	}

	/* -------------------------------------------- */

	/**
	 * Play a single audio effect by it's source path and Howl ID
	 * @param {String} src
	 * @param {Number} id
	 */
	play(src, id) {
		let howl = this.sounds[src];
		if (!howl)
			throw new Error('Howl instance does not exist for sound ' + src);
		howl.play(id);
	}

	/* -------------------------------------------- */

	/**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 */
	awaitFirstGesture() {
		if (!this.locked) return;
		const interactions = [
			'contextmenu',
			'auxclick',
			'mousedown',
			'mouseup',
			'keydown',
		];
		interactions.forEach(event =>
			document.addEventListener(event, this._onFirstGesture.bind(this), {
				once: true,
			})
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the first observed user gesture
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if (!this.pending.length) return;
		console.log(
			`${vtt} | Activating pending audio playback with user gesture.`
		);
		this.locked = false;
		this.pending.forEach(fn => fn());
		this.pending = [];
	}

	/* -------------------------------------------- */

	preload(data) {
		game.socket.emit('preloadAudio', data);
		this.constructor.preload(data);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Open socket listeners which transact ChatMessage data
	 * @private
	 */
	static socketListeners(socket) {
		socket.on('playAudio', this.play);
		socket.on('preloadAudio', this.preload);
	}

	/* -------------------------------------------- */

	/**
	 * Play a one-off sound effect which is not part of a Playlist
	 *
	 * @param {Object} data           An object configuring the audio data to play
	 * @param {String} data.src       The audio source file path, either a public URL or a local path relative to the public directory
	 * @param {Number} data.volume    The volume level at which to play the audio, between 0 and 1.
	 * @param {Boolean} data.autoplay Begin playback of the audio effect immediately once it is loaded.
	 * @param {Boolean} data.loop     Loop the audio effect and continue playing it until it is manually stopped.
	 * @param {Boolean} [push]        Push the audio sound effect to other connected clients?
	 *
	 * @return {Howl}                 A Howl instance which controls audio playback.
	 *
	 * @example
	 * // Play the sound of a locked door for all players
	 * Audio.play({src: "sounds/lock.wav", volume: 0.8, autoplay: true, loop: false}, true);
	 */
	static play(data, push = false) {
		let audioData = mergeObject(
			{ src: null, volume: 1.0, autoplay: true, loop: false },
			data,
			{ insertKeys: true }
		);
		audioData.volume *= game.settings.get('core', 'globalInterfaceVolume');
		if (push) game.socket.emit('playAudio', audioData);
		new Howl(audioData);
	}

	/* -------------------------------------------- */

	/**
	 * Create a Howl object and load it to be ready for later playback
	 * @param {Object} data         The audio data to preload
	 */
	static preload(data) {
		game.audio
			.create({
				src: data.path,
				autoplay: false,
				preload: true,
			})
			.load();
	}

	/* -------------------------------------------- */

	/**
	 * Returns the volume value based on a range input volume control's position.
	 * This is using an exponential approximation of the logarithmic nature of audio level perception
	 * Based on https://www.dr-lex.be/info-stuff/volumecontrols.html
	 * We're using x^3 by default instead of x^4 otherwise the audio becomes nearly silent around the 40% mark.
	 * @param {number|string} value   Value between [0, 1] of the range input
	 * @param {number} order          [optional] the exponent of the curve (default: 2)
	 * @return {number}
	 */
	static inputToVolume(value, order = 2) {
		return Math.pow(parseFloat(value), order);
	}

	/* -------------------------------------------- */

	/**
	 * Counterpart to inputToVolume()
	 * Returns the input range value based on a volume
	 * @param {number} volume     Value between [0, 1] of the volume level
	 * @param {number} order      [optional] the exponent of the curve (default: 2)
	 * @return {number}
	 */
	static volumeToInput(volume, order = 2) {
		return Math.pow(volume, 1 / order);
	}

	/* -------------------------------------------- */
	/*  Audio Stream Analysis                       */
	/* -------------------------------------------- */

	/**
	 * Returns a singleton AudioContext if one can be created.
	 * An audio context may not be available due to limited resources or browser compatibility
	 * in which case null will be returned
	 *
	 * @return {AudioContext}   A singleton AudioContext or null if one is not available
	 */
	getAudioContext() {
		if (this._audioContext) return this._audioContext;
		try {
			// Use one Audio Context for all the analysers.
			return new (AudioContext || webkitAudioContext)();
		} catch (err) {
			console.log(
				'Could not create AudioContext. Will not be able to analyse stream volumes.'
			);
		}
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * Registers a stream for periodic reports of audio levels.
	 * Once added, the callback will be called with the maximum decibel level of
	 * the audio tracks in that stream since the last time the event was fired.
	 * The interval needs to be a multiple of AudioHelper.levelAnalyserNativeInterval which defaults at 50ms
	 *
	 * @param {string} id             An id to assign to this report. Can be used to stop reports
	 * @param {MediaStream} stream    The media stream to report on its audio tracks
	 * @param {Function} callback     The callback function to call with the decibel level. `callback(dbLevel)`
	 * @param {number} interval       (optional) The interval at which to produce reports.
	 * @param {number} smoothing      (optional) The smoothingTimeConstant to set on the audio analyser. Refer to AudioAnalyser API docs.
	 * @return {boolean}              Returns whether or not listening to the stream was successful
	 */
	startLevelReports(id, stream, callback, interval = 50, smoothing = 0.1) {
		let audioContext = this.getAudioContext();
		if (audioContext === null) return false;

		// Clean up any existing report with the same ID
		this.stopLevelReports(id);

		// Make sure this stream has audio tracks, otherwise we can't connect the analyser to it
		if (stream.getAudioTracks().length === 0) return false;

		// Create the analyser
		let analyser = audioContext.createAnalyser();
		analyser.fftSize = 512;
		analyser.smoothingTimeConstant = smoothing;

		// Connect the analyser to the MediaStreamSource
		audioContext.createMediaStreamSource(stream).connect(analyser);
		this._analyserStreams[id] = {
			stream,
			analyser,
			interval,
			callback,
			// Used as a counter of 50ms increments in case the interval is more than 50
			_lastEmit: 0,
		};

		// Ensure the analyser timer is started as we have at least one valid stream to listen to
		this._ensureAnalyserTimer();
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Stop sending audio level reports
	 * This stops listening to a stream and stops sending reports.
	 * If we aren't listening to any more streams, cancel the global analyser timer.
	 * @param {string} id      The id of the reports that passed to startLevelReports.
	 */
	stopLevelReports(id) {
		delete this._analyserStreams[id];
		if (isObjectEmpty(this._analyserStreams)) this._cancelAnalyserTimer();
	}

	/* -------------------------------------------- */

	/**
	 * Ensures the global analyser timer is started
	 *
	 * We create only one timer that runs every 50ms and only create it if needed, this is meant to optimize things
	 * and avoid having multiple timers running if we want to analyse multiple streams at the same time.
	 * I don't know if it actually helps much with performance but it's expected that limiting the number of timers
	 * running at the same time is good practice and with JS itself, there's a potential for a timer congestion
	 * phenomenon if too many are created.
	 * @private
	 */
	_ensureAnalyserTimer() {
		if (this._analyserInterval === 0) {
			this._analyserInterval = setInterval(
				this._emitVolumes.bind(this),
				AudioHelper.levelAnalyserNativeInterval
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Cancel the global analyser timer
	 * If the timer is running and has become unnecessary, stops it.
	 * @private
	 */
	_cancelAnalyserTimer() {
		if (this._analyserInterval !== 0) {
			clearInterval(this._analyserInterval);
			this._analyserInterval = 0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Capture audio level for all speakers and emit a webrtcVolumes custom event with all the volume levels
	 * detected since the last emit.
	 * The event's detail is in the form of {userId: decibelLevel}
	 * @private
	 */
	_emitVolumes() {
		for (let id in this._analyserStreams) {
			const analyserStream = this._analyserStreams[id];
			if (
				++analyserStream._lastEmit <
				analyserStream.interval /
					AudioHelper.levelAnalyserNativeInterval
			)
				continue;

			// Create the Fast Fourier Transform Array only once. Assume all analysers use the same fftSize
			if (this._fftArray === null)
				this._fftArray = new Float32Array(
					analyserStream.analyser.frequencyBinCount
				);

			// Fill the array
			analyserStream.analyser.getFloatFrequencyData(this._fftArray);
			let maxDecibel = Math.max(...this._fftArray);
			analyserStream.callback(maxDecibel, this._fftArray);
			analyserStream._lastEmit = 0;
		}
	}
}

/**
 * The Native interval for the AudioHelper to analyse audio levels from streams
 * Any interval passed to startLevelReports() would need to be a multiple of this value.
 * Defaults to 50ms.
 * @type {Number}
 */
AudioHelper.levelAnalyserNativeInterval = 50;

FONTS = {
	Signika: {
		custom: {
			families: ['Signika'],
			urls: ['fonts/signika/signika.css'],
		},
	},
	FontAwesome: {
		custom: {
			families: ['FontAwesome'],
			urls: ['fonts/fontawesome/css/all.min.css'],
		},
	},
	_loaded: [],
};

/**
 * Load font, and perform a callback once the font has been rendered
 * @param fontName
 * @param callback
 */
function loadFont(fontName, callback) {
	const font = $.extend(FONTS[fontName], {
		fontloading: function(fontFamily, fvd) {
			console.log('Foundry VTT | Loading Font: ' + fontFamily);
			let temp = document.createElement('p');
			temp.id = fontFamily;
			temp.classList.add('font-preload');
			temp.style.fontFamily = fontFamily;
			temp.style.fontSize = '0px';
			temp.style.visibility = 'hidden';
			temp.innerHTML = '.';
			document.body.appendChild(temp);
		},
		fontactive: () => {
			console.log(`${vtt} | Loaded font ${fontName}`);
			$('p#' + fontName).remove();
			if (callback) callback();
		},
		fontinactive: () => {
			console.log('Something went wrong with ' + fontName);
			$('p#' + fontName).remove();
		},
	});

	if (!FONTS._loaded.includes(fontName)) {
		WebFont.load(font);
		FONTS._loaded.push(fontName);
	}
}

class Hooks {
	/**
	 * Register a callback handler which should be triggered when a hook is triggered.
	 *
	 * @param {String} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 */
	static on(hook, fn) {
		console.log(`${vtt} | Registered callback for ${hook} hook`);
		const id = this._id++;
		this._hooks[hook] = this._hooks[hook] || [];
		this._hooks[hook].push(fn);
		this._ids[id] = fn;
		return id;
	}

	/* -------------------------------------------- */

	/**
	 * Register a callback handler for an event which is only triggered once the first time the event occurs.
	 * After a "once" hook is triggered the hook is automatically removed.
	 *
	 * @param {String} hook   The unique name of the hooked event
	 * @param {Function} fn   The callback function which should be triggered when the hook event occurs
	 */
	static once(hook, fn) {
		this._once.push(fn);
		return this.on(hook, fn);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister a callback handler for a particular hook event
	 *
	 * @param {String} hook   The unique name of the hooked event
	 * @param {Function} fn   The function that should be removed from the set of hooked callbacks
	 */
	static off(hook, fn) {
		console.log(`${vtt} | Unregistered callback for ${hook} hook`);
		if (typeof fn === 'number') {
			let id = fn;
			fn = this._ids[fn];
			delete this._ids[id];
		}
		if (!this._hooks.hasOwnProperty(hook)) return;
		const fns = this._hooks[hook];
		let idx = fns.indexOf(fn);
		if (idx !== -1) fns.splice(idx, 1);
	}

	/* -------------------------------------------- */

	/**
	 * Call all hook listeners in the order in which they were registered
	 * Hooks called this way can not be handled by returning false and will always trigger every hook callback.
	 *
	 * @param {String} hook   The hook being triggered
	 * @param {Array} args    Arguments passed to the hook callback functions
	 */
	static callAll(hook, ...args) {
		if (CONFIG.debug.hooks) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if (!this._hooks.hasOwnProperty(hook)) return;
		const fns = new Array(...this._hooks[hook]);
		for (let fn of fns) {
			this._call(hook, fn, args);
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Call hook listeners in the order in which they were registered.
	 * Continue calling hooks until either all have been called or one returns `false`.
	 *
	 * Hook listeners which return `false` denote that the original event has been adequately handled and no further
	 * hooks should be called.
	 *
	 * @param {String} hook   The hook being triggered
	 * @param {...*} args      Arguments passed to the hook callback functions
	 */
	static call(hook, ...args) {
		if (CONFIG.debug.hooks) {
			console.log(`DEBUG | Calling ${hook} hook with args:`);
			console.log(args);
		}
		if (!this._hooks.hasOwnProperty(hook)) return;
		const fns = new Array(...this._hooks[hook]);
		for (let fn of fns) {
			let callAdditional = this._call(hook, fn, args);
			if (callAdditional === false) return false;
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Call a hooked function using provided arguments and perhaps unregister it.
	 * @private
	 */
	static _call(hook, fn, args) {
		if (this._once.includes(fn)) this.off(hook, fn);
		try {
			return fn(...args);
		} catch (err) {
			console.warn(`Error thrown in hooked function ${fn.name}`);
			console.error(err);
		}
	}
}

// Static class attributes
Hooks._hooks = {};
Hooks._once = [];
Hooks._ids = {};
Hooks._id = 1;

/**
 * An enumeration of keyboard codes where the keys are constant key names and the values are numeric codes
 * @type {Object}
 */
const KEYS = {
	BACKSPACE: 8,
	TAB: 9,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	ESC: 27,
	SPACE: 32,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	DELETE: 46,
	DIGIT0: 48,
	DIGIT1: 49,
	DIGIT2: 50,
	DIGIT3: 51,
	DIGIT4: 52,
	DIGIT5: 53,
	DIGIT6: 54,
	DIGIT7: 55,
	DIGIT8: 56,
	DIGIT9: 57,
	A: 65,
	D: 68,
	S: 83,
	W: 87,
	Z: 90,
	C: 67,
	V: 86,
	NUM1: 97,
	NUM2: 98,
	NUM3: 99,
	NUM4: 100,
	NUM5: 101,
	NUM6: 102,
	NUM7: 103,
	NUM8: 104,
	NUM9: 105,
	F5: 116,
};

/* -------------------------------------------- */

class KeyboardManager {
	constructor() {
		/**
		 * A mapping of known key codes
		 * @type {Object}
		 */
		this.keys = KEYS;

		/**
		 * The set of key codes which should be captured
		 * @type {Set}
		 */
		this.codes = new Set(Object.values(KEYS));

		/**
		 * The set of key codes which are currently depressed (down)
		 * @type {Set}
		 */
		this._downKeys = null;

		/**
		 * The set of key codes which have been already handled per workflow
		 * @type {Set}
		 */
		this._handled = null;
		this._reset();

		// Status handlers
		this._moveTime = null;
		this._tabState = 0;
		this._wheelTime = 0;

		// Activate input listeners
		window.addEventListener('keydown', e => this._onKeyDown(e));
		window.addEventListener('keyup', e => this._onKeyUp(e));
		window.addEventListener('visibilitychange', e => this._reset(e));
		window.addEventListener('wheel', e => this._onWheel(e), {
			passive: false,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Reset tracking for which keys are in the down and released states
	 * @private
	 */
	_reset() {
		this._downKeys = new Set([]);
		this._handled = new Set([]);
		this._tabState = 0;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Return whether the keyCode is currently in the DOWN state
	 * @param {Number} keyCode    The key code to test
	 * @type {Boolean}
	 */
	isDown(keyCode) {
		return this._downKeys.has(keyCode);
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to test whether, given an Event, the CTRL (or CMD) keys are pressed
	 * @param event
	 * @return {Boolean}
	 */
	isCtrl(event) {
		event = event.hasOwnProperty('ctrlKey')
			? event
			: event.data.originalEvent;
		return event.ctrlKey || event.metaKey;
	}

	/* -------------------------------------------- */

	get moveKeys() {
		return [
			KEYS.UP,
			KEYS.LEFT,
			KEYS.DOWN,
			KEYS.RIGHT,
			KEYS.W,
			KEYS.A,
			KEYS.S,
			KEYS.D,
			KEYS.NUM1,
			KEYS.NUM2,
			KEYS.NUM3,
			KEYS.NUM4,
			KEYS.NUM5,
			KEYS.NUM6,
			KEYS.NUM7,
			KEYS.NUM8,
			KEYS.NUM9,
		];
	}

	/* -------------------------------------------- */

	get hasFocus() {
		return $(':focus').length ? true : false;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	_onKeyDown(event) {
		let kc = event.keyCode;
		if ([91, 224].includes(kc)) kc = KEYS.CTRL;

		// Don't handle codes which are not tracked, or have already been handled
		if (!this.codes.has(kc) || this._handled.has(kc)) return;

		// Register that the key is down and handle it
		this._downKeys.add(kc);
		this._handleKeys(event, kc, false);
	}

	/* -------------------------------------------- */

	_onKeyUp(event) {
		let kc = event.keyCode;
		if ([91, 224].includes(kc)) kc = KEYS.CTRL;

		// Handle valid codes
		if (!this.codes.has(kc)) return;
		this._downKeys.delete(kc);
		this._handled.delete(kc);
		this._handleKeys(event, kc, true);
	}

	/* -------------------------------------------- */

	/**
	 * Delegate tracked key codes by dispatching to their various handlers
	 * @param {Event} event     The keydown or keyup event
	 * @param {Number} kc       The key-code being executed
	 * @param {Boolean} up      A flag for whether the key is down or up
	 * @private
	 */
	_handleKeys(event, kc, up) {
		// Collect meta modifiers
		const modifiers = {
			isShift: event.shiftKey,
			isCtrl: event.ctrlKey || event.modKey,
			isAlt: event.altKey,
			hasFocus: this.hasFocus,
		};

		// Disptach events to bound handlers
		if (kc === KEYS.TAB) this._onTab(event, up, modifiers);
		else if (kc === KEYS.ESC) this._onEscape(event, up, modifiers);
		else if (kc === KEYS.SPACE) this._onSpace(event, up, modifiers);
		else if (this.moveKeys.includes(kc))
			this._onMovement(event, up, modifiers);
		else if (Number.between(kc, KEYS.DIGIT0, KEYS.DIGIT9))
			this._onDigit(event, up, modifiers);
		else if (kc === KEYS.Z) this._onUndo(event, up, modifiers);
		else if ([KEYS.DELETE, KEYS.BACKSPACE].includes(kc))
			this._onDelete(event, up, modifiers);
		else if (kc === KEYS.ALT) this._onAlt(event, up, modifiers);
		else if (kc === KEYS.C) this._onCopy(event, up, modifiers);
		else if (kc === KEYS.V) this._onPaste(event, up, modifiers);
	}

	/* -------------------------------------------- */

	/**
	 * Master mouse-wheel event keyboard handler
	 * @private
	 */
	_onWheel(event) {
		// Prevent zooming the entire browser window
		if (event.ctrlKey) event.preventDefault();

		// Handle wheel events for the canvas if it is ready and if it is our hover target
		let hover = document.elementFromPoint(event.clientX, event.clientY);
		if (canvas.ready && hover && hover.id === 'board') {
			event.preventDefault();
			let layer = canvas.activeLayer;
			let isCtrl = event.ctrlKey || event.metaKey,
				isShift = event.shiftKey;

			// Case 1 - rotate tokens or tiles
			if (layer instanceof PlaceablesLayer && (isCtrl || isShift))
				layer._onMouseWheel(event);
			// Case 2 - zoom the canvas
			else canvas._onMouseWheel(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle TAB keypress events
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onTab(event, up, modifiers) {
		// Always prevent tab actions if a form field is not in focus
		if (!modifiers.hasFocus) event.preventDefault();
		else return;
		if (up || !canvas.ready) {
			this._tabState = 0;
			return;
		}
		if (this._tabState > 0) return;

		// Attempt to cycle tokens, otherwise re-center the canvas
		let cycled = canvas.tokens.cycleTokens(!modifiers.shiftKey);
		if (!cycled) canvas.recenter();
		this._tabState = 1;
	}

	/* -------------------------------------------- */

	/**
	 * Handle ESC keypress events
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onEscape(event, up, modifiers) {
		if (up || modifiers.hasFocus) return;

		// Save fog of war if there are pending changes
		if (canvas.ready) canvas.sight.saveFog();

		// Case 1 - dismiss an open context menu
		if (ui.context && ui.context.menu.length) ui.context.close();
		// Case 2 - close open UI windows
		else if (Object.keys(ui.windows).length) {
			Object.values(ui.windows).forEach(app => app.close());
		}

		// Case 3 (GM) - release controlled objects
		else if (
			canvas.ready &&
			game.user.isGM &&
			Object.keys(canvas.activeLayer._controlled).length
		) {
			event.preventDefault();
			canvas.activeLayer.releaseAll();
		}

		// Case 4 - toggle the main menu
		else ui.menu.toggle();

		// Flag the keydown workflow as handled
		this._handled.add(event.keyCode);
	}

	/* -------------------------------------------- */

	/**
	 * Handle SPACE keypress events
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onSpace(event, up, modifiers) {
		const ruler = canvas.controls.ruler;
		if (up) return;

		// Move along a measured ruler
		if (canvas.ready && ruler.active) {
			let moved = ruler.moveToken(event);
			if (moved) event.preventDefault();
		}

		// Pause the game
		else if (!modifiers.hasFocus && game.user.isGM) {
			event.preventDefault();
			game.togglePause(null, true);
		}

		// Flag the keydown workflow as handled
		this._handled.add(event.keyCode);
	}

	/* -------------------------------------------- */

	/**
	 * Handle ALT keypress events
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onAlt(event, up, modifiers) {
		if (!canvas.ready) return;
		event.preventDefault();

		// Highlight placeable objects on any layers which are visible
		const layers = canvas.layers.filter(
			l => l.objects && l.objects.visible
		);
		for (let layer of layers) {
			layer.placeables
				.filter(t => t.visible)
				.forEach(t => {
					if (!up) t._onMouseOver(event);
					else t._onMouseOut(event);
				});
		}

		// Flag the keydown workflow as handled
		if (!up) this._handled.add(event.keyCode);
	}

	/* -------------------------------------------- */

	/**
	 * Handle WASD or ARROW keypress events
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onMovement(event, up, modifiers) {
		if (!canvas.ready || up || modifiers.hasFocus) return;
		event.preventDefault();
		const layer = canvas.activeLayer;

		// Delay 50ms before shifting tokens in order to capture diagonal movements
		if (layer instanceof TokenLayer || layer instanceof TilesLayer) {
			setTimeout(() => this._handleMovement(event, layer), 50);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle keyboard movement for a PlaceablesLayer where object movement is supported.
	 * @private
	 */
	_handleMovement(event, layer) {
		// Throttle keyboard movement to once per 150ms
		let now = Date.now();
		if (now - this._moveTime < 150) return;
		this._moveTime = now;

		// Get controlled objects
		let objects = layer.placeables.filter(o => o._controlled);
		if (objects.length === 0) return;
		let dx = 0,
			dy = 0;

		// Regular movement
		if ([KEYS.W, KEYS.UP, KEYS.NUM8].some(k => this.isDown(k))) dy -= 1;
		if ([KEYS.A, KEYS.LEFT, KEYS.NUM4].some(k => this.isDown(k))) dx -= 1;
		if ([KEYS.S, KEYS.DOWN, KEYS.NUM2].some(k => this.isDown(k))) dy += 1;
		if ([KEYS.D, KEYS.RIGHT, KEYS.NUM6].some(k => this.isDown(k))) dx += 1;

		// Diagonal movement
		if (this.isDown(KEYS.NUM1)) {
			dx -= 1;
			dy += 1;
		}
		if (this.isDown(KEYS.NUM3)) {
			dx += 1;
			dy += 1;
		}
		if (this.isDown(KEYS.NUM7)) {
			dx -= 1;
			dy -= 1;
		}
		if (this.isDown(KEYS.NUM9)) {
			dx += 1;
			dy -= 1;
		}

		// Rotate or shift tokens
		return layer.moveMany({ dx, dy, rotate: event.shiftKey });
	}

	/* -------------------------------------------- */

	/**
	 * Handle number key presses
	 * @param {Event} event       The original digit key press
	 * @param {boolean} up        Is it a keyup?
	 * @param {Object}modifiers   What modifiers affect the keypress?
	 * @private
	 */
	_onDigit(event, up, modifiers) {
		if (modifiers.hasFocus || up) return;
		const num = event.keyCode - KEYS.DIGIT0;
		const slot = ui.hotbar.macros.find(m => m.key === num);
		if (slot.macro) slot.macro.execute();
		this._handled.add(event.keyCode);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Z Keypress Events to generally undo previous actions
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onUndo(event, up, modifiers) {
		if (modifiers.hasFocus || !canvas.ready) return;

		// Ensure we are on a Placeables layer
		const layer = canvas.activeLayer;
		if (!layer instanceof PlaceablesLayer) return;

		// Undo history for the Layer
		if (up && modifiers.isCtrl && layer.history.length) {
			layer.undoHistory();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle "C" keypress events to copy data to clipboard
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onCopy(event, up, modifiers) {
		if (!game.user.isGM) return;
		if (!canvas.ready || up || modifiers.hasFocus || !modifiers.isCtrl)
			return;

		// If text is selected, allow a regular copy operation
		if (window.getSelection().toString() !== '') return;

		// Otherwise attempt to copy objects on the Placeables Layer
		let layer = canvas.activeLayer;
		if (layer instanceof PlaceablesLayer) layer.copyObjects();
	}

	/* -------------------------------------------- */

	/**
	 * Handle "V" keypress events to paste data from clipboard
	 * @param event {Event}
	 * @param up {Boolean}
	 * @param modifiers {Object}
	 * @private
	 */
	_onPaste(event, up, modifiers) {
		if (!game.user.isGM) return;
		if (!canvas.ready || up || modifiers.hasFocus || !modifiers.isCtrl)
			return;
		let layer = canvas.activeLayer;
		if (layer instanceof PlaceablesLayer) {
			let pos = canvas.app.renderer.plugins.interaction.mouse.getLocalPosition(
				canvas.tokens
			);
			layer.pasteObjects(pos, { hidden: modifiers.isAlt });
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle DELETE Keypress Events
	 * @param {Event} event
	 * @param {Boolean} up
	 * @param modifiers {Object}
	 * @private
	 */
	_onDelete(event, up, modifiers) {
		if (this.hasFocus) return;
		event.preventDefault();

		// Remove hotbar Macro
		if (ui.hotbar._hover)
			game.user.assignHotbarMacro(null, ui.hotbar._hover);
		// Delete placeables from Canvas layer
		else if (
			canvas.ready &&
			canvas.activeLayer instanceof PlaceablesLayer
		) {
			return canvas.activeLayer._onDeleteKey(event);
		}
	}
}

/**
 * Specify a rate limit for mouse wheel to gate repeated scrolling.
 * This is especially important for continuous scrolling mice which emit hundreds of events per second.
 * This designates a minimum number of milliseconds which must pass before another wheel event is handled
 * @type {Number}
 */
KeyboardManager.MOUSE_WHEEL_RATE_LIMIT = 50;
/**
 * An abstract interface for defining setting storage patterns
 * Each setting is a key/value pair
 */
class ClientSettings {
	constructor(worldSettings) {
		/**
		 * A object of registered game settings for this scope
		 * @type {Object}
		 */
		this.settings = {};

		/**
		 * The storage interfaces used for persisting settings
		 * Each storage interface shares the same API as window.localStorage
		 */
		this.storage = {
			client: window.localStorage,
			world: new WorldSettingsStorage(worldSettings),
		};
	}

	/* -------------------------------------------- */

	/**
	 * Return a singleton instance of the Game Settings Configuration app
	 * @return {SettingsConfig}
	 */
	get sheet() {
		if (!this._sheet) this._sheet = new SettingsConfig(this.settings);
		return this._sheet;
	}

	/* -------------------------------------------- */

	/**
	 * Register a new game setting under this setting scope
	 * @param module {String}   The module namespace under which the setting is registered
	 * @param key {String}      The key name for the setting under the namespace module
	 * @param data {Object}     Configuration for setting data
	 */
	register(module, key, data) {
		if (!module || !key)
			throw new Error(
				'You must specify both module and key portions of the setting'
			);
		data['key'] = key;
		data['module'] = module;
		data['scope'] = ['client', 'world'].includes(data.scope)
			? data.scope
			: 'client';
		key = `${module}.${key}`;
		this.settings[key] = data;
	}

	/* -------------------------------------------- */

	/**
	 * Get the value of a game setting for a certain module and setting key
	 * @param module {String}   The module namespace under which the setting is registered
	 * @param key {String}      The setting key to retrieve
	 */
	get(module, key) {
		if (!module || !key)
			throw new Error(
				'You must specify both module and key portions of the setting'
			);
		key = `${module}.${key}`;
		if (!this.settings.hasOwnProperty(key))
			throw new Error('This is not a registered game setting');

		// Get the setting and the correct storage interface
		let setting = this.settings[key],
			storage = this.storage[setting.scope];

		// Get the setting value
		let value = JSON.parse(storage.getItem(key));
		value = value !== null ? value : setting.default;

		// Cast the value to a requested type
		return setting.type ? setting.type(value) : value;
	}

	/* -------------------------------------------- */

	/**
	 * Set the value of a game setting for a certain module and setting key
	 * @param module {String}   The module namespace under which the setting is registered
	 * @param key {String}      The setting key to retrieve
	 * @param value             The data to assign to the setting key
	 */
	async set(module, key, value) {
		if (!module || !key)
			throw new Error(
				'You must specify both module and key portions of the setting'
			);
		key = `${module}.${key}`;

		// Get the setting and the correct storage interface
		if (!this.settings.hasOwnProperty(key))
			throw new Error('This is not a registered game setting');
		let setting = this.settings[key];

		// Push world setting changes
		return this.update(key, value);
	}

	/* -------------------------------------------- */

	/**
	 * Update the setting storage with a new value
	 * @param {String} key
	 * @param {*} value
	 * @return {Promise}
	 */
	async update(key, value) {
		let setting = this.settings[key],
			storage = this.storage[setting.scope];
		await storage.setItem(key, JSON.stringify(value));

		// Trigger change callback
		let onChange = this.settings[key].onChange;
		if (onChange instanceof Function) onChange(value);

		// Return the new value
		return value;
	}

	/* -------------------------------------------- */

	static socketListeners(socket) {
		socket.on('updateWorldSetting', (key, value) => {
			const setting = game.settings.settings[key];
			game.settings.storage.world._set(key, value);
			if (setting.onChange instanceof Function)
				setting.onChange(JSON.parse(value));
			game.settings.sheet.render();
		});
	}
}

/* -------------------------------------------- */

/**
 * A simple interface for World settings storage which imitates the API provided by localStorage
 */
class WorldSettingsStorage {
	constructor(settings) {
		this.data = {};
		for (let s of settings) {
			this._set(s.key, s.value);
		}
	}

	getItem(key) {
		return this.data[key] || null;
	}

	setItem(key, value) {
		return new Promise((resolve, reject) => {
			game.socket.emit('updateWorldSetting', key, value, setting => {
				this._set(key, setting.value);
				resolve();
			});
		});
	}

	_set(key, value) {
		this.data[key] = value;
	}
}

/* -------------------------------------------- */
/**
 * A collection of helper methods designed to orchestrate the client side socket workflow in a standardized way.
 */
class SocketInterface {
	/**
	 * A generalized socket trigger interface which standardizes the way that information is provided to the server
	 *
	 * @param {String} eventName      The socket event name to emit
	 * @param {Object} eventData      Data provided to the server as part of the event
	 * @param {Object} options        Additional options which contextualize the socket request
	 * @param {String} preHook        If an optional preHook is provided, ensure it does not return false before
	 *                                proceeding with the socket emission.
	 * @param {String} postHook       The name of an optional post-hook event to call with the resolved context and the
	 *                                provided event arguments.
	 * @param {*} context             The Entity or Object context for the request. Passed as the first argument to the
	 *                                preHook.
	 * @param {Function} success      A function to call upon successful receipt of response.
	 *
	 * @return {Promise}              A Promise which resolves to the return value of the provided handler function
	 */
	static async trigger(
		eventName,
		eventData,
		options = {},
		{ preHook = null, postHook = null, context = null, success = null } = {}
	) {
		// Dispatch the pre-hook
		if (preHook) {
			const hookArgs = Array(...Object.values(eventData), options);
			if (context) hookArgs.unshift(context);
			const allowed = Hooks.call(preHook, ...hookArgs);
			if (allowed === false) {
				console.log(
					`${vtt} | ${eventName} submission prevented by ${preHook} hook`
				);
				return null;
			}
		}

		// Dispatch the socket event
		const response = await this._dispatch(eventName, eventData, options);

		// Handle the server response
		return this.handle(response, success, { postHook, context });
	}

	/* -------------------------------------------- */

	/**
	 * Generalized handler for single-target responses
	 */
	static async handle(
		response,
		handler,
		{ postHook = null, context = null } = {}
	) {
		// Call the response handler
		let result;
		if (handler instanceof Function) {
			if (!handler.name.startsWith('bound_') && context)
				handler = handler.bind(context);
			result = handler(response);
		}

		// Trigger a post-event hook
		if (postHook) {
			const hookArgs = Object.values(response);
			if (context) hookArgs.unshift(context);
			Hooks.callAll(postHook, ...hookArgs);
		}

		// Return the result returned by the handler
		return result;
	}

	/* -------------------------------------------- */

	/**
	 * A generalized socket trigger interface which standardizes the way that information is provided to the server
	 * Similar to the basic trigger method, except this method is responsible for triggering multi-object operations
	 *
	 * @param {String} eventName      The socket event name to emit
	 * @param {Array} eventData       Data provided to the server as part of the event
	 * @param {Object} options        Additional options which contextualize the socket request
	 * @param {String} preHook        If an optional preHook is provided, ensure it does not return false before
	 *                                proceeding with the socket emission.
	 * @param {String} postHook       The name of an optional post-hook event to call with the resolved context and the
	 *                                provided event arguments.
	 * @param {*} context             The Entity or Object context for the request. Passed as the first argument to the
	 *                                preHook.
	 * @param {Function} success      A function to call upon successful receipt of response.
	 *
	 * @return {Promise}              A Promise which resolves to the return value of the provided handler function
	 */
	static async triggerMany(
		eventName,
		eventData,
		options = {},
		{ preHook = null, postHook = null, context = null, success = null } = {}
	) {
		// Pass each update to a pre-hook filter
		if (preHook) {
			const eventDataCopy = duplicate(eventData);
			for (let data of eventData.data) {
				eventDataCopy.data = data;
				const hookArgs = Object.values(eventDataCopy);
				if (context) hookArgs.unshift(context);
				let allowed = Hooks.call(preHook, ...hookArgs);
				if (allowed === false) {
					console.log(
						`${vtt} | ${eventName} submission prevented by ${preHook} hook`
					);
					return null;
				}
			}
		}

		// Dispatch the socket event
		const response = await this._dispatch(eventName, eventData, options);

		// Handle the server response
		return this.handleMany(response, success, { postHook, context });
	}

	/* -------------------------------------------- */

	/**
	 * Generalized handler for multi-target responses
	 */
	static async handleMany(
		response,
		handler,
		{ postHook = null, context = null } = {}
	) {
		const responseCopy = postHook ? duplicate(response) : null;

		// Call the response handler
		let result;
		if (handler instanceof Function) {
			if (context) handler = handler.bind(context);
			result = handler(response);
		}

		// Pass each updated object through a post hook
		if (postHook) {
			const updates = response.data;
			if (!updates.length) return;
			for (let update of updates) {
				responseCopy.data = update;
				const hookArgs = Object.values(responseCopy);
				if (context) hookArgs.unshift(context);
				Hooks.callAll(postHook, ...hookArgs);
			}
		}

		// Return the result provided by the handler
		return result;
	}

	/* -------------------------------------------- */
	/*  Internal Helpers                            */
	/* -------------------------------------------- */

	/**
	 * A helper to standardize dispatching the socket request and handling its response
	 * @param {String} eventName    The socket event name being handled
	 * @param {Object} eventData    Data provided for the socket event
	 * @param {Object} options      Additional options which modify the request
	 * @return {Promise}            A promise which resolves to the socket response, if successful
	 * @private
	 */
	static _dispatch(eventName, eventData, options) {
		return new Promise((resolve, reject) => {
			game.socket.emit(eventName, eventData, options, response => {
				if (response.error) {
					this._handleDatabaseError(response.error);
					reject();
				} else resolve(response);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * General use handler for receiving a database error and transforming it into a notification and log message
	 * @param err
	 * @private
	 */
	static _handleDatabaseError(err) {
		let error = err instanceof Error ? err : err.error;
		ui.notifications.error(error.message);
		console.error(error.stack);
	}
}

class SortingHelpers {
	/**
	 * Given a source object to sort, a target to sort relative to, and an Array of siblings in the container:
	 * Determine the updated sort keys for the source object, or all siblings if a reindex is required.
	 * Return an Array of updates to perform, it is up to the caller to dispatch these updates.
	 * Each update is structured as:
	 * {
	 *   target: object,
	 *   update: {sortKey: sortValue}
	 * }
	 *
	 * @param {*} source            The source object being sorted
	 * @param {*} target            The target object relative which to sort
	 * @param {Array} siblings      The sorted Array of siblings which share the same sorted container
	 * @param {String} sortKey      The name of the data property within the source object which defines the sort key
	 * @param {Boolean} sortBefore  Whether to sort before the target (if true) or after (if false)
	 *
	 * @returns {Array}             An Array of updates for the caller of the helper function to perform
	 */
	static performIntegerSort(
		source,
		{
			target = null,
			siblings = [],
			sortKey = 'sort',
			sortBefore = true,
		} = {}
	) {
		// Ensure the siblings are sorted
		siblings.sort((a, b) => a.data[sortKey] - b.data[sortKey]);

		// Determine the index target for the sort
		let defaultIdx = sortBefore ? siblings.length : 0;
		let idx = target
			? siblings.findIndex(sib => sib === target)
			: defaultIdx;

		// Determine the indices to sort between
		let min, max;
		if (sortBefore) [min, max] = this._sortBefore(siblings, idx, sortKey);
		else [min, max] = this._sortAfter(siblings, idx, sortKey);

		// Easiest case - no siblings
		if (siblings.length === 0) {
			return [
				{
					target: source,
					update: { [sortKey]: CONST.SORT_INTEGER_DENSITY },
				},
			];
		}

		// No minimum - sort to beginning
		else if (Number.isFinite(max) && min === null) {
			return [
				{
					target: source,
					update: { [sortKey]: max - CONST.SORT_INTEGER_DENSITY },
				},
			];
		}

		// No maximum - sort to end
		else if (Number.isFinite(min) && max === null) {
			return [
				{
					target: source,
					update: { [sortKey]: min + CONST.SORT_INTEGER_DENSITY },
				},
			];
		}

		// Sort between two
		else if (
			Number.isFinite(min) &&
			Number.isFinite(max) &&
			Math.abs(max - min) > 1
		) {
			return [
				{
					target: source,
					update: { [sortKey]: Math.round(0.5 * (min + max)) },
				},
			];
		}

		// Reindex all siblings
		else {
			siblings.splice(idx, 0, source);
			return siblings.map((sib, i) => {
				return {
					target: sib,
					update: { [sortKey]: (i + 1) * CONST.SORT_INTEGER_DENSITY },
				};
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort before the target
	 * @private
	 */
	static _sortBefore(siblings, idx, sortKey) {
		let max = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let min = siblings[idx - 1] ? siblings[idx - 1].data[sortKey] : null;
		return [min, max];
	}

	/* -------------------------------------------- */

	/**
	 * Given an ordered Array of siblings and a target position, return the [min,max] indices to sort after the target
	 * @private
	 */
	static _sortAfter(siblings, idx, sortKey) {
		let min = siblings[idx] ? siblings[idx].data[sortKey] : null;
		let max = siblings[idx + 1] ? siblings[idx + 1].data[sortKey] : null;
		return [min, max];
	}

	/* -------------------------------------------- */
}
/**
 * Export data content to be saved to a local file
 * @param {String} data       Data content converted to a string
 * @param {String} type       The type of
 * @param {String} filename   The filename of the resulting download
 */
function saveDataToFile(data, type, filename) {
	const blob = new Blob([data], { type: type });

	// Create an element to trigger the download
	let a = document.createElement('a');
	a.href = window.URL.createObjectURL(blob);
	a.download = filename;

	// Dispatch a click event to the element
	a.dispatchEvent(
		new MouseEvent('click', {
			bubbles: true,
			cancelable: true,
			view: window,
		})
	);
	setTimeout(() => window.URL.revokeObjectURL(a.href), 100);
}

/* -------------------------------------------- */

/**
 * Read text data from a user provided File object
 * @param {File} file           A File object
 * @return {Promise.<String>}   A Promise which resolves to the loaded text data
 */
function readTextFromFile(file) {
	const reader = new FileReader();
	return new Promise((resolve, reject) => {
		reader.onload = ev => {
			resolve(reader.result);
		};
		reader.onerror = ev => {
			reader.abort();
			reject();
		};
		reader.readAsText(file);
	});
}

/* -------------------------------------------- */

/**
 * Escapes a string to be used in a regular expression.
 * Regexps special characters will be escaped to avoid getting interpreted by the regular expression machine
 * @param {String} string    The string to escape
 */
function escapeStringForRegexp(string) {
	return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
/**
 * A helper class to provide common functionality for working with HTML5 video objects
 * A singleton instance of this class is available as ``game.video``
 */
class VideoHelper {
	constructor() {
		if (game.video instanceof this.constructor) {
			throw new Error(
				'You may not re-initialize the singleton VideoHelper. Use game.video instead.'
			);
		}

		/**
		 * A collection of HTML5 video objects which are currently active within the FVTT page
		 * @type {Object}
		 */
		this.videos = [];

		/**
		 * A user gesture must be registered before video playback can begin.
		 * This Set records the video elements which await such a gesture.
		 * @type {Set}
		 */
		this.pending = new Set();

		/**
		 * A flag for whether video playback is currently locked by awaiting a user gesture
		 * @type {Boolean}
		 */
		this.locked = true;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	static hasVideoExtension(src) {
		let rgx = new RegExp(
			'(\\.' + CONST.VIDEO_FILE_EXTENSIONS.join('|\\.') + ')(\\?.*)?',
			'i'
		);
		return rgx.test(src);
	}

	/* -------------------------------------------- */

	/**
	 * Play a single video source
	 * If playback is not yet enabled, add the video to the pending queue
	 * @param {HTMLElement} video   The VIDEO element to play
	 */
	play(video) {
		video.play().catch(err => {
			if (this.locked) this.pending.add(video);
			else throw new Error(err.toString());
		});
	}

	/* -------------------------------------------- */

	/**
	 * Register an event listener to await the first mousemove gesture and begin playback once observed
	 * A user interaction must involve a mouse click or keypress.
	 * Listen for any of these events, and handle the first observed gesture.
	 */
	awaitFirstGesture() {
		if (!this.locked) return;
		const interactions = [
			'contextmenu',
			'auxclick',
			'mousedown',
			'mouseup',
			'keydown',
		];
		interactions.forEach(event =>
			document.addEventListener(event, this._onFirstGesture.bind(this), {
				once: true,
			})
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the first observed user gesture
	 * We need a slight delay because unfortunately Chrome is stupid and doesn't always acknowledge the gesture fast enough.
	 * @param {Event} event   The mouse-move event which enables playback
	 */
	_onFirstGesture(event) {
		if (!this.pending.size) return;
		console.log(
			`${vtt} | Activating pending video playback with user gesture.`
		);
		this.locked = false;
		for (let video of Array.from(this.pending)) {
			this.play(video);
		}
		this.pending.clear();
	}
}

let _appId = 0;
let _maxZ = 100;

const MIN_WINDOW_WIDTH = 200,
	MIN_WINDOW_HEIGHT = 50;

/**
 * The standard application window that is rendered for a large variety of UI elements in Foundry VTT
 * @abstract
 *
 * @param options {Object}    Configuration options which control how the application is rendered
 *
 * @param options.height {Number}   The height in pixels (or "auto") for the rendered element
 * @param options.width {Number}    The width in pixels (or "auto") for the rendered element
 * @param options.top {Number}      The vertical position (from the top) of the rendered element
 * @param options.left {Number}     The horizontal position (from the left) of the rendered element
 * @param options.template {String} The default HTML template path to use for applications of this type
 * @param options.popOut {Boolean}  Display the element wrapped in a containing window frame (true, the default) or
 *                                  only the inner HTML (false).
 * @param options.minimizable {Boolean} Customize whether the application is able to be minimized by double-clicking
 *                                  the header. Default behavior is the value of `options.popOut`
 * @param options.resizable {Boolean} Customize whether a window application window may be re-sized by dragging a
 *                                  handle in the bottom-right corner of the window display.
 */
class Application {
	constructor(options) {
		/**
		 * The options provided to this application upon initialization
		 * @type {Object}
		 */
		this.options = mergeObject(
			this.constructor.defaultOptions,
			options || {},
			{
				insertKeys: true,
				insertValues: false,
				overwrite: true,
				inplace: false,
			}
		);

		/**
		 * The application ID is a unique incrementing integer which is used to identify every application window
		 * drawn by the VTT
		 * @type {Number}
		 */
		this.appId = _appId += 1;

		/**
		 * An internal reference to the HTML element this application renders
		 * @type {jQuery}
		 */
		this._element = null;

		/**
		 * Track the current position and dimensions of the Application UI
		 * @type {Object}
		 */
		this.position = {
			width: this.options.width,
			height: this.options.height,
			left: this.options.left,
			top: this.options.top,
			scale: this.options.scale,
		};

		/**
		 * Track whether the Application is currently minimized
		 * @type {Boolean}
		 * @private
		 */
		this._minimized = false;

		/**
		 * Track whether the Application has been successfully rendered
		 * @type {Boolean}
		 * @private
		 */
		this._rendered = false;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by all Application classes.
	 * Application subclasses may include additional options which are specific to their usage.
	 * All keys are optional, descriptions and default values are listed below:
	 *
	 * @returns {Object} options                    The default options for this Application class
	 * @returns {string} options.baseApplication    A named "base application" which generates an additional hook
	 * @returns {number} options.width              The default pixel width for the rendered HTML
	 * @returns {number} options.height             The default pixel height for the rendered HTML
	 * @returns {number} options.top                The default offset-top position for the rendered HTML
	 * @returns {number} options.left               The default offset-left position for the rendered HTML
	 * @returns {boolean} options.popOut            Whether to display the application as a pop-out container
	 * @returns {boolean} options.minimizable       Whether the rendered application can be minimized (popOut only)
	 * @returns {boolean} options.resizable         Whether the rendered application can be drag-resized (popOut only)
	 * @returns {string} options.id                 The default CSS id to assign to the rendered HTML
	 * @returns {Array.<string>} options.classes    An array of CSS string classes to apply to the rendered HTML
	 * @returns {string} options.title              A default window title string (popOut only)
	 * @returns {string} options.template           The default HTML template path to render for this Application
	 */
	static get defaultOptions() {
		let config = CONFIG[this.name] || {};
		return {
			baseApplication: null,
			width: config.width,
			height: config.height,
			top: null,
			left: null,
			popOut: true,
			minimizable: true,
			resizable: false,
			id: '',
			classes: [],
			title: '',
			template: config.template,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Return the CSS application ID which uniquely references this UI element
	 */
	get id() {
		return this.options.id ? this.options.id : `app-${this.appId}`;
	}

	/* -------------------------------------------- */

	/**
	 * Return the active application element, if it currently exists in the DOM
	 * @type {jQuery|HTMLElement}
	 */
	get element() {
		if (this._element) return this._element;
		let selector = '#' + this.id;
		return $(selector);
	}

	/* -------------------------------------------- */

	/**
	 * The path to the HTML template file which should be used to render the inner content of the app
	 * @type {string}
	 */
	get template() {
		return this.options.template;
	}

	/* -------------------------------------------- */

	/**
	 * Control the rendering style of the application. If popOut is true, the application is rendered in its own
	 * wrapper window, otherwise only the inner app content is rendered
	 * @type {boolean}
	 */
	get popOut() {
		return this.options.popOut !== undefined
			? Boolean(this.options.popOut)
			: true;
	}

	/* -------------------------------------------- */

	/**
	 * An Application window should define its own title definition logic which may be dynamic depending on its data
	 * @type {string}
	 */
	get title() {
		return this.options.title;
	}

	/* -------------------------------------------- */
	/* Application rendering
  /* -------------------------------------------- */

	/**
	 * An application should define the data object used to render its template.
	 * This function may either return an Object directly, or a Promise which resolves to an Object
	 * If undefined, the default implementation will return an empty object allowing only for rendering of static HTML
	 *
	 * @return {Object|Promise}
	 */
	getData(options) {
		return {};
	}

	/* -------------------------------------------- */

	/**
	 * Render the Application by evaluating it's HTML template against the object of data provided by the getData method
	 * If the Application is rendered as a pop-out window, wrap the contained HTML in an outer frame with window controls
	 *
	 * @param {Boolean} force   Add the rendered application to the DOM if it is not already present. If false, the
	 *                          Application will only be re-rendered if it is already present.
	 * @param {Object} options  Additional rendering options which are applied to customize the way that the Application
	 *                          is rendered in the DOM.
	 *
	 * @param {Number} options.left           The left positioning attribute
	 * @param {Number} options.top            The top positioning attribute
	 * @param {Number} options.width          The rendered width
	 * @param {Number} options.height         The rendered height
	 * @param {Number} options.scale          The rendered transformation scale
	 * @param {Boolean} options.log           Whether to display a log message that the Application was rendered
	 * @param {String} options.renderContext  A context-providing string which suggests what event triggered the render
	 * @param {*} options.renderData          The data change which motivated the render request
	 *
	 */
	render(force = false, options = {}) {
		this._render(force, options);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * An asynchronous inner function which handles the rendering of the Application
	 * @param {Object} options    Provided rendering options, see the render function for details
	 * @return {Promise}
	 * @private
	 */
	async _render(force = false, options = {}) {
		this._rendered = false;

		// Get the existing HTML element and data for rendering
		const element = this.element;
		if (!force && !element.length) return;
		if (options.log || (force && !element.length))
			console.log(`${vtt} | Rendering ${this.constructor.name}`);

		// Obtain application data used for rendering
		const data = await this.getData(options);

		// Render the inner content
		const inner = await this._renderInner(data, options);
		let html = inner;

		// If the application already exists in the DOM, replace the inner content
		if (element.length) this._replaceHTML(element, html, options);
		// Otherwise render a new app
		else {
			// Wrap a popOut application in an outer frame
			if (this.popOut) {
				html = await this._renderOuter(options);
				html.find('.window-content').append(inner);
				ui.windows[this.appId] = this;
			}

			// Add the HTML to the DOM and record the element
			this._injectHTML(html, options);
		}

		// Activate event listeners on the inner HTML
		this.activateListeners(inner);

		// Set the application position (if it's not currently minimized)
		if (this.popOut && !this._minimized) this.setPosition(this.position);

		// Dispatch Hooks for rendering the base and subclass applications
		if (
			this.options.baseApplication &&
			this.options.baseApplication !== this.constructor.name
		) {
			Hooks.call(
				`render${this.options.baseApplication}`,
				this,
				html,
				data
			);
		}
		Hooks.call('render' + this.constructor.name, this, html, data);

		// Flag successful rendering
		this._rendered = true;
	}

	/* -------------------------------------------- */

	/**
	 * Render the outer application wrapper
	 * @return {Promise.<HTMLElement>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderOuter(options) {
		// Gather basic application data
		const classes = options.classes || this.options.classes;
		const windowData = {
			id: this.id,
			classes: classes.join(' '),
			appId: this.appId,
			title: this.title,
			headerButtons: this._getHeaderButtons(),
		};

		// Render the template and return the promise
		let html = await renderTemplate(
			'templates/app-window.html',
			windowData
		);
		html = $(html);

		// Activate header button click listeners
		windowData.headerButtons.forEach(button => {
			const btn = html.find(`a.${button.class}`);
			btn.mousedown(ev => ev.stopPropagation()).mouseup(ev => {
				ev.preventDefault();
				button.onclick(ev);
			});
		});

		// Make the outer window draggable
		const header = html.find('header')[0];
		new Draggable(this, html, header, this.options.resizable);

		// Make the outer window minimizable
		if (this.options.minimizable) {
			header.addEventListener(
				'dblclick',
				this._onToggleMinimize.bind(this)
			);
		}

		// Set the outer frame z-index
		if (Object.keys(ui.windows).length === 0) _maxZ = 100;
		html.css({ zIndex: ++_maxZ });

		// Return the outer frame
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * Render the inner application content
	 * @param {Object} data         The data used to render the inner template
	 * @return {Promise.<jQuery>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderInner(data, options) {
		let html = await renderTemplate(this.template, data);
		if (html === '')
			throw new Error(
				`No data was returned from template ${this.template}`
			);
		return $(html);
	}

	/* -------------------------------------------- */

	/**
	 * Customize how inner HTML is replaced when the application is refreshed
	 * @param {HTMLElement|jQuery} element  The original HTML element
	 * @param {HTMLElement|jQuery} html     New updated HTML
	 * @private
	 */
	_replaceHTML(element, html, options) {
		if (!element.length) return;

		// For pop-out windows update the inner content and the window title
		if (this.popOut) {
			element.find('.window-content').html(html);
			element.find('.window-title').text(this.title);
		}

		// For regular applications, replace the whole thing
		else element.replaceWith(html);
	}

	/* -------------------------------------------- */

	/**
	 * Customize how a new HTML Application is added and first appears in the DOC
	 * @param html {jQuery}
	 * @private
	 */
	_injectHTML(html, options) {
		$('body').append(html);
		this._element = html;
		html.hide().fadeIn(200);
	}

	/* -------------------------------------------- */

	/**
	 * Specify the set of config buttons which should appear in the Application header
	 * Buttons should be returned as an Array of Objects with the following keys:
	 * label: The button label
	 * icon: A font-awesome glyph icon
	 * class: the css class of the button
	 * onclick: the button click handler
	 * @return {Array.<Object>}
	 * @private
	 */
	_getHeaderButtons() {
		return [
			{
				label: 'Close',
				class: 'close',
				icon: 'fas fa-times',
				onclick: ev => this.close(),
			},
		];
	}

	/* -------------------------------------------- */
	/* Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Once the HTML for an Application has been rendered, activate event listeners which provide interactivity for
	 * the application
	 * @param html {jQuery|HTMLElement}
	 */
	activateListeners(html) {}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Close the application and un-register references to it within UI mappings
	 * This function returns a Promise which resolves once the window closing animation concludes
	 * @return {Promise}
	 */
	async close() {
		let el = this.element;
		if (!el.length) return Promise.resolve();
		el.css({ minHeight: 0 });
		return new Promise(resolve => {
			el.slideUp(200, () => {
				el.remove();
				this._element = null;
				delete ui.windows[this.appId];
				this._rendered = this._minimized = false;
				resolve();
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Minimize the pop-out window, collapsing it to a small tab
	 * Take no action for applications which are not of the pop-out variety or apps which are already minimized
	 * @return {Promise}    A Promise which resolves to true once the minimization action has completed
	 */
	async minimize() {
		if (!this.popOut || [true, null].includes(this._minimized)) return;
		this._minimized = null;

		// Get content
		let window = this.element,
			header = window.find('.window-header'),
			content = window.find('.window-content');

		// Remove minimum width and height styling rules
		window.css({ minWidth: 100, minHeight: 30 });

		// Slide-up content
		content.slideUp(100);

		// Slide up window height
		return new Promise(resolve => {
			window.animate(
				{ height: `${header[0].offsetHeight + 1}px` },
				100,
				() => {
					header
						.children()
						.not('.window-title')
						.not('.close')
						.hide();
					window.animate({ width: MIN_WINDOW_WIDTH }, 100, () => {
						window.addClass('minimized');
						this._minimized = true;
						resolve(true);
					});
				}
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Maximize the pop-out window, expanding it to its original size
	 * Take no action for applications which are not of the pop-out variety or are already maximized
	 * @return {Promise}    A Promise which resolves to true once the maximization action has completed
	 */
	async maximize() {
		if (!this.popOut || [false, null].includes(this._minimized)) return;
		this._minimized = null;

		// Get content
		let window = this.element,
			header = window.find('.window-header'),
			content = window.find('.window-content');

		// Expand window
		return new Promise(resolve => {
			window.animate(
				{ width: this.position.width, height: this.position.height },
				100,
				() => {
					header.children().show();
					content.slideDown(100, () => {
						window.removeClass('minimized');
						this._minimized = false;
						window.css({ minWidth: '', minHeight: '' });
						this.setPosition(this.position);
						resolve(true);
					});
				}
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Set the application position and store it's new location.
	 *
	 * @param {number|null} left            The left offset position in pixels
	 * @param {number|null} top             The top offset position in pixels
	 * @param {number|null} width           The application width in pixels
	 * @param {number|string|null} height   The application height in pixels
	 * @param {number|null} scale           The application scale as a numeric factor where 1.0 is default
	 *
	 * @returns {Object}                    The updated position object for the application containing the new values
	 */
	setPosition({ left, top, width, height, scale } = {}) {
		const el = this.element[0];
		const p = this.position;
		const pop = this.popOut;
		const styles = window.getComputedStyle(el);

		// If Height is "auto" unset current preference
		if (height === 'auto' || this.options.height === 'auto') {
			el.style.height = 'auto';
			p.height = null;
			if (height === 'auto') height = null;
		}

		// Update Width
		if (!el.style.width || width) {
			const minWidth =
				parseInt(styles.minWidth) || (pop ? MIN_WINDOW_WIDTH : 0);
			p.width = Math.clamped(
				minWidth,
				width || el.offsetWidth,
				el.style.maxWidth || window.innerWidth
			);
			el.style.width = p.width + 'px';
		}

		// Update Height
		if (!el.style.height || height) {
			const minHeight =
				parseInt(styles.minHeight) || (pop ? MIN_WINDOW_HEIGHT : 0);
			p.height = Math.clamped(
				minHeight,
				height || el.offsetHeight,
				el.style.maxHeight || window.innerHeight
			);
			el.style.height = p.height + 'px';
		}

		// Update Left
		if ((pop && !el.style.left) || Number.isFinite(left)) {
			const maxLeft = Math.max(window.innerWidth - el.offsetWidth, 0);
			if (!Number.isFinite(left))
				left = (window.innerWidth - el.offsetWidth) / 2;
			p.left = Math.clamped(left, 0, maxLeft);
			el.style.left = p.left + 'px';
		}

		// Update Top
		if ((pop && !el.style.top) || Number.isFinite(top)) {
			const maxTop = Math.max(window.innerHeight - el.offsetHeight, 0);
			if (!Number.isFinite(top))
				top = (window.innerHeight - el.offsetHeight) / 2;
			p.top = Math.clamped(top, 0, maxTop);
			el.style.top = p.top + 'px';
		}

		// Update Scale
		if (scale) {
			p.scale = scale;
			if (scale === 1) el.style.transform = '';
			else el.style.transform = `scale(${scale})`;
		}

		// Return the updated position object
		return p;
	}

	/* -------------------------------------------- */

	/**
	 * Handle application minimization behavior - collapsing content and reducing the size of the header
	 * @param {Event} ev
	 * @private
	 */
	_onToggleMinimize(ev) {
		ev.preventDefault();
		if (this._minimized) this.maximize(ev);
		else this.minimize(ev);
	}

	/* -------------------------------------------- */

	/**
	 * Additional actions to take when the application window is resized
	 * @param {Event} event
	 * @private
	 */
	_onResize(event) {}
}

/* -------------------------------------------- */

/**
 * An abstract pattern for defining an Application responsible for updating some object using an HTML form
 *
 * A few critical assumptions:
 * 1) This application is used to only edit one object at a time
 * 2) The template used contains one (and only one) HTML <form> as it's outer-most element
 * 3) This abstract layer has no knowledge of what is being updated, so the implementation must define _updateObject
 *
 * @type {Application}
 *
 * @param object {*}                    Some object or entity which is the target to be updated.
 *
 * @param [options] {Object}            Additional options which modify the rendering of the sheet.
 * @param options.editable {Boolean}        (true) Is the form editable, or should its fields be disabled?
 * @param options.closeOnSubmit {Boolean}   (true) Automatically close the form when the submit button is pressed.
 * @param options.submitOnClose {Boolean}   (false) Automatically submit the form if the application window is closed.
 * @param options.submitOnUnfocus {Boolean} (false) Automatically submit the form if an input field is unfocused.
 */
class FormApplication extends Application {
	constructor(object, options) {
		super(options);

		/**
		 * The object target which we are using this form to modify
		 * @type {*}
		 */
		this.object = object;

		/**
		 * A convenience reference to the form HTMLElement
		 * @type {HTMLElement}
		 */
		this.form = null;

		/**
		 * Keep track of any FilePicker instances which are associated with this form
		 * The values of this Array are inner-objects with references to the FilePicker instances and other metadata
		 * @type {Array}
		 */
		this.filepickers = [];

		/**
		 * Keep track of any mce editors which may be active as part of this form
		 * The values of this Array are inner-objects with references to the MCE editor and other metadata
		 * @type {Object}
		 */
		this.editors = {};
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the entity edit sheet.
	 * In addition to the default options object supported by the parent Application class, the Form Application
	 * supports the following additional keys and values:
	 *
	 * @returns {Object} options                    The default options for this FormApplication class, see Application
	 * @returns {boolean} options.closeOnSubmit     Whether to automatically close the application when it's contained
	 *                                              form is submitted. Default is true.
	 * @returns {boolean} options.submitOnClose     Whether to automatically submit the contained HTML form when the
	 *                                              application window is manually closed. Default is false.
	 * @returns {boolean} options.submitOnUnfocus   Whether to automatically submit the contained HTML form when a text
	 *                                              input element loses focus.
	 * @returns {boolean} options.editable          Whether the application form is editable - if true, it's fields will
	 *                                              be unlocked and the form can be submitted. If false, all form fields
	 *                                              will be disabled and the form cannot be submitted. Default is true.
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['form'],
			closeOnSubmit: true,
			submitOnClose: false,
			submitOnUnfocus: false,
			editable: true,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Is the Form Application currently editable?
	 * @type {boolean}
	 */
	get isEditable() {
		return this.options.editable;
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Provide data to the form
	 * @return {Object}   The data provided to the template when rendering the form
	 */
	getData() {
		return {
			object: duplicate(this.object),
			options: this.options,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Render the FormApplication inner sheet content.
	 * See Application._renderInner for more detail.
	 * @private
	 */
	async _renderInner(...args) {
		const html = await super._renderInner(...args);
		this.form = html[0];
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * A helper function to transform an HTML form into a FormData object which is ready for dispatch
	 * @param {HTMLElement} form    The form-type HTMLElement
	 * @return {FormData}           The prepared FormData object
	 * @private
	 */
	_getFormData(form) {
		const FD = new FormData(form);
		const dtypes = {};
		const editorTargets = Object.keys(this.editors);

		// Iterate over standard form data
		for (let k of FD.keys()) {
			let input = form[k];
			if (input.disabled) FD.delete(k);
			if (input.dataset.dtype) dtypes[k] = input.dataset.dtype;
		}

		// Explicitly handle all checkboxes in the form
		for (let box of form.querySelectorAll('input[type="checkbox"]')) {
			FD.set(box.name, box.checked || false);
			dtypes[box.name] = 'Boolean';
		}

		// Process editable images
		for (let img of form.querySelectorAll('img[data-edit]')) {
			if (img.getAttribute('disabled')) continue;
			FD.set(
				img.dataset.edit,
				img.src.replace(window.location.origin + '/', '')
			);
		}

		// Process editable divs (excluding MCE editors)
		for (let div of form.querySelectorAll('div[data-edit]')) {
			if (div.getAttribute('disabled')) continue;
			else if (editorTargets.includes(div.dataset.edit)) continue;
			FD.set(div.dataset.edit, div.innerHTML.trim());
		}

		// Handle MCE editors
		Object.values(this.editors).forEach(ed => {
			if (ed.mce) {
				FD.delete(ed.mce.id);
				if (ed.changed) FD.set(ed.target, ed.mce.getContent());
			}
		});

		// Record target data types for casting
		FD._dtypes = dtypes;
		return FD;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate the default set of listeners for the Entity sheet
	 * These listeners handle basic stuff like form submission or updating images
	 *
	 * @param html {JQuery}     The rendered template ready to have listeners attached
	 */
	activateListeners(html) {
		// Disable input fields if the form is not editable
		if (!this.isEditable) {
			this._disableFields(this.form);
			return;
		}

		// Process form submission
		this.form.onsubmit = this._onSubmit.bind(this);

		// Maybe process unfocus events
		if (this.options.submitOnUnfocus) {
			html.find('input')
				.not('[type="checkbox"]')
				.focusout(this._onUnfocus.bind(this));
		}

		// Detect and activate TinyMCE rich text editors
		html.find('.editor-content[data-edit]').each((i, div) =>
			this._activateEditor(div)
		);

		// Detect and activate file-picker buttons
		html.find('button.file-picker').each((i, button) =>
			this._activateFilePicker(button)
		);

		// Color change inputs
		html.find('input[type="color"][data-edit]').change(
			this._onColorPickerChange.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * If the form is not editable, disable its input fields
	 * @param form {HTMLElement}
	 * @private
	 */
	_disableFields(form) {
		const inputs = ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON'];
		for (let i of inputs) {
			for (let el of form.getElementsByTagName(i))
				el.setAttribute('disabled', '');
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle the change of a color picker input which enters it's chosen value into a related input field
	 * @private
	 */
	_onColorPickerChange(event) {
		event.preventDefault();
		let input = event.target,
			form = input.form;
		form[input.dataset.edit].value = input.value;
	}

	/* -------------------------------------------- */

	/**
	 * Handle standard form submission steps
	 * @param {Event} event             The submit event which triggered this handler
	 * @param {Object|null} updateData  Additional specific data keys/values which override or extend the contents of
	 *                                  the parsed form. This can be used to update other flags or data fields at the
	 *                                  same time as processing a form submission to avoid multiple database operations.
	 * @param {Boolean} preventClose    Override the standard behavior of whether to close the form on submit
	 * @returns {Promise}               A promise which resolves to the validated update data
	 * @private
	 */
	async _onSubmit(event, { updateData = null, preventClose = false } = {}) {
		event.preventDefault();
		if (!this._rendered || !this.options.editable || this._submitting)
			return false;
		this._submitting = true;

		// Acquire and validate Form Data
		const form = this.element.find('form').first()[0];
		let formData = this._getFormData(form);

		// Construct update data object by casting form data
		formData = Array.from(formData).reduce((obj, [k, v]) => {
			let dt = formData._dtypes[k];
			if (dt === 'Number') obj[k] = Number(v);
			else if (dt === 'Boolean') obj[k] = v === 'true';
			else obj[k] = v;
			return obj;
		}, {});

		// Incorporate any additional provided updateData
		if (updateData && typeof updateData === 'object') {
			formData = mergeObject(formData, updateData);
		}

		// Trigger the object update
		await this._updateObject(event, formData);
		if (this.options.closeOnSubmit && !preventClose) this.close();
		this._submitting = false;
		return formData;
	}

	/* -------------------------------------------- */

	/**
	 * Handle unfocusing an input on form - maybe trigger an update if ``options.liveUpdate`` has been set to true
	 * @param event {Event}   The initial triggering event
	 * @private
	 */
	_onUnfocus(event) {
		this._submitting = true;
		setTimeout(() => {
			let hasFocus = $(':focus').length;
			if (!hasFocus) this._onSubmit(event);
			this._submitting = false;
		}, 25);
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @returns {Promise}         A Promise which resolves once the update operation has completed
	 * @abstract
	 */
	async _updateObject(event, formData) {
		throw new Error(
			'A subclass of the FormApplication must implement the _updateObject method.'
		);
	}

	/* -------------------------------------------- */
	/*  TinyMCE Editor
  /* -------------------------------------------- */

	/**
	 * Activate a TinyMCE editor instance present within the form
	 * @param div {HTMLElement}
	 * @private
	 */
	_activateEditor(div) {
		// Get the editor content div
		let target = div.getAttribute('data-edit'),
			button = div.nextElementSibling,
			hasButton = button && button.classList.contains('editor-edit'),
			wrap = div.parentElement.parentElement,
			wc = $(div).parents('.window-content')[0];

		// Determine the preferred editor height
		let heights = [wrap.offsetHeight, wc ? wc.offsetHeight : null];
		if (div.offsetHeight > 0) heights.push(div.offsetHeight);
		let height = Math.min(...heights.filter(h => Number.isFinite(h)));

		// Get initial content
		const data =
				this.object instanceof Entity ? this.object.data : this.object,
			initialContent = getProperty(data, target);

		// Add record to editors registry
		this.editors[target] = {
			target: target,
			button: button,
			hasButton: hasButton,
			mce: null,
			active: !hasButton,
			changed: false,
		};

		// Define editor options
		let editorOpts = {
			target: div,
			height: height,
			setup: mce => (this.editors[target].mce = mce),
			save_onsavecallback: mce => {
				this._onEditorSave(target, mce.getElement(), mce.getContent());
				if (hasButton) {
					mce.remove();
					button.style.display = 'block';
				}
			},
		};

		// If we are using a toggle button, delay activation until it is clicked
		if (hasButton)
			button.onclick = event => {
				this.editors[target].changed = false;
				this.editors[target].active = true;
				button.style.display = 'none';
				editorOpts['height'] = div.offsetHeight;
				this._createEditor(target, editorOpts, initialContent);
			};
		else this._createEditor(target, editorOpts, initialContent);
	}

	/* -------------------------------------------- */

	/**
	 * Encapsulate TinyMCE text editor creation for instances of this FormApplication.
	 * This method allows a targeted way for subclasses to implement a custom TinyMCE editor instead of the default.
	 * @private
	 */
	_createEditor(target, editorOptions, initialContent) {
		TextEditor.create(editorOptions, initialContent).then(mce => {
			const editor = mce[0];
			editor.focus();
			editor.on('change', ev => (this.editors[target].changed = true));
		});
	}

	/* -------------------------------------------- */

	/**
	 * By default, when the editor is saved treat it as a form submission event
	 * @private
	 */
	_onEditorSave(target, element, content) {
		element.innerHTML = content;
		const formData = validateForm(this.form);
		let event = new Event('mcesave');

		// Remove the MCE from the set of active editors
		this.editors[target].active = false;
		this.editors[target].mce.destroy();
		this.editors[target].mce = null;

		// Update the form object
		this._updateObject(event, formData);
	}

	/* -------------------------------------------- */
	/*  FilePicker UI
  /* -------------------------------------------- */

	/**
	 * Activate a FilePicker instance present within the form
	 * @param button {HTMLElement}
	 * @private
	 */
	_activateFilePicker(button) {
		button.onclick = event => {
			event.preventDefault();
			let target = button.getAttribute('data-target');
			let fp = FilePicker.fromButton(button);
			this.filepickers.push({
				target: target,
				app: fp,
			});
			fp.browse();
		};
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Extend the logic applied when the application is closed to destroy any remaining MCE instances
	 * This function returns a Promise which resolves once the window closing animation concludes
	 *
	 * @param {boolean} options.submit      Explicitly specify whether or not to submit the form when closing. Default
	 *                                      behavior uses the value of FormApplication.options.submitOnClose.
	 * @return {Promise}
	 */
	async close(options = {}) {
		if (!this._rendered) return;

		// Optionally trigger a save
		const submit = options.hasOwnProperty('submit')
			? options.submit
			: this.options.submitOnClose;
		if (submit) this.submit();

		// Close any open FilePicker instances
		this.filepickers.forEach(fp => {
			if (fp.app) fp.app.close();
		});

		// Close any open MCE editors
		Object.values(this.editors).forEach(ed => {
			if (ed.mce) ed.mce.destroy();
		});
		this.editors = {};

		// Close the application itself
		return super.close();
	}

	/* -------------------------------------------- */

	/**
	 * Submit the contents of a Form Application, processing its content as defined by the Application
	 * @param {Object|null} updateData   Additional data updates to submit in addition to those parsed from the form
	 * @returns {FormApplication}       Return a self-reference for convenient method chaining
	 */
	submit({ updateData = null } = {}) {
		if (this._submitting) return;
		const submitEvent = new Event('submit');
		this._onSubmit(submitEvent, { updateData, preventClose: true });
		return this;
	}
}

/* -------------------------------------------- */

/**
 * Extend the FormApplication pattern to incorporate specific logic for viewing or editing Entity instances.
 * See the FormApplication documentation for more complete description of this interface.
 *
 * @extends {FormApplication}

 * @param {Entity} object                           An Entity which should be managed by this form sheet.
 * @param {Object} [options]                        Optional configuration parameters for how the form behaves.
 * @param {boolean} [options.editable=true]         Is the form editable, or should its fields be disabled?
 * @param {boolean} [options.closeOnSubmit=true]    Automatically close the form when the submit button is pressed.
 * @param {boolean} [options.submitOnClose=false]   Automatically submit the form if the application window is closed.
 * @param {boolean} [options.submitOnUnfocus=false] Automatically submit the form if an input field is unfocused.
 */
class BaseEntitySheet extends FormApplication {
	constructor(object, options) {
		super(object, options);

		// Register the sheet as an active Application for the Entity
		this.entity.apps[this.appId] = this;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the object property, which in the case of a BaseEntitySheet is an Entity instance.
	 * @type {Entity}
	 */
	get entity() {
		return this.object;
	}

	/* -------------------------------------------- */

	get isEditable() {
		return this.options.editable && this.entity.owner;
	}

	/* -------------------------------------------- */

	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['sheet'],
			template: `templates/sheets/${this.name.toLowerCase()}.html`,
		});
	}

	/* -------------------------------------------- */

	get title() {
		return this.entity.name;
	}

	/* -------------------------------------------- */

	getData() {
		let isOwner = this.entity.owner;
		return {
			entity: duplicate(this.entity.data),
			owner: isOwner,
			limited: this.entity.limited,
			options: this.options,
			editable: this.isEditable,
			cssClass: isOwner ? 'editable' : 'locked',
		};
	}

	/* -------------------------------------------- */

	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if (this.entity.compendium) {
			buttons.unshift({
				label: 'Import',
				class: 'import',
				icon: 'fas fa-download',
				onclick: async ev => {
					await this.close();
					const packName = this.entity.compendium.collection;
					this.entity.collection.importFromCollection(
						packName,
						this.entity._id
					);
				},
			});
		}
		return buttons;
	}

	/* -------------------------------------------- */

	_updateObject(event, formData) {
		formData['_id'] = this.object._id;
		this.entity.update(formData);
	}
}

/* -------------------------------------------- */

/**
 * A helper class which assists with localization and string translation
 */
class Localization {
	constructor() {
		/**
		 * The target language for localization
		 * @type {String}
		 */
		this.lang = null;

		/**
		 * The translation dictionary for the target language
		 * @type {Object}
		 */
		this.translations = {};

		/**
		 * Fallback translations if the target keys are not found
		 * @type {Object}
		 */
		this._fallback = {};
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Localization module
	 * Discover available language translations and apply the current language setting
	 * @return {Promise}
	 */
	async initialize() {
		const lang = await game.settings.get('core', 'language');
		this._discoverLanguages();
		await this.setLanguage(lang);
	}

	/* -------------------------------------------- */

	/**
	 * Discover the available supported languages from the set of packages which are provided
	 * @private
	 */
	_discoverLanguages() {
		const sl = CONFIG.supportedLanguages;

		// Define packages
		const systems = game.data.systems || [game.data.system.data];
		const modules = game.data.modules;
		const worlds = game.data.worlds || [game.data.world];
		const packages = systems
			.concat(modules)
			.concat(worlds)
			.map(p => p.data || p);

		// Discover and register languages
		packages
			.filter(p => p.languages.length)
			.forEach(p => {
				for (let l of p.languages) {
					if (!sl.hasOwnProperty(l.lang)) {
						sl[l.lang] = l.name;
					}
				}
			});
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the dictionary of translation strings for the requested language
	 * @param {String} lang     The language for which to load translations
	 * @return {Promise}
	 * @private
	 */
	async _getTranslations(lang) {
		const translations = {};
		const loadOrder = [];

		// Check for core provided translation
		let coreDict = `lang/${lang}.json`;
		if (await srcExists(coreDict)) loadOrder.push(coreDict);

		// Add game system translations
		if (game.system) {
			let sl = game.system.data.languages.find(l => l.lang === lang);
			if (sl)
				loadOrder.push(`systems/${game.system.data.name}/${sl.path}`);
		}

		// Add module translations
		if (game.modules) {
			for (let module of game.modules) {
				let ml = module.data.languages.find(l => l.lang === lang);
				if (ml)
					loadOrder.push(`modules/${module.data.name}/${ml.path}`);
			}
		}

		// Load the translations sequentially, overwriting any previously defined strings
		for (let src of loadOrder) {
			let json = await this._loadTranslationFile(src);
			mergeObject(translations, json, { inplace: true });
		}

		// Return the prepared translations
		return translations;
	}

	/* -------------------------------------------- */

	/**
	 * Load a single translation file and return its contents as processed JSON
	 * @param {String} src    The translation file path to load
	 * @private
	 */
	async _loadTranslationFile(src) {
		const resp = await fetch(src);
		if (resp.status !== 200) {
			console.warn(
				`${vtt} | Unable to load requested localization file ${src}`
			);
			return {};
		}
		return resp
			.json()
			.then(json => {
				console.log(`${vtt} | Loaded localization file ${src}`);
				return json;
			})
			.catch(err => {
				console.error(
					`Unable to parse localization file ${src}: ${err}`
				);
				return {};
			});
	}

	/* -------------------------------------------- */

	/**
	 * Set a language as the active translation source for the session
	 * @param {String} lang       A language string in CONFIG.supportedLanguages
	 * @return {Promise}          A Promise which resolves once the translations for the requested language are ready
	 */
	async setLanguage(lang) {
		if (!Object.keys(CONFIG.supportedLanguages).includes(lang)) {
			console.error(
				`Cannot set language ${lang}, as it is not in the supported set. Falling back to English`
			);
			lang = 'en';
		}

		// Set the language and load translations
		this.lang = lang;
		this.translations = await this._getTranslations(lang);

		// Load English translations as fallback
		if (lang !== 'en') this._fallback = await this._getTranslations('en');
	}

	/* -------------------------------------------- */

	/**
	 * Localize a string by drawing a translation from the available translations dictionary, if available
	 * If a translation is not available, the original string is returned
	 * @param {String} stringId     The string ID to translate
	 * @return {String}             The translated string
	 */
	localize(stringId) {
		return (
			getProperty(this.translations, stringId) ||
			getProperty(this._fallback, stringId) ||
			stringId
		);
	}
}

// Register Handlebars Extensions
HandlebarsIntl.registerWith(Handlebars);

// Global template cache
_templateCache = {};

/**
 * Get a template from the server by fetch request and caching the retrieved result
 * @param {string} path   The web-accessible HTML template URL
 * @returns {Promise}			A Promise which resolves to the compiled template or null
 */
async function getTemplate(path) {
	if (!_templateCache.hasOwnProperty(path)) {
		await new Promise(resolve => {
			game.socket.emit('template', path, resp => {
				compiled = Handlebars.compile(resp.html);
				Handlebars.registerPartial(path, compiled);
				_templateCache[path] = compiled;
				console.log(
					`Foundry VTT | Retrieved and compiled template ${path}`
				);
				resolve(compiled);
			});
		});
	}
	return _templateCache[path];
}

/* -------------------------------------------- */

/**
 * Load and cache a set of templates by providing an Array of paths
 * @param {Array} paths
 * @return {Promise}
 */
async function loadTemplates(paths) {
	for (let p of paths) {
		await getTemplate(p);
	}
}

/* -------------------------------------------- */

/**
 * Get and render a template using provided data and handle the returned HTML
 * Support asynchronous file template file loading with a client-side caching layer
 *
 * @param {String} path             The file path to the target HTML template
 * @param {Object} data             A data object against which to compile the template
 *
 * @return {Promise.<HTMLElement>}  Returns the rendered HTML
 */
function renderTemplate(path, data) {
	return getTemplate(path).then(template => {
		return template(data || {});
	});
}

/* -------------------------------------------- */

/**
 * A Handlebars helper to set an <option> within a <select> block as selected based on its value
 * Escape the string as handlebars would, then escape any regexp characters in it
 */
Handlebars.registerHelper('select', function(selected, options) {
	const escapedValue = escapeStringForRegexp(
		Handlebars.escapeExpression(selected)
	);
	const rgx = new RegExp(' value="' + escapedValue + '"');
	const html = options.fn(this);
	return html.replace(rgx, '$& selected');
});

/* -------------------------------------------- */

Handlebars.registerHelper('checked', function(value, options) {
	return Boolean(value) ? 'checked' : '';
});

/* -------------------------------------------- */

/**
 * An Handlebars helper to format numbers
 */
Handlebars.registerHelper('numberFormat', function(value, options) {
	// Helper parameters
	let dec =
			options.hash['decimals'] !== undefined
				? options.hash['decimals']
				: 0,
		sign = options.hash['sign'] || false;

	// Parse to float
	value = parseFloat(value).toFixed(dec);

	// Attach sign
	if (sign) {
		return value >= 0 ? '+' + value : value;
	} else {
		return value;
	}
});

/* -------------------------------------------- */

Handlebars.registerHelper('timeSince', function(value, options) {
	return timeSince(value);
});

/* -------------------------------------------- */

/**
 * Render a file-picker button linked to an <input> field
 */
Handlebars.registerHelper('filePicker', function(options) {
	let type = options.hash['type'],
		target = options.hash['target'];
	if (!target)
		throw new Error('You must define the name of the target field.');

	// Construct the HTML
	return new Handlebars.SafeString(`
  <button type="button" class="file-picker" data-type="${type}" data-target="${target}" title="Browse Files" tabindex="-1">
      <i class="fas fa-file-import fa-fw"></i>
  </button>`);
});

/* -------------------------------------------- */

/**
 * Render a MCE editor container with an optional toggle button
 */
Handlebars.registerHelper('editor', function(options) {
	let target = options.hash['target'],
		content = options.hash['content'] || '',
		button = Boolean(options.hash['button']),
		owner = Boolean(options.hash['owner']),
		editable = Boolean(options.hash['editable']);
	if (!target) throw new Error('You must define the name of a target field.');

	// Enrich the content
	content = TextEditor.enrichHTML(content, {
		secrets: owner,
		entities: true,
	});

	// Construct the HTML
	let editor = $(
		`<div class="editor"><div class="editor-content" data-edit="${target}">${content}</div></div>`
	);

	// Append edit button
	if (button && editable)
		editor.append(
			$('<a class="editor-edit"><i class="fas fa-edit"></i></a>')
		);
	return new Handlebars.SafeString(editor[0].outerHTML);
});

/* -------------------------------------------- */

Handlebars.registerHelper('localize', function(value, options) {
	return game.i18n.localize(value);
});

/* -------------------------------------------- */

/* Client Globals */
let socket,
	canvas,
	keyboard,
	game = {},
	ui = { windows: {} };
const vtt = CONST.vtt;

/**
 * The core Game instance which encapsulates the data, settings, and states relevant for managing the game experience.
 * The singleton instance of the Game class is available as the global variable ``game``.
 *
 * @param {Object} worldData    An object of all the World data vended by the server when the client first connects
 * @param {String} userId       The ID of the currently active user, retrieved from their session cookie
 * @param {Socket} socket       The open web-socket which should be used to transact game-state data
 */
class Game {
	constructor(worldData, userId, socket) {
		/**
		 * The object of world data passed from the server
		 * @type {Object}
		 */
		this.data = worldData;

		/**
		 * The id of the active game user
		 * @type {String}
		 */
		this.userId = userId;

		/**
		 * A reference to the open Socket.io connection
		 * @type {WebSocket}
		 */
		this.socket = socket;

		/**
		 * Client settings which are used to configure application behavior
		 * @type {ClientSettings}
		 */
		this.settings = new ClientSettings(this.data.settings || []);

		/**
		 * Localization support
		 * @type {Localization}
		 */
		this.i18n = new Localization();

		/**
		 * The Keyboard Manager
		 * @type {KeyboardManager}
		 */
		this.keyboard = null;

		/**
		 * A singleton instance of the Audio Helper class
		 * @type {AudioHelper}
		 */
		this.audio = new AudioHelper();

		/**
		 * A singleton instance of the Video Helper class
		 * @type {VideoHelper}
		 */
		this.video = new VideoHelper();

		/**
		 * Whether the Game is running in debug mode
		 * @type {Boolean}
		 */
		this.debug = false;

		/**
		 * A flag for whether the Game has successfully reached the "ready" hook
		 * @type {boolean}
		 */
		this.ready = false;
	}

	/* -------------------------------------------- */

	/**
	 * Fetch World data and return a Game instance
	 * @return {Promise}  A Promise which resolves to the created Game instance
	 */
	static async create() {
		// Get the session user
		const cookies = Game.getCookies();
		const userId = cookies.user;
		console.log(`${vtt} | Authenticated as User ${userId}`);

		// Connect to the game socket, passing the userId as an initial data packet
		const socket = io.connect(window.location.origin, {
			reconnection: true,
			reconnectionDelay: 1000,
			reconnectionAttempts: 3,
			reconnectionDelayMax: 5000,
			query: { userId: userId || null },
		});
		console.log(`${vtt} | Connected to server socket`);

		// Fetch World data, or Setup data if no world is configured
		let gameData = await this.getWorldData(socket);
		if (!gameData.world) gameData = await this.getSetupData(socket);

		// Create the Game instance
		return new Game(gameData, userId, socket);
	}

	/* -------------------------------------------- */

	/**
	 * Request World data from server and return it
	 * @return {Promise}
	 */
	static async getWorldData(socket) {
		return new Promise(resolve => {
			socket.emit('world', resolve);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Request setup data from server and return it
	 * @return {Promise}
	 */
	static async getSetupData(socket) {
		return new Promise(resolve => {
			socket.emit('getSetupData', resolve);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Game for the current window location
	 */
	async initialize() {
		console.log(`${vtt} | Initializing session`);
		this.ready = false;
		Hooks.callAll('init');

		// Begin loading fonts
		loadFont('Signika');
		loadFont('FontAwesome');

		// Register game settings
		this.registerSettings();

		// Initialize language translations
		await this.i18n.initialize();

		// Activate event listeners
		this.activateListeners();

		// Initialize client view
		const url = window.location.pathname;
		if (/\/game/.test(url)) return this._initializeGameView();
		else if (/\/setup/.test(url)) return this._initializeSetupView();
		else if (/\/join/.test(url)) return this._initializeJoinView();
		else if (/\/stream/.test(url)) return this._initializeStreamView();
		else if (/\/players/.test(url)) return this._initializePlayersView();
	}

	/* -------------------------------------------- */

	/**
	 * Shut down the currently active Game.
	 * Requires GameMaster user permission
	 * @return {Promise}
	 */
	async shutDown() {
		if (!game.user.isGM)
			throw new Error('You can not shut down the currently active Game');
		await fetch('./setup', {
			method: 'POST',
			body: { shutdown: true },
		}).then(resp => {
			if (resp.status === 200 && resp.redirected)
				window.location.href = resp.url;
		});
	}

	/* -------------------------------------------- */
	/*  Primary Game Initialization
  /* -------------------------------------------- */

	/**
	 * Fully set up the game state, initializing Entities, UI applications, and the Canvas
	 */
	async setupGame() {
		Hooks.callAll('setup');

		// Initialization Steps
		this.initializeEntities();
		await this.initializePacks();
		this.initializeRTC();
		this.initializeUI();
		await this.initializeCanvas();
		this.initializeKeyboard();
		this.openSockets();

		// Register sheet preferences
		EntitySheetConfig.initializeSheets();

		// If the player is not a GM and does not have an impersonated character, prompt for selection
		if (!this.user.isGM && !this.user.character) {
			new PlayerConfig(this.user).render(true);
		}

		// Call all game ready hooks
		this.ready = true;
		Hooks.callAll('ready');
	}

	/* -------------------------------------------- */

	/**
	 * Initialize game state data by creating Collections for all Entity types
	 */
	initializeEntities() {
		this.users = new Users(this.data.users).initialize();
		this.messages = new Messages(this.data.messages).initialize();
		this.scenes = new Scenes(this.data.scenes).initialize();
		this.actors = new Actors(this.data.actors).initialize();
		this.items = new Items(this.data.items).initialize();
		this.journal = new Journal(this.data.journal).initialize();
		this.macros = new Macros(this.data.macros).initialize();
		this.playlists = new Playlists(this.data.playlists).initialize();
		this.combats = new CombatEncounters(this.data.combat).initialize();
		this.tables = new RollTables(this.data.tables).initialize();
		this.folders = new Folders(this.data.folders).initialize();
	}

	/* -------------------------------------------- */

	/**
	 * Initialization actions for compendium packs
	 */
	async initializePacks() {
		const visibility = await game.settings.get(
			'core',
			'compendiumVisibility'
		);
		this.packs = this.data.packs.map(metadata => {
			const pack = new Compendium(metadata);
			if (visibility[pack.collection] === false) pack.public = false;
			return pack;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WebRTC implementation
	 */
	initializeRTC() {
		this.webrtc = new WebRTC(new WebRTCSettings());
		this.webrtc.initialize();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize core UI elements
	 */
	initializeUI() {
		ui.nav = new SceneNavigation().render();
		ui.controls = new SceneControls();
		ui.notifications = new Notifications().render();
		ui.sidebar = new Sidebar().render();
		ui.players = new PlayerList().render();
		ui.hotbar = new Hotbar().render();
		ui.webrtc = new CameraViews(this.webrtc).render();
		ui.pause = new Pause().render();
		ui.menu = new MainMenu();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the game Canvas
	 */
	async initializeCanvas() {
		if (document.getElementById('board')) {
			try {
				canvas = new Canvas();
				await canvas.draw();
			} catch (err) {
				console.error(
					`Failed to render WebGL canvas! Be sure to read the following error carefully.`
				);
				console.error(err);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Initialize Keyboard and Mouse controls
	 */
	initializeKeyboard() {
		keyboard = new KeyboardManager();
		this.keyboard = keyboard;
	}

	/* -------------------------------------------- */

	/**
	 * Register core game settings
	 */
	registerSettings() {
		// Language preference
		game.settings.register('core', 'language', {
			name: 'SETTINGS.LangN',
			hint: 'SETTINGS.LangL',
			scope: 'client',
			config: true,
			default: 'en',
			type: String,
			choices: CONFIG.supportedLanguages,
			onChange: lang => window.location.reload(),
		});

		// Register module configuration settings
		game.settings.register('core', ModuleManagement.CONFIG_SETTING, {
			name: 'Module Configuration Settings',
			scope: 'world',
			config: false,
			default: {},
			type: Object,
			onChange: settings => console.log(settings),
		});

		// Register compendium visibility setting
		game.settings.register('core', 'compendiumVisibility', {
			name: 'Compendium Visibility Controls',
			scope: 'world',
			config: false,
			default: {},
			type: Object,
			onChange: enabled => {
				game.packs.forEach(
					p =>
						(p.public = enabled.hasOwnProperty(p.collection)
							? enabled[p.collection]
							: true)
				);
				ui.compendium.render();
			},
		});

		// Allow Trusted player uploads
		game.settings.register('core', 'allowTrustedUpload', {
			name: 'SETTINGS.TrustUpN',
			hint: 'SETTINGS.TrustUpL',
			scope: 'world',
			config: true,
			default: false,
			type: Boolean,
		});

		// Combat Tracker Configuration
		game.settings.register('core', Combat.CONFIG_SETTING, {
			name: 'Combat Tracker Configuration',
			scope: 'world',
			config: false,
			default: {},
			type: Object,
			onChange: setting => {
				game.combats.settings = setting;
				if (game.combat) {
					game.combat.setupTurns();
					game.combats.render();
				}
			},
		});

		// Entity Sheet Class Configuration
		game.settings.register('core', 'sheetClasses', {
			name: 'Sheet Class Configuration',
			scope: 'world',
			config: false,
			default: {},
			type: Object,
			onChange: setting =>
				EntitySheetConfig._updateDefaultSheets(setting),
		});

		// Register game settings which modify behavior of the walls layer
		game.settings.register('core', 'playerDoors', {
			name: 'SETTINGS.PDoorN',
			hint: 'SETTINGS.PDoorL',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
		});

		// Are Chat Bubbles Enabled?
		game.settings.register('core', 'chatBubbles', {
			name: 'SETTINGS.CBubN',
			hint: 'SETTINGS.CBubL',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
		});

		// Pan to Token Speaker
		game.settings.register('core', 'chatBubblesPan', {
			name: 'SETTINGS.CBubPN',
			hint: 'SETTINGS.CBubPL',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
		});

		// Register game settings which configure Message behavior
		game.settings.register('core', 'secretMessages', {
			name: 'SETTINGS.SMesgN',
			hint: 'SETTINGS.SMesgL',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
			onChange: enabled => ui.chat.postAll(),
		});

		// Soft Shadows
		game.settings.register('core', 'softShadows', {
			name: 'SETTINGS.SoftSN',
			hint: 'SETTINGS.SoftSL',
			config: true,
			default: true,
			type: Boolean,
			onChange: enabled => {
				if (canvas.sight) canvas.sight._onChangeSoftShadows(enabled);
			},
		});

		// Show Player Cursors
		game.settings.register('core', 'showCursors', {
			name: 'SETTINGS.CursorN',
			hint: 'SETTINGS.CursorL',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
			onChange: enabled => {
				if (canvas.controls)
					canvas.controls._onChangeCursorSetting(enabled);
			},
		});

		// Default Drawing Configuration
		game.settings.register('core', DrawingsLayer.DEFAULT_CONFIG_SETTING, {
			name: 'Default Drawing Configuration',
			scope: 'client',
			config: false,
			default: {},
			type: Object,
		});

		// Entity-specific settings
		RollTables.registerSettings();
		Macros.registerSettings();

		// Audio playback settings
		AudioHelper.registerSettings();

		// Register CanvasLayer settings
		NotesLayer.registerSettings();
		TemplateLayer.registerSettings();
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * The currently connected User
	 * @type {User}
	 */
	get user() {
		return this.users ? this.users.get(this.userId) : null;
	}

	/* -------------------------------------------- */

	/**
	 * Metadata regarding the current game World
	 * @type {Object}
	 */
	get world() {
		return this.data.world;
	}

	/* -------------------------------------------- */

	/**
	 * Metadata regarding the game System which powers this World
	 * @type {Object}
	 */
	get system() {
		return this.data.system;
	}

	/* -------------------------------------------- */

	/**
	 * An Array of metadata for each Module which is active within this game World
	 * @type {Array<Object>}
	 */
	get modules() {
		return this.data.modules;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the currently active Combat encounter
	 * @type {Combat}
	 */
	get combat() {
		return this.combats.active;
	}

	/* -------------------------------------------- */

	/**
	 * A state variable which tracks whether or not the game session is currently paused
	 * @type {Boolean}
	 */
	get paused() {
		return this.data.paused;
	}

	/* -------------------------------------------- */

	/**
	 * A convenient reference to the currently active canvas tool
	 * @type {String}
	 */
	get activeTool() {
		return ui.controls.activeTool;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Toggle the pause state of the game
	 * Trigger the `pauseGame` Hook when the paused state changes
	 * @param {Boolean} pause     The new pause state
	 * @param {Boolean} [push]    Push the pause state change to other connected clients?
	 */
	togglePause(pause, push = false) {
		this.data.paused = pause || !this.data.paused;
		if (push && game.user.isGM) game.socket.emit('pause', this.data.paused);

		// Render the paused UI
		ui.pause.render();

		// Call API hooks
		Hooks.callAll('pauseGame', this.data.paused);
	}

	/* -------------------------------------------- */
	/*  Cookie Management                           */
	/* -------------------------------------------- */

	static getCookies() {
		const cookies = {};
		for (let cookie of document.cookie.split('; ')) {
			let [name, value] = cookie.split('=');
			cookies[name] = decodeURIComponent(value);
		}
		return cookies;
	}

	/* -------------------------------------------- */

	static clearCookies() {
		document.cookie =
			'user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
		return true;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Open socket listeners which transact game state data
	 */
	openSockets() {
		AudioHelper.socketListeners(this.socket);
		Game.socketListeners(this.socket);
		Users.socketListeners(this.socket);
		Scenes.socketListeners(this.socket);
		Actors.socketListeners(this.socket);
		Items.socketListeners(this.socket);
		Journal.socketListeners(this.socket);
		RollTables.socketListeners(this.socket);
		Playlists.socketListeners(this.socket);
		CombatEncounters.socketListeners(this.socket);
		Messages.socketListeners(this.socket);
		Folders.socketListeners(this.socket);
		Macros.socketListeners(this.socket);
		ClientSettings.socketListeners(this.socket);
		ControlsLayer.socketListeners(this.socket);
	}

	/* -------------------------------------------- */

	/**
	 * General game-state socket listeners and event handlers
	 * @param socket
	 */
	static socketListeners(socket) {
		// Disconnection and reconnection attempts
		socket.on('disconnect', reason => {
			ui.notifications.error(
				'You have lost connection to the server, attempting to re-establish.'
			);
		});

		// Reconnect failed
		socket.on('reconnect_failed', () => {
			ui.notifications.error('Server connection lost.');
			window.location.href = ROUTE_PREFIX + '/no';
		});

		// Reconnect succeeded
		socket.on('reconnect', attemptNumber => {
			ui.notifications.info('Server connection re-established.');
		});

		// Handle pause
		socket.on('pause', pause => {
			game.togglePause(pause, false);
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate Event Listeners which apply to every Game View
	 */
	activateListeners() {
		// Disable touch zoom
		document.addEventListener('touchmove', ev => {
			if (ev.scale !== 1) ev.preventDefault();
		});

		// Disable right-click
		document.addEventListener('contextmenu', ev => ev.preventDefault());

		// Disable mouse 3, 4, and 5
		document.addEventListener('mousedown', ev => {
			if ([3, 4, 5].includes(ev.button)) ev.preventDefault();
		});

		// Handle window resizing
		window.addEventListener('resize', event => this._onResize(event));

		// Entity links
		TextEditor.activateListeners();

		// Await gestures to begin audio and video playback
		game.audio.awaitFirstGesture();
		game.video.awaitFirstGesture();
	}

	/* -------------------------------------------- */

	/**
	 * Handle resizing of the game window
	 * Reposition any active UI windows
	 * @private
	 */
	_onResize(event) {
		Object.values(ui.windows).forEach(app => app.setPosition());
		if (canvas && canvas.ready) canvas._onResize(event);
	}

	/* -------------------------------------------- */
	/*  View Initialization Functions
  /* -------------------------------------------- */

	/**
	 * Initialization steps for the primary Game view
	 * @private
	 */
	async _initializeGameView() {
		// Require a valid user cookie and EULA acceptance
		if (!SIGNED_EULA) window.location.href = ROUTE_PREFIX + '/no';
		if (!this.userId) {
			let err =
				'Something went wrong with your user cookie, please reload your session.';
			$('body').html($(`<div class="banner error">${err}</div>`));
			throw new Error(err);
		}

		// Setup the game
		this.setupGame();

		// Set a timeout of 10 minutes before kicking the user off
		setTimeout(() => {
			if (this.user.isGM || !this.data.demo) return;
			console.log(
				`${vtt} | Ending demo session after 10 minutes. Thanks for testing!`
			);
			this.socket.disconnect();
			Game.clearCookies();
			window.location.href = ROUTE_PREFIX + '/join';
		}, 1000 * 60 * 10);

		// Context menu listeners
		ContextMenu.eventListeners();

		// Force hyperlinks to a separate window/tab
		$(document).on('click', 'a[href]', ev => {
			if (ev.target.href === 'javascript:void(0)') return;
			ev.preventDefault();
			window.open(ev.target.href, '_blank');
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialization steps for the game setup view
	 * @private
	 */
	async _initializeSetupView() {
		ui.notifications = new Notifications().render();
		if (!SIGNED_EULA) new EULA().render(true);
		ui.setup = new SetupConfiguration(game.data).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Initialization steps for the game setup view
	 * @private
	 */
	async _initializeJoinView() {
		ui.notifications = new Notifications().render();
		const form = document.getElementById('join-form');
		form.addEventListener('submit', this._onJoinFormSubmit.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle submission of the Join Game form.
	 * Submit a POST request to the server, and either redirect or notify depending on the response.
	 * @param {Event} event     The form submission event
	 * @return {Promise}
	 * @private
	 */
	async _onJoinFormSubmit(event) {
		event.preventDefault();

		// Disable the button and collect form data
		const form = event.target;
		form.submit.disabled = true;
		const formData = new FormData(form);

		// Submit a POST request to the server
		const response = await fetch(window.location.pathname, {
			method: 'POST',
			body: formData,
		}).then(r => r.json());

		// Redirect on success
		if (response.status === 'success') {
			ui.notifications.info('Login successful, joining game!');
			setTimeout(() => (window.location.href = response.redirect), 500);
		}

		// Notify on failure
		else if (response.status === 'failed') {
			ui.notifications.error(response.error);
			form.submit.disabled = false;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Initialization steps for the Stream helper view
	 * @private
	 */
	async _initializeStreamView() {
		this.users = new Users(this.data.users).initialize();
		this.messages = new Messages(this.data.messages).initialize();
		this.actors = new Actors(this.data.actors).initialize();
		ui.chat = new ChatLog({ stream: true }).render();
		Messages.socketListeners(this.socket);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Player Management View
	 * @private
	 */
	async _initializePlayersView() {
		if (!SIGNED_EULA) window.location.href = ROUTE_PREFIX + '/no';
		this.users = new Users(this.data.users).initialize();
		this.players = new UserManagement(this.users);
		this.players.render(true);
		ui.notifications = new Notifications().render();
		Users.socketListeners(this.socket);
	}
}

/* -------------------------------------------- */

/**
 * Once the Window has loaded, created and initialize the Game object
 */
window.addEventListener(
	'DOMContentLoaded',
	async function() {
		game = await Game.create();
		game.initialize();
	},
	{ once: true, passive: true }
);

/**
 * The base Die class.
 *
 * Each Die instance represents a distinct term in a roll equation which transacts rolls of an die with some number
 * of faces. The Die instance provides controls for rerolling, exploding, counting, or modifying the set of results
 * from the Die.
 *
 * @param {Number} faces    The number of faces for this Die
 *
 * @example
 * // Define a 6-sided die
 * let die = new Die(6);
 *
 * // Roll the die 4 times
 * die.roll(4);
 *
 * // Roll another 2 times, adding the new results to the existing set
 * die.roll(2);
 *
 * // For all 6 of the initial rolls, reroll if any result was a 1
 * die.reroll([1]);
 *
 * // For set of remaining results, roll a bonus die if any result was a 6
 * die.explode([6]);
 *
 * // Count the total number of rolls which was greater than 3
 * die.countSuccess(3, ">");
 *
 * // Display the total number of successes
 * console.log(die.total);
 */
class Die {
	constructor(faces, options = {}) {
		/**
		 * The number of faces for this Die
		 * @type {Number}
		 *
		 * @example
		 * let die = new Die(6);    // A 6-sided die has six faces
		 * console.log(die.faces)   // 6
		 */
		this.faces = this._getFaces(faces);

		/**
		 * An Array representing the faces of the die
		 * @type {Array}
		 *
		 * @example
		 * let die = new Die(6);    // One side for each of the possible faces
		 * console.log(die.sides)   // [1,2,3,4,5,6]
		 */
		this.sides =
			faces instanceof Array
				? faces.map(s => parseInt(s))
				: Array.from(new Array(parseInt(faces))).map((e, i) => i + 1);

		/**
		 * Track all dice which have ever been rolled
		 * @type {Array}
		 *
		 * @example
		 * let die = new Die(4);
		 * die.roll(4);             // Roll 4d4
		 * console.log(die.rolls);  // [{...}, {...}, {...}, {...}]
		 */
		this.rolls = [];

		/**
		 * Any additional options which may be required by the Die
		 */
		this.options = options;
	}

	/* -------------------------------------------- */

	/**
	 * Track the set of kept results out of all rolls
	 * @type {Array}
	 *
	 * @example
	 * let die = new Die(6);
	 * die.roll(6);               // Roll 6d6
	 * console.log(die.results);  // [6,4,1,2,3,4]
	 * die.keepHighest(2);        // Keep the 2 best results
	 * console.log(die.results);  // [6,4]
	 */
	get results() {
		return this.rolls
			.filter(r => !r.rerolled && !r.discarded)
			.map(r => {
				if (r.success === true) return 1;
				else if (r.success === false) return 0;
				return r.roll;
			});
	}

	/* -------------------------------------------- */

	/**
	 * The sum of all kept results
	 * @type {Number}
	 *
	 * @example
	 * let die = new Die(20);
	 * die.roll(2);               // Roll 2d20
	 * console.log(die.results)   // [6,17]
	 * console.log(die.total)     // 23
	 */
	get total() {
		const total = this.results.reduce((t, n) => t + n);
		if (this.options.marginSuccess)
			return total - parseInt(this.options.marginSuccess);
		else if (this.options.marginFailure)
			return parseInt(this.options.marginFailure) - total;
		return total;
	}

	/* -------------------------------------------- */

	_getFaces(f) {
		if (Number.isFinite(f) && f > 0) return f;
		else throw new Error(`Invalid number of faces ${f} for Die class`);
	}

	/* -------------------------------------------- */

	/**
	 * Roll this Die once
	 * @return {Number}
	 * @private
	 */
	_roll() {
		let res = Math.floor(twist.random() * this.sides.length);
		return {
			roll: this.sides[res],
		};
	}

	/* -------------------------------------------- */

	/**
	 * Roll the initial set of results for the Die
	 * @param {Number} nd     The number of times to roll the die
	 * @return {Die}          The updated die containing new rolls
	 *
	 * @example
	 * let die = new Die(6);
	 * die.roll(6);               // Roll 6d6
	 * console.log(die.results);  // [5,2,4,4,1,6]
	 * console.log(die.total);    // 22
	 */
	roll(nd) {
		nd = nd || 1;
		let rolls = [];
		for (let n = 1; n <= nd; n++) {
			rolls.push(this._roll());
		}
		this.rolls = this.rolls.concat(rolls);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Re-roll any results with results in the provided target set
	 * Dice which have already been re-rolled will not be re-rolled again
	 * @param {Array} targets       Target results which would trigger a reroll
	 * @return {Die}                The updated die containing new rolls
	 *
	 * @example
	 * let die = new Die(4);
	 * die.roll(3);               // Roll 3d4
	 * console.log(die.results);  // [1,3,4]
	 * die.reroll([1,2]);         // Re-roll 1s or 2s
	 * console.log(die.results);  // [3,4,2]
	 */
	reroll(targets) {
		if (!targets || !targets.length) return this.rolls;

		// Flag dice which are eligible for re-roll
		let eligible = this.rolls.filter(r => {
			if (r.rerolled || r.discarded) return false;
			else if (targets.includes(r.roll)) return (r.rerolled = true);
			return false;
		});

		// Roll any eligible dice
		let rolls = eligible.map(r => this._roll());
		this.rolls = this.rolls.concat(rolls);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Explode the rolls in this set by rolling additional dice for each roll which achieved a certain result
	 * Dice which have been re-rolled or have already exploded cannot explode
	 * @param {Array} range         The range of target results which would trigger an explode
	 * @return {Die}                The updated die containing new rolls
	 *
	 * @example
	 * let die = new Die(8);
	 * die.roll(6);               // Roll 6d8
	 * console.log(die.results);  // [8,3,6,4,2,7]
	 * die.explode([7,8]);        // Explode on 7s and 8s, rolling additional dice
	 * console.log(die.results);  // [8,3,6,4,2,7,7,2,3]
	 */
	explode(range) {
		if (!range || !range.length || range.length === this.faces) return this;

		// Explode until there are no valid results left to explode
		let exploding = true,
			rolls = this.rolls;
		while (exploding) {
			// Get the dice which are eligible to explode
			let eligible = rolls.filter((r, i) => {
				if (r.rerolled || r.discarded || r.exploded) return false;
				if (range.includes(r.roll)) return (r.exploded = true);
				return false;
			});

			// Roll any eligible dice
			rolls = eligible.map(r => this._roll());
			exploding = rolls.length > 0;
			this.rolls = this.rolls.concat(rolls);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Filter the result set, keeping the highest n results in order
	 * @param {Number} n    The number of results to keep
	 * @return {Die}        The updated die containing new rolls
	 *
	 * @example
	 * let die = new Die(6);
	 * die.roll(4);               // Roll 4d6
	 * console.log(die.results);  // [6,2,1,5]
	 * die.keepHighest(2);        // Keep the best 2 results
	 * console.log(die.results);  // [6,5]
	 */
	keepHighest(n) {
		let cut = this.results.sort((a, b) => b - a)[n - 1],
			kept = 0;
		let rolls = this.rolls.filter(r => !r.rerolled && !r.discarded);

		// First drop any results that are strictly lower than the cut
		rolls.forEach(r => {
			if (r.roll > cut) ++kept;
			else if (r.roll < cut) r.discarded = true;
		});

		// Next keep ties until we have reached the target
		rolls
			.filter(r => r.roll === cut)
			.forEach(r => {
				if (kept < n) ++kept;
				else r.discarded = true;
			});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Filter the result set, keeping the lowest n results in order
	 * @param {Number} n    The number of results to keep
	 * @return {Array}      The filtered results
	 *
	 * @example
	 * let die = new Die(6);
	 * die.roll(4);               // Roll 4d6
	 * console.log(die.results);  // [6,2,1,5]
	 * die.keepLowest(3);         // Kepe the lowest 3 results
	 * console.log(die.results);  // [2,1,5]
	 */
	keepLowest(n) {
		let cut = this.results.sort((a, b) => a - b)[n - 1],
			kept = 0;
		let rolls = this.rolls.filter(r => !r.rerolled && !r.discarded);

		// First drop any results that are strictly higher than the cut
		rolls.forEach(r => {
			if (r.roll < cut) ++kept;
			else if (r.roll > cut) r.discarded = true;
		});

		// Next keep ties until we have reached the target
		rolls
			.filter(r => r.roll === cut)
			.forEach(r => {
				if (kept < n) ++kept;
				else r.discarded = true;
			});
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Map results to 0 or 1 depending on whether they match a success condition
	 * @param {Number} target     The target result to test against
	 * @param {String} operator   The comparison operator against which to test. Default is '>='
	 *
	 * @example
	 * let die = new Die(3);
	 * die.roll(6);               // Roll 6d3
	 * console.log(die.results);  // [1,3,1,2,2,3]
	 * die.countSuccess(3);       // Count the results where a 3 was rolled
	 * console.log(die.results);  // [0,1,0,0,0,1]
	 * console.log(die.total);    // 2
	 */
	countSuccess(target, operator) {
		operator = operator || '>=';
		this.rolls.forEach(r => {
			if (r.rerolled || r.discarded) return;
			if (operator === '>=' && Number(r.roll >= target)) r.success = true;
			else if (operator === '>' && Number(r.roll > target))
				r.success = true;
			else if (operator === '=' && Number(r.roll === target))
				r.success = true;
			else if (operator === '<' && Number(r.roll < target))
				r.success = true;
			else if (operator === '<=' && Number(r.roll <= target))
				r.success = true;
			else r.success = false;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Special Die types may optionally define a tooltip used in lieu of the numeric result
	 * @param {Number} result   The rolled die result
	 * @private
	 */
	_getTooltip(result) {
		return result;
	}
}

/**
 * A special die used by Fate/Fudge systems
 * Mathematically behaves like 1d3-2
 * @type {Die}
 */
class FateDie extends Die {
	constructor() {
		super(3);
		this.sides = [-1, 0, 1];
	}

	/* -------------------------------------------- */

	/**
	 * Special Die types may optionally define a tooltip used in lieu of the numeric result
	 * @param {Number} result   The rolled die result
	 * @private
	 */
	_getTooltip(result) {
		return {
			'-1': '-',
			'0': '&nbsp;',
			'1': '+',
		}[result];
	}
}

/**
 * This class provides an interface and API for conducting dice rolls.
 * The basic structure for a dice roll is a string formula and an object of data against which to parse it.
 *
 * @param formula {String}    The string formula to parse
 * @param data {Object}       The data object against which to parse attributes within the formula
 *
 * @example
 * // Attack with advantage!
 * let r = new Roll("2d20kh + @prof + @strMod", {prof: 2, strMod: 4});
 *
 * // The parsed components of the roll formula
 * console.log(r.parts);    // [Die, +, 2, +, 4]
 *
 * // Execute the roll
 * r.roll();
 *
 * // The resulting equation after it was rolled
 * console.log(r.result);   // 16 + 2 + 4
 *
 * // The total resulting from the roll
 * console.log(r.total);    // 22
 */
class Roll {
	constructor(formula, data) {
		/**
		 * The original provided formula
		 * This formula will be reinterpreted once components have been parsed
		 * @type {String}
		 */
		this._formula = formula;

		/**
		 * The original provided data
		 * @type {Object}
		 */
		this.data = data;

		/**
		 * An array of parsed formula terms
		 * @type {Array}
		 */
		this.terms = [];

		/**
		 * An array of evaluate Roll parts
		 * @type {Array}
		 */
		this.parts = [];

		/**
		 * An internal flag for whether the Roll object has been rolled
		 * @private
		 */
		this._rolled = false;

		/**
		 * Cache the rolled total to avoid re-evaluating it multiple times
		 */
		this._result = null;

		/**
		 * Cache the evaluated total to avoid re-evaluating it
		 */
		this._total = null;

		/**
		 * Regular expression patterns
		 */
		this.rgx = {
			reroll: /r(<=|>=|<|>)?([0-9]+)?/,
			explode: /x(<=|>=|<|>)?([0-9]+)?/,
			keep: /(kh|kl|dh|dl)([0-9]+)?/,
			success: /(cs|cf|ms)(<=?|>=?|=)?([0-9]+)?/,
		};

		// Initialize the roll
		this._init(this._formula);
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Express the Roll as a formatted string formula
	 * @return {String}
	 */
	get formula() {
		if (!this._rolled) return this._formula;
		return this.parts
			.map(p => (p instanceof Die ? p.formula : p))
			.join(' ');
	}

	/**
	 * The resulting arithmetic expression after rolls have been evaluated
	 * @return {String}
	 */
	get result() {
		return this._result;
	}

	/**
	 * Express the total result of the roll and cache the result to avoid re-evaluating
	 * @return {Number}
	 */
	get total() {
		if (!this._rolled) return null;
		if (!this._total) {
			let total = this._safeEval(this.result);
			this._total = Number.isInteger(total)
				? total
				: Math.round(total * 100) / 100;
		}
		return this._total;
	}

	/**
	 * Get an Array of any :class:`Die` objects which were rolled as part of the evaluation of this roll
	 * @type {Array}
	 */
	get dice() {
		return this.parts.filter(p => p instanceof Die);
	}

	/**
	 * The regular expression used to identify a Die component of a Roll
	 * @private
	 * @type {String}
	 */
	static get diceRgx() {
		return '([0-9]+)?[dD]([0-9fF]+)([a-z][a-z0-9<=>]+)?';
	}

	/**
	 * Record supported arithmetic operators for Roll instances
	 * @private
	 * @type {Array.<String>}
	 */
	static get arithmeticOperators() {
		return ['+', '-', '*', '/'];
	}

	/* -------------------------------------------- */
	/*  Initialization                              */
	/* -------------------------------------------- */

	/**
	 * Initialize the roll object using a provided formula
	 * @param formula {String}    The roll formula
	 * @private
	 */
	_init(formula) {
		// Step 1 - Substitute provided data
		formula = this._replaceData(formula);

		// Step 2 - Parse the substituted formula into parts
		this.terms = this._getTerms(formula);
	}

	/* -------------------------------------------- */

	/**
	 * Replace referenced data attributes in the roll formula with the syntax `@attr` with the corresponding key from
	 * the provided `data` object.
	 * @param {String} formula    The original formula within which to replace
	 * @private
	 */
	_replaceData(formula) {
		let dataRgx = new RegExp(/@([a-z.0-9]+)/gi);
		return formula.replace(dataRgx, (match, term) => {
			let value = getProperty(this.data, term);
			return value ? String(value).trim() : '0';
		});
	}

	/* -------------------------------------------- */

	/**
	 * Parse a string formula, extracting arithmetic operators and enforcing standardized spacing
	 * Return the terms of the formula as an Array
	 * @private
	 */
	_getTerms(formula) {
		let arith = this.constructor.arithmeticOperators,
			math = arith.concat(['(', ')']),
			split = new RegExp(math.map(t => '\\' + t).join('|'), 'g'),
			terms = formula.replace(split, t => `;${t};`).split(';');
		return terms
			.map(t => t.trim())
			.filter(t => t !== '')
			.filter((t, i, arr) => {
				return !(t === '+' && arr[i - 1] === '+');
			});
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Execute the Roll, replacing dice and evaluating the total result
	 * @returns {Roll}    The rolled Roll object, able to be chained into other methods
	 *
	 * @example
	 * let r = new Roll("2d6 + 4 + 1d4");
	 * r.roll();
	 * > 12
	 */
	roll() {
		if (this._rolled)
			throw new Error('This Roll object has already been rolled.');
		this.parts = this._replaceDice(this.terms);

		// Evaluate the result to make sure it is safe
		let result = this.parts
			.map(p => (p instanceof Die ? p.total : p))
			.join(' ');
		this._result = this._validateResult(result);

		// Denote that the roll has been evaluated
		this._rolled = true;
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Create a new Roll object using the original provided formula and data
	 * Each roll is immutable, so this method returns a new Roll instance using the same data.
	 * @returns {Roll}    A new Roll object, rolled using the same formula and data
	 */
	reroll() {
		let r = new this.constructor(this._formula, this.data);
		return r.roll();
	}

	/* -------------------------------------------- */

	/**
	 * Replace terms within a formula group which match a dice roll syntax with a :class:`Die` instance
	 * Basic syntax is {n}d{X}{mods}
	 * @private
	 */
	_replaceDice(terms) {
		return terms.map((term, i) => {
			// Recursively delegate inner groups
			if (term instanceof Array) {
				return this._replaceDice(term);
			}

			// Check for match
			let rgx = term.match(new RegExp(this.constructor.diceRgx));
			if (!rgx) return term;

			// Get die sides
			let sides = rgx[2],
				cls = Die;
			if (/[f|F]/.test(sides)) cls = FateDie;
			else {
				sides = parseInt(sides);
				if (sides > 10000)
					throw new Error(
						'You may not roll dice with more than 10000 sides'
					);
			}

			// Get dice number and sides
			let number = parseInt(rgx[1] || 1);
			if (!Number.isFinite(number) || number <= 0)
				throw new Error('Invalid number of rolled dice.');
			else if (number > 100)
				throw new Error(
					'You may not roll more than 100 dice at a time'
				);

			// Determine which roll options are requested
			let options = this._parseOptions(rgx[3]);

			// Create the Die and roll it
			let die = new cls(sides);
			die.roll(number);

			// Apply any modifiers
			for (let option of options) {
				this._rerollDie(die, option);
				this._explodeDie(die, option);
				this._keepDropDie(die, option);
				this._successDie(die, option);
			}

			// Replace the part with the Die
			die.formula = `${number}d${sides}${options.join('').toLowerCase()}`;
			return die;
		});
	}

	/* -------------------------------------------- */

	_validateResult(result) {
		const unsafeMath = /([a-zA-Z_{1}][a-zA-Z0-9_]+)(?=[\s+]?\()/g;
		let valid = true;
		result.replace(unsafeMath, fn => {
			if (Math.hasOwnProperty(fn)) return 'Math.' + fn;
			else valid = false;
		});
		if (!valid) throw new Error('Invalid arithmetic expression!');
		return result;
	}

	/* -------------------------------------------- */

	/**
	 * Safely evaluate a formulaic expression using a Proxy environment which is allowed access to Math commands
	 * @param {String} expression     The formula expression to evaluate
	 * @return {Number}               The returned numeric result
	 * @private
	 */
	_safeEval(expression) {
		const src = 'with (sandbox) { return ' + expression + '}';
		const evl = new Function('sandbox', src);
		return evl(CONFIG.Roll.mathProxy);
	}

	/* -------------------------------------------- */

	/**
	 * Parse options and determine their order of operations
	 * @param {String} query    The dice roll options query
	 */
	_parseOptions(query) {
		if (!query) return [];
		for (let p of Object.values(this.rgx)) {
			query = query.replace(RegExp(p, 'g'), match => match + ';');
		}
		let options = query.split(';').filter(o => o !== '');
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Reroll a single die by parsing the option string
	 * @private
	 */
	_rerollDie(die, option) {
		let rr = option.match(this.rgx.reroll);
		if (!rr) return;

		// Determine the reroll range
		let target,
			nrr = parseInt(rr[2] || 1);
		if (rr[1]) {
			if (rr[1] === '<') target = Array.fromRange(nrr);
			else if (rr[1] === '<=')
				target = Array.fromRange(nrr).map(n => n + 1);
			else if (rr[1] === '>')
				target = Array.fromRange(die.faces - nrr).map(n => n + nrr + 1);
			else if (rr[1] === '>=')
				target = Array.fromRange(die.faces - nrr + 1).map(n => n + nrr);
		} else target = [nrr];

		// Reroll the die
		die.reroll(target);
	}

	/* -------------------------------------------- */

	/**
	 * Explode a single die by parsing the option string
	 * @private
	 */
	_explodeDie(die, option) {
		let ex = option.match(this.rgx.explode);
		if (!ex) return;
		let operator = ex[1];
		let target = parseInt(ex[2] || die.faces);

		// Define target arrays
		let range = die.sides.filter(s => {
			if (operator === '<') return s < target;
			else if (operator === '<=') return s <= target;
			else if (operator === '>') return s > target;
			else if (operator === '>=') return s >= target;
			return s === target;
		});

		// Explode the die
		die.explode(range);
	}

	/* -------------------------------------------- */

	/**
	 * Keep or drop die by parsing the option string
	 * @private
	 */
	_keepDropDie(die, option) {
		let kd = option.match(this.rgx.keep);
		if (!kd) return;
		let nr = die.results.length,
			mode = kd[1],
			num = parseInt(kd[2] || 1);

		// Highest
		if (['kh', 'dl'].includes(mode)) {
			if (mode === 'dl') num = Math.max(nr - num, 1);
			die.keepHighest(num);
		}

		// Lowest
		else if (['kl', 'dh'].includes(mode)) {
			if (mode === 'dh') num = Math.min(nr - num);
			die.keepLowest(num);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Count successes or margin of success
	 * @private
	 */
	_successDie(die, option) {
		let cs = option.match(this.rgx.success);
		if (!cs) return;
		let mode = cs[1],
			operator = cs[2],
			target = parseInt(cs[3]);

		// Count successes or failures
		if (['cs', 'cf'].includes(mode)) {
			// Flip the operator for counting failures
			if (mode === 'cf') {
				operator = {
					'>=': '<',
					'>': '<=',
					'<': '>=',
					'<=': '>',
				}[operator];
			}

			// Apply the die function
			die.countSuccess(target, operator);
		}

		// Margin of success or failure
		else if (mode === 'ms') {
			if (['>', '>=', '=', undefined].includes(operator))
				die.options['marginSuccess'] = target;
			else if (['<', '<='].includes(operator))
				die.options['marginFailure'] = target;
		}
	}

	/* -------------------------------------------- */
	/*  HTML Rendering
  /* -------------------------------------------- */

	/**
	 * Render a Roll instance to HTML
	 * @param chatOptions {Object}      An object configuring the behavior of the resulting chat message.
	 * @return {Promise.<HTMLElement>}  A Promise which resolves to the rendered HTML
	 */
	async render(chatOptions = {}) {
		chatOptions = mergeObject(
			{
				user: game.user._id,
				flavor: null,
				template: CONFIG.Roll.template,
				blind: false,
			},
			chatOptions
		);

		// Execute the roll, if needed
		if (!this._rolled) this.roll();

		// Define chat data
		const chatData = {
			user: chatOptions.user,
			flavor: chatOptions.flavor,
		};

		// Blind results
		if (chatOptions.isPrivate) {
			chatData.formula = '???';
			chatData.tooltip = '';
			chatData.total = '?';
		}

		// Regular results
		else {
			chatData.formula = this.formula;
			chatData.tooltip = await this.getTooltip();
			chatData.total = this.total;
		}

		// Render the roll display template
		return renderTemplate(chatOptions.template, chatData);
	}

	/* -------------------------------------------- */

	/**
	 * Render the tooltip HTML for a Roll instance
	 * @return {Promise.<HTMLElement>}
	 */
	getTooltip() {
		const data = {
			formula: this.formula,
			total: this.total,
		};

		// Prepare dice parts
		const dice = this.parts.filter(p => p instanceof Die);
		data['parts'] = dice.map(d => {
			let minRoll = Math.min(...d.sides),
				maxRoll = Math.max(...d.sides);

			// Generate tooltip data
			return {
				formula: d.formula,
				total: d.total,
				faces: d.faces,
				rolls: d.rolls.map(r => {
					return {
						result: d._getTooltip(r.roll),
						classes: [
							'd' + d.faces,
							r.rerolled ? 'rerolled' : null,
							r.exploded ? 'exploded' : null,
							r.discarded ? 'discarded' : null,
							r.roll === minRoll ? 'min' : null,
							r.roll === maxRoll ? 'max' : null,
						]
							.filter(c => c)
							.join(' '),
					};
				}),
			};
		});

		// Render the tooltip template
		return renderTemplate(CONFIG.Roll.tooltip, data);
	}

	/* -------------------------------------------- */

	/**
	 * Transform a Roll instance into a ChatMessage, displaying the roll result.
	 * This function can either create the ChatMessage directly, or return the data object that will be used to create.
	 *
	 * @param {Object} chatData             The data object to use when creating the message
	 * @param {string|null} [rollMode=null] The template roll mode to use for the message from CONFIG.rollModes
	 * @param {boolean} [create=true]       Whether to automatically create the chat message, or only return the prepared
	 *                                      chatData object.
	 * @return {Promise|Object}             A promise which resolves to the created ChatMessage entity, if create is true
	 *                                      or the Object of prepared chatData otherwise.
	 */
	toMessage(chatData = {}, { rollMode = null, create = true } = {}) {
		// Perform the roll, if it has not yet been rolled
		if (!this._rolled) this.roll();

		// Prepare chat data
		chatData = mergeObject(
			{
				user: game.user._id,
				type: CONST.CHAT_MESSAGE_TYPES.ROLL,
				content: this.total,
				sound: CONFIG.sounds.dice,
			},
			chatData
		);
		chatData.roll = JSON.stringify(this);

		// Handle different roll modes TODO: remove chatData.rollMode in 0.5.x
		rollMode =
			rollMode ||
			chatData.rollMode ||
			game.settings.get('core', 'rollMode');
		switch (rollMode) {
			case 'gmroll':
				chatData['whisper'] = game.users.entities
					.filter(u => u.isGM)
					.map(u => u._id);
				break;
			case 'selfroll':
				chatData['whisper'] = [game.user._id];
				break;
			case 'blindroll':
				chatData['whisper'] = game.users.entities
					.filter(u => u.isGM)
					.map(u => u._id);
				chatData['blind'] = true;
		}

		// Either create the message or just return the chat data
		return create ? ChatMessage.create(chatData) : chatData;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Alter the Roll formula by adding or multiplying the number of dice included in each roll term
	 *
	 * @param add {Number}      A number of dice to add to each Die term
	 * @param multiply {Number} A multiplier for the number of dice in each Die term
	 *
	 * @example
	 * let r = new Roll("4d8 + 4 + 2d4");
	 * r.alter(1, 2);
	 * r.formula;
	 * > 9d8 + 4 + 5d4
	 */
	alter(add, multiply) {
		let rgx = new RegExp(Roll.diceRgx, 'g');
		if (this._rolled)
			throw new Error(
				'You may not alter a Roll which has already been rolled'
			);

		// Update dice roll terms
		this.terms = this.terms.map(t => {
			return t.replace(rgx, (match, nd, d, mods) => {
				nd = nd * (multiply || 1) + (add || 0);
				mods = mods || '';
				return nd + 'd' + d + mods;
			});
		});

		// Update the formula
		this._formula = this.terms.join(' ');
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Return the minimum possible Dice roll which can result from the given formula
	 * @param {string} formula      A dice roll formula to minimize
	 * @return {Roll}               A Roll instance representing the minimal roll
	 */
	static minimize(formula) {
		const roll = new Roll(formula).roll();
		for (let d of roll.dice) {
			Object.values(d.rolls).forEach(r => (r.roll = d.sides[0]));
		}
		roll._result = roll._validateResult(
			roll.parts.map(p => (p instanceof Die ? p.total : p)).join(' ')
		);
		roll._total = null;
		return roll;
	}

	/* -------------------------------------------- */

	/**
	 * Return the maximum possible Dice roll which can result from the given formula
	 * @param {string} formula      A dice roll formula to maximize
	 * @return {Roll}               A Roll instance representing the maximal roll
	 */
	static maximize(formula) {
		const roll = new Roll(formula).roll();
		for (let d of roll.dice) {
			Object.values(d.rolls).forEach(
				r => (r.roll = d.sides[d.sides.length - 1])
			);
		}
		roll._result = roll._validateResult(
			roll.parts.map(p => (p instanceof Die ? p.total : p)).join(' ')
		);
		roll._total = null;
		return roll;
	}

	/* -------------------------------------------- */

	/**
	 * Acquire data object representing the most-likely current actor.
	 * This data can be included in the invocation of a Roll instance for evaluating dynamic attributes.
	 *
	 * @return {Object}     An object of data representing the current Actor (if any)
	 */
	static getActorData() {
		let data, actor;

		// If the user is a GM - include the data for the currently selected token
		if (game.user.isGM && canvas.ready) {
			let ct = canvas.tokens.controlled;
			if (ct.length === 1) actor = canvas.tokens.controlled.shift().actor;
		}

		// Otherwise, if the user has an impersonated character, use their own character's data
		else if (game.user.character) actor = game.user.character;

		// If no actor was identified, return an empty object
		if (!actor) return {};
		data = duplicate(actor.data.data);
		data['name'] = actor.name;
		return data;
	}

	/* -------------------------------------------- */

	static simulate(formula, n) {
		let results = [...Array(n)].reduce((arr, v) => {
			let r = new Roll(formula);
			arr.push(r.roll().total);
			return arr;
		}, []);
		let mean = results.reduce((sum, v) => (sum += v), 0) / results.length;
		console.log(`Rolled ${formula} ${n} times. Average result: ${mean}`);
		return results;
	}

	/* -------------------------------------------- */
	/*  Saving and Loading
  /* -------------------------------------------- */

	/**
	 * Structure the Roll data as an object suitable for JSON stringification
	 * @return {Object}     Structured data which can be serialized into JSON
	 */
	toJSON() {
		// Structure roll parts
		const parts = this.parts.map(p => {
			if (p instanceof Die) {
				return {
					class: p.constructor.name,
					faces: p.faces,
					rolls: p.rolls,
					formula: p.formula,
					options: p.options,
				};
			} else return p;
		});

		// Serialize roll equation
		return {
			class: this.constructor.name,
			formula: this.formula,
			parts: parts,
			total: this.total,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Recreate a Roll instance using a provided JSON string
	 * @param {String} json   Serialized JSON data representing the Roll
	 * @return {Roll}         A revived Roll instance
	 */
	static fromJSON(json) {
		const data = JSON.parse(json);
		if (data.class !== 'Roll')
			throw new Error(
				'Unable to recreate Roll instance from provided data'
			);

		// Create the instance
		let roll = new this(data.formula);

		// Update parts
		roll.parts = data.parts.map(p => {
			// Die rolls
			if (p instanceof Object && p.class) {
				let cls = CONFIG.diceTypes.find(d => d.name === p.class);
				if (!cls) throw new Error(`Unrecognized die type ${p.class}`);
				let d = new cls(p.faces, p.options);
				d.rolls = p.rolls;
				d.formula = p.formula;
				return d;
			}

			// String parts
			return p;
		});

		// Ensure we re-derived the correct total
		roll._result = roll.parts
			.map(p => (p instanceof Die ? p.total : p))
			.join(' ');
		roll._rolled = true;
		if (roll.total !== data.total)
			throw new Error(
				'The result of the recombined Roll was inconsistent.'
			);
		return roll;
	}
}

CONFIG.Roll = {
	template: 'templates/dice/roll.html',
	tooltip: 'templates/dice/tooltip.html',
	mathProxy: new Proxy(Math, {
		has: () => true,
		get: (t, k) => (k === Symbol.unscopables ? undefined : t[k]),
	}),
};

CONFIG.diceTypes = [Die, FateDie];

const MAX_INT = 4294967296.0,
	N = 624,
	M = 397,
	UPPER_MASK = 0x80000000,
	LOWER_MASK = 0x7fffffff,
	MATRIX_A = 0x9908b0df;

/**
 * A standalone, pure JavaScript implementation of the Mersenne Twister pseudo random number generator. Compatible
 * with Node.js, requirejs and browser environments. Packages are available for npm, Jam and Bower.
 *
 * @author Raphael Pigulla <pigulla@four66.com>
 * @license See the attached LICENSE file.
 * @version 0.2.3
 */
class MersenneTwister {
	/**
	 * Instantiates a new Mersenne Twister.
	 *
	 * @constructor
	 * @alias module:MersenneTwister
	 * @since 0.1.0
	 * @param {number=} seed The initial seed value.
	 */
	constructor(seed) {
		if (typeof seed === 'undefined') {
			seed = new Date().getTime();
		}
		this.mt = new Array(N);
		this.mti = N + 1;
		this.seed(seed);
	}

	/**
	 * Initializes the state vector by using one unsigned 32-bit integer "seed", which may be zero.
	 *
	 * @since 0.1.0
	 * @param {number} seed The seed value.
	 */
	seed(seed) {
		let s;

		this.mt[0] = seed >>> 0;

		for (this.mti = 1; this.mti < N; this.mti++) {
			s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
			this.mt[this.mti] =
				((((s & 0xffff0000) >>> 16) * 1812433253) << 16) +
				(s & 0x0000ffff) * 1812433253 +
				this.mti;
			this.mt[this.mti] >>>= 0;
		}
	}

	/**
	 * Initializes the state vector by using an array key[] of unsigned 32-bit integers of the specified length. If
	 * length is smaller than 624, then each array of 32-bit integers gives distinct initial state vector. This is
	 * useful if you want a larger seed space than 32-bit word.
	 *
	 * @since 0.1.0
	 * @param {array} vector The seed vector.
	 */
	seedArray(vector) {
		let i = 1,
			j = 0,
			k = N > vector.length ? N : vector.length,
			s;

		this.seed(19650218);

		for (; k > 0; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);

			this.mt[i] =
				(this.mt[i] ^
					(((((s & 0xffff0000) >>> 16) * 1664525) << 16) +
						(s & 0x0000ffff) * 1664525)) +
				vector[j] +
				j;
			this.mt[i] >>>= 0;
			i++;
			j++;
			if (i >= N) {
				this.mt[0] = this.mt[N - 1];
				i = 1;
			}
			if (j >= vector.length) {
				j = 0;
			}
		}

		for (k = N - 1; k; k--) {
			s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
			this.mt[i] =
				(this.mt[i] ^
					(((((s & 0xffff0000) >>> 16) * 1566083941) << 16) +
						(s & 0x0000ffff) * 1566083941)) -
				i;
			this.mt[i] >>>= 0;
			i++;
			if (i >= N) {
				this.mt[0] = this.mt[N - 1];
				i = 1;
			}
		}

		this.mt[0] = 0x80000000;
	}

	/**
	 * Generates a random unsigned 32-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int() {
		let y,
			kk,
			mag01 = new Array(0, MATRIX_A);

		if (this.mti >= N) {
			if (this.mti === N + 1) {
				this.seed(5489);
			}

			for (kk = 0; kk < N - M; kk++) {
				y = (this.mt[kk] & UPPER_MASK) | (this.mt[kk + 1] & LOWER_MASK);
				this.mt[kk] = this.mt[kk + M] ^ (y >>> 1) ^ mag01[y & 1];
			}

			for (; kk < N - 1; kk++) {
				y = (this.mt[kk] & UPPER_MASK) | (this.mt[kk + 1] & LOWER_MASK);
				this.mt[kk] = this.mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 1];
			}

			y = (this.mt[N - 1] & UPPER_MASK) | (this.mt[0] & LOWER_MASK);
			this.mt[N - 1] = this.mt[M - 1] ^ (y >>> 1) ^ mag01[y & 1];
			this.mti = 0;
		}

		y = this.mt[this.mti++];

		y ^= y >>> 11;
		y ^= (y << 7) & 0x9d2c5680;
		y ^= (y << 15) & 0xefc60000;
		y ^= y >>> 18;

		return y >>> 0;
	}

	/**
	 * Generates a random unsigned 31-bit integer.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	int31() {
		return this.int() >>> 1;
	}

	/**
	 * Generates a random real in the interval [0;1] with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	real() {
		return this.int() * (1.0 / (MAX_INT - 1));
	}

	/**
	 * Generates a random real in the interval ]0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	realx() {
		return (this.int() + 0.5) * (1.0 / MAX_INT);
	}

	/**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rnd() {
		return this.int() * (1.0 / MAX_INT);
	}

	/**
	 * Generates a random real in the interval [0;1[ with 32-bit resolution.
	 *
	 * Same as .rnd() method - for consistency with Math.random() interface.
	 *
	 * @since 0.2.0
	 * @returns {number}
	 */
	random() {
		return this.rnd();
	}

	/**
	 * Generates a random real in the interval [0;1[ with 53-bit resolution.
	 *
	 * @since 0.1.0
	 * @returns {number}
	 */
	rndHiRes() {
		const a = this.int() >>> 5,
			b = this.int() >>> 6;
		return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
	}
}

const twist = new MersenneTwister();

/**
 * An iterable container of Entity objects within the Foundry Virtual Tabletop framework.
 * Each Entity type has it's own subclass of Collection, which defines the abstract interface.
 * @abstract
 *
 * @param {Array} data      An Array of Entity data from which to create instances
 * @param {Array} apps      An Array of Application instances which the Collection modifies
 */
class Collection {
	constructor(data, apps) {
		/**
		 * A reference to the original source data provided by the server
		 * @type {Object}
		 * @private
		 */
		this._source = data;

		/**
		 * An Array of all the Entity instances of this type which are contained within the collection
		 * @type {Array}
		 */
		this.entities = [];

		/**
		 * An Array of application references which will be automatically updated when the collection content changes
		 * @type {Array}
		 */
		this.apps = apps || [];
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the Collection instance by preparing all of it's contained Entities
	 * @return {this}     A reference to the initialized Collection
	 */
	initialize() {
		this.entities = this._source.map(d => new this.object(d));
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Render any Applications associated with this Collection
	 * @return {this}     A reference to the rendered Collection
	 */
	render(...args) {
		for (let a of this.apps) a.render(...args);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Make the collection iterable
	 * @generator
	 */
	[Symbol.iterator]() {
		return this.entities.values();
	}

	/* -------------------------------------------- */
	/*  Collection Properties                       */
	/* -------------------------------------------- */

	/**
	 * The Collection name
	 * @type {string}
	 */
	get name() {
		return this.constructor.name;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the singleton instance of this Collection, or null if it has not yet been created.
	 * @type {Collection|null}
	 */
	static get instance() {
		return game[this.name.toLowerCase()] || null;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the SidebarDirectory application for this Collection, or null if it has not yet been created.
	 * @type {SidebarDirectory|null}
	 */
	get directory() {
		return ui[this.name.toLowerCase()] || null;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Entity subclass which should be used when creating elements of this Collection.
	 * This should always be an explicit reference to the class which is used in this game to represent the entity,
	 * and not the base implementation of that entity type. For example :class:`Actor5e` not :class:`Actor`.
	 * @abstract
	 * @type {Entity}
	 */
	get object() {
		return Entity;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the base Entity name which is contained within this Collection.
	 * @type {string}
	 */
	get entity() {
		return this.object.entity;
	}

	/* -------------------------------------------- */
	/*  Collection Management Methods               */
	/* -------------------------------------------- */

	/**
	 * Add a new Entity to the Collection, asserting that they are of the correct type.
	 * @param entity {Entity}   The entity instance to add to the collection
	 */
	insert(entity) {
		if (!(entity instanceof this.object)) {
			throw new Error(
				`You may only push instances of ${this.object.name} to the ${this.name} collection`
			);
		}

		// Is the data already in the source?
		let source_index = this._source.findIndex(e => e._id === entity._id);
		if (source_index !== -1) {
			this._source[source_index] = entity.data;
		} else {
			this._source.push(entity.data);
		}

		// Is the entity already in the collection?
		let collection_index = this.entities.findIndex(
			e => e._id === entity._id
		);
		if (collection_index !== -1) {
			this.entities[collection_index] = entity;
		} else {
			this.entities.push(entity);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Remove an Entity from the Collection by its ID.
	 * @param id {string}   The entity ID which should be removed
	 */
	remove(id) {
		const find = e => e._id === id;
		this._source.findSplice(find);
		this.entities.findSplice(find);
	}

	/* -------------------------------------------- */

	/**
	 * Get an element from the collection by ID.
	 * @param {string} id       The entity ID to retrieve from the collection
	 * @param {boolean} strict  Throw an Error if the requested id does not exist, otherwise return null. Default false.
	 * @return {Entity|null}    The retrieved Entity, if the ID was found, otherwise null;
	 */
	get(id, { strict = false } = {}) {
		const entity = this.entities.find(e => e._id === id);
		if (!entity && strict) {
			throw new Error(
				`The ${this.object.name} ${id} does not exist in the ${this.constructor.name} collection`
			);
		}
		return entity || null;
	}

	/* -------------------------------------------- */

	/**
	 * Import an Entity from a compendium collection, adding it to the current World.
	 * @param {string} collection     The name of the pack from which to import
	 * @param {string} entryId        The ID of the compendium entry to import
	 * @param {Object} [updateData]   Optional additional data used to modify the imported Entity before it is created
	 * @param {Object} [options]      Optional arguments passed to the Entity.create method
	 * @return {Promise.<Entity>}     A Promise containing the imported Entity
	 */
	async importFromCollection(
		collection,
		entryId,
		updateData = {},
		options = {}
	) {
		const entName = this.object.entity;
		const pack = game.packs.find(p => p.collection === collection);
		if (pack.metadata.entity !== entName) return;

		// Prepare the source data from which to create the Entity
		const source = await pack.getEntity(entryId);
		const createData = mergeObject(source.data, updateData);
		delete createData._id;

		// Create the Entity
		console.log(
			`${vtt} | Importing ${entName} ${source.name} from ${collection}`
		);
		this.directory.activate();
		return await this.object.create(createData, options);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Activate socket listeners related to this particular Entity type.
	 * @param {Socket} socket   The open game socket
	 */
	static socketListeners(socket) {
		let collection = this.instance;
		const name = collection.entity;

		// Define helper registration function
		const handle = (eventName, handler) => {
			socket.on(eventName, response =>
				SocketInterface.handle(response, handler, {
					postHook: eventName,
					context: collection,
				})
			);
		};
		const handleMany = (eventName, handler, postHook) => {
			socket.on(eventName, response =>
				SocketInterface.handleMany(response, handler, {
					postHook: postHook,
					context: collection,
				})
			);
		};

		// Register Entity handlers
		const operations = ['create', 'update', 'delete'];
		for (let op of operations) {
			const eventName = op + name;
			handle(eventName, collection[`_${op}Entity`]);
			handleMany(
				`${op}Many${name}`,
				collection[`_${op}ManyEntities`],
				eventName
			);
		}

		// Register Embedded Entity handlers
		const embeddedEntities = Object.keys(
			collection.object.config.embeddedEntities
		);
		for (let embeddedName of embeddedEntities) {
			for (let op of operations) {
				const eventName = op + embeddedName;
				handle(eventName, collection[`_${op}EmbeddedEntity`]);
				handleMany(
					`${op}Many${embeddedName}`,
					collection[`_${op}ManyEmbeddedEntities`],
					eventName
				);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle Entity creation workflow using the server response from the create<Entity> socket.
	 * @private
	 *
	 * @param {Object} created      The created Entity data
	 * @param {Object} options      Additional options which describe the creation request
	 * @param {string} userId       The ID of the triggering User
	 *
	 * @return {Entity}             The created Entity instance
	 */
	_createEntity({ created, options, userId }) {
		const name = this.entity;

		// Create the Entity and add it to the Collection
		const entity = new this.object(created);
		if (options.temporary) return entity;

		// Insert the created entity into the Collection
		console.log(`${vtt} | Creating new ${name} with ID ${entity._id}`);
		if (!options.temporary) this.insert(entity);
		const renderContext = {
			renderContext: 'create' + name,
			renderData: created,
			entity: entity,
		};
		this.render(false, renderContext);

		// Call entity creation steps
		entity._onCreate(created, options, userId, renderContext);
		return entity;
	}

	/* -------------------------------------------- */

	/**
	 * Handle creation of multiple Entities using data provided from a server response.
	 * @private
	 *
	 * @param {Array.<Object>} data     An Array of created Entity data
	 * @param {Object} options          Additional options which describe the creation request
	 * @param {string} userId           The ID of the triggering User
	 *
	 * @return {Array.<Entity>}         The created Entity instances
	 */
	_createManyEntities({ data, options, userId }) {
		const name = this.entity;

		// Create the Entities and add then to the parent Collection
		const entities = data.map(data => {
			let entity = new this.object(data);
			if (!options.temporary) this.insert(entity);
			entity._onCreate(data, options, userId, {
				renderContext: 'create' + name,
				renderData: data,
			});
			return entity;
		});
		if (options.temporary) return entities;

		// Render Collection update
		console.log(`${vtt} | Created ${entities.length} new ${name}s`);
		this.render(false, {
			renderContext: 'createMany' + name,
			renderData: entities,
		});
		return entities;
	}

	/* -------------------------------------------- */

	/**
	 * Handle Entity update workflow using the server response from the update<Entity> socket.
	 * @private
	 *
	 * @param {Object} updated      The updated Entity data
	 * @param {Object} options      Additional options which describe the update request
	 * @param {String} userId       The ID of the triggering User
	 *
	 * @return {Entity}             The updated Entity instance
	 */
	_updateEntity({ updated, options, userId }) {
		const name = this.entity;

		// Retrieve the entity to update
		const entity = this.get(updated._id, { strict: true });

		// Merge new data with the existing data object
		mergeObject(entity.data, updated);
		if (updated.permission && entity.data.permission)
			entity.data.permission = updated.permission;

		// Define update context
		const renderContext = {
			renderContext: 'update' + name,
			renderData: updated,
			entity: entity,
		};

		// Handle entity update steps and re-render the collection
		entity._onUpdate(updated, options, userId, renderContext);
		this.render(false, renderContext);
		return entity;
	}

	/* -------------------------------------------- */

	/**
	 * Handle updates to multiple Entities using data provided from a server response.
	 * @private
	 *
	 * @param {Array.<Object>} data     An Array of incremental Entity update data
	 * @param {Object} options          Additional options which describe the update request
	 * @param {string} userId           The ID of the triggering User
	 *
	 * @return {Array.<Entity>}         The updated Entity instances
	 */
	_updateManyEntities({ data, options, userId }) {
		const name = this.entity;

		// Structure the pending updates
		const updateIds = new Set();
		const updates = data.reduce((obj, data) => {
			updateIds.add(data._id);
			obj[data._id] = data;
			return obj;
		}, {});

		// Update data for each Entity
		const entities = [];
		for (let entity of this.entities) {
			if (!updateIds.has(entity.id)) continue;
			const update = updates[entity.id];
			mergeObject(entity.data, update);
			if (update.permission && entity.data.permission)
				entity.data.permission = update.permission;
			entity._onUpdate(update, options, userId, {
				renderContext: 'update' + name,
				renderData: update,
			});
			entities.push(entity);
		}

		// Render Collection update
		this.render(false, {
			renderContext: 'updateMany' + name,
			renderData: data,
		});
		return entities;
	}

	/* -------------------------------------------- */

	/**
	 * Handle Entity deletion workflow using the server response from the delete<Entity> socket.
	 * @private
	 *
	 * @param {String} deleted      The ID of the deleted Entity
	 * @param {Object} options      Additional options which describe the deletion request
	 * @param {String} userId       The ID of the triggering User
	 *
	 * @return {Entity}             The deleted Entity instance
	 * */
	_deleteEntity({ deleted, options, userId }) {
		const name = this.entity;

		// Remove the entity from it's collection
		const entity = this.get(deleted, { strict: true });
		console.log(`${vtt} | Deleting ${name} with ID ${entity._id}`);
		this.remove(deleted);

		// Call entity deletion steps
		const renderContext = {
			renderContext: 'delete' + name,
			renderData: deleted,
			entity: entity,
		};
		entity._onDelete(deleted, options, userId, renderContext);

		// Render Collection update
		this.render(false, renderContext);
		return entity;
	}

	/* -------------------------------------------- */

	/**
	 * Handle deletion of multiple Entities using an Array of ids provided from a server response.
	 * @private
	 *
	 * @param {Array.<string>} data     An Array of Entity ids to delete
	 * @param {Object} options          Additional options which describe the deletion request
	 * @param {string} userId           The ID of the triggering User
	 *
	 * @return {Array.<Entity>}         The deleted Entity instances
	 */
	_deleteManyEntities({ data, options, userId }) {
		const name = this.entity;

		// Record the IDs to delete
		const toDelete = new Set(
			options.deleteAll ? this._source.map(e => e._id) : data
		);

		// Delete each entity in the target set
		const entities = [];
		this.entities = this.entities.filter(e => {
			if (toDelete.has(e._id)) {
				e._onDelete(e._id, options, userId, {
					renderContext: 'delete' + name,
					renderData: e._id,
				});
				entities.push(e);
				return false;
			}
			return true;
		});

		// Filter the source data
		for (let id of toDelete) {
			this._source.findSplice(s => s._id === id);
		}
		console.log(`${vtt} | Deleted ${data.length} ${name}s`);

		// Render Collection update
		this.render(false, {
			renderContext: 'deleteMany' + name,
			renderData: data,
		});
		return entities;
	}

	/* -------------------------------------------- */

	/**
	 * Handle the creation of a new Embedded Entity within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {Object} created      The created Embedded Entity data
	 * @param {Object} options      Additional options which modify the creation request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Object}             The created Embedded Entity data
	 */
	_createEmbeddedEntity({ parentId, created, options, userId }) {
		if (options.temporary) return created;

		// Get the parent entity and the child collection
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;
		const collection = parent.getEmbeddedCollection(embeddedName);

		// Push the created data into the child collection
		collection.push(created);
		console.log(
			`${vtt} | Created ${options.embeddedName} ${created._id} in ${this.object.name} ${parentId}`
		);

		// Call Entity child creation steps and return the created child
		parent._onCreateEmbeddedEntity({
			embeddedName,
			created,
			options,
			userId,
		});
		const renderContext = {
			renderContext: `create${embeddedName}`,
			renderData: created,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return created;
	}

	/* -------------------------------------------- */

	/**
	 * Handle creation of multiple Embedded Entities within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {Array} data          An Array of created Embedded Entity data
	 * @param {Object} options      Additional options which modify the creation request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Array}              The created Embedded Entity Array
	 */
	_createManyEmbeddedEntities({ parentId, data, options, userId }) {
		if (options.temporary) return data;

		// Get the parent entity and current collection
		const cls = this.object;
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;
		const collectionName = cls.config.embeddedEntities[embeddedName];

		// Add new entities to the collection
		parent.data[collectionName] = parent.data[collectionName].concat(data);
		console.log(
			`${vtt} | Created ${data.length} new ${embeddedName}s in ${cls.name} ${parentId}`
		);

		// Call Embedded Entity creation steps
		data.forEach(child =>
			parent._onCreateEmbeddedEntity({
				embeddedName,
				created: child,
				options,
				userId,
			})
		);
		const renderContext = {
			renderContext: `createMany${embeddedName}s`,
			renderData: data,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Handle updates to an Embedded Entity within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {Object} data         The updated Embedded Entity data
	 * @param {Object} options      Additional options which modify the update request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Object}             The updated Embedded Entity data
	 */
	_updateEmbeddedEntity({ parentId, data, options, userId }) {
		// Get the parent entity and current child
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;
		let child = parent.getEmbeddedEntity(embeddedName, data._id, {
			strict: true,
		});

		// Update the child data
		mergeObject(child, data);

		// Call Embedded Entity update steps
		parent._onUpdateEmbeddedEntity({ embeddedName, data, options, userId });
		const renderContext = {
			renderContext: `update${embeddedName}`,
			renderData: data,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return child;
	}

	/* -------------------------------------------- */

	/**
	 * Handle updates to a multiple Embedded Entities within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {Array} data          An Array of embedded entity data updates
	 * @param {Object} options      Additional options which modify the update request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Array}              The updated Embedded Entity Array
	 */
	_updateManyEmbeddedEntities({ parentId, data, options, userId }) {
		// Get the parent entity and the child collection
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;
		const collection = parent.getEmbeddedCollection(embeddedName);

		// Structure the pending updates
		const updateIds = new Set();
		const updates = data.reduce((obj, u) => {
			updateIds.add(u._id);
			obj[u._id] = u;
			return obj;
		}, {});

		// Update the data for each child
		for (let child of collection) {
			if (!updateIds.has(child._id)) continue;
			mergeObject(child, updates[child._id]);
		}

		// Call Embedded Entity update steps
		data.forEach(child =>
			parent._onUpdateEmbeddedEntity({
				embeddedName,
				data: child,
				options,
				userId,
			})
		);
		const renderContext = {
			renderContext: `updateMany${embeddedName}s`,
			renderData: data,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Handle deletion of an Embedded Entity within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {string} deleted      The Embedded Entity id to delete from the parent
	 * @param {Object} options      Additional options which modify the deletion request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Object}             The deleted Embedded Entity data
	 */
	_deleteEmbeddedEntity({ parentId, deleted, options, userId }) {
		// Get the parent entity
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;

		// Remove the current child
		const child = parent.removeEmbeddedEntity(embeddedName, deleted);
		console.log(
			`${vtt} | Deleted ${options.embeddedName} ${deleted} in ${this.object.name} ${parentId}`
		);

		// Call Embedded Entity deletion steps
		parent._onDeleteEmbeddedEntity({
			embeddedName,
			deleted: child,
			options,
			userId,
		});
		const renderContext = {
			renderContext: `delete${embeddedName}`,
			renderData: child,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return child;
	}

	/* -------------------------------------------- */

	/**
	 * Handle deletion of multiple Embedded Entities within a parent Entity in response to server-side socket broadcast.
	 * @private
	 *
	 * @param {string} parentId     The parent Entity ID
	 * @param {Array} data          An Array of Embedded Entity ids to delete
	 * @param {Object} options      Additional options which modify the update request
	 * @param {string} userId       The id of the requesting user
	 *
	 * @return {Array}              The deleted Embedded Entity Array
	 */
	_deleteManyEmbeddedEntities({ parentId, data, options, userId }) {
		// Get the parent entity and current collection
		const cls = this.object;
		const parent = this.get(parentId, { strict: true });
		const embeddedName = options.embeddedName;
		const collectionName = cls.config.embeddedEntities[embeddedName];

		// Remove deleted IDs from the collection
		const toDelete = new Set(data);
		const [kept, deleted] = parent.data[collectionName].partition(c =>
			toDelete.has(c._id)
		);
		parent.data[collectionName] = kept;
		console.log(
			`${vtt} | Deleted ${deleted.length} ${embeddedName}s from ${cls.name} ${parentId}`
		);

		// Call Embedded Entity deletion steps
		deleted.forEach(child =>
			parent._onDeleteEmbeddedEntity({
				embeddedName,
				deleted: child,
				options,
				userId,
			})
		);
		const renderContext = {
			renderContext: `deleteMany${embeddedName}s`,
			renderData: data,
		};
		parent._onModifyEmbeddedEntity({ embeddedName, renderContext });
		return deleted;
	}
}

/**
 * The Compendium class provides an interface for interacting with compendium packs which are
 * collections of similar Entities which are stored outside of the world database but able to
 * be easily imported into an active session.
 *
 * When the game session is initialized, each available compendium pack is constructed and
 * added to the ``game.packs``.
 *
 * Each Compendium is distinctly referenced using its canonical "collection" name which is a
 * unique string that contains the package name which provides the compendium as well as the
 * name of the pack within that package. For example, in the D&D5e system, the compendium pack
 * which provides the spells available within the SRD has the collection name "dnd5e.spells".
 *
 * @type {Application}
 *
 * @param metadata {Object}   The compendium metadata, an object provided by game.data
 * @param options {Object}    Application rendering options
 *
 * @example
 * // Let's learn the collection names of all the compendium packs available within a game
 * game.packs.map(p => p.collection);
 *
 * // Suppose we are working with a particular pack named "dnd5e.spells"
 * const pack = game.packs.find(p => p.collection === "dnd5e.spells");
 *
 * // We can load the index of the pack which contains all entity IDs, names, and image icons
 * pack.getIndex().then(index => console.log(index));
 *
 * // We can find a specific entry in the compendium by its name
 * let entry = pack.index.find(e => e.name === "Acid Splash");
 *
 * // Given the entity ID of "Acid Splash" we can load the full Entity from the compendium
 * pack.getEntity(entry.id).then(spell => console.log(spell));
 *
 * @example
 * // We often may want to programmatically create new Compendium content
 * // Let's start by creating a custom spell as an Item instance
 * let itemData = {name: "Custom Death Ray", type: "Spell"};
 * let item = new Item(itemData);
 *
 * // Once we have an entity for our new Compendium entry we can import it, if the pack is unlocked
 * pack.importEntity(item);
 *
 * // When the entity is imported into the compendium it will be assigned a new ID, so let's find it
 * pack.getIndex().then(index => {
 *   let entry = index.find(e => e.name === itemData.name));
 *   console.log(entry);
 * });
 *
 * // If we decide to remove an entry from the compendium we can do that by the entry ID
 * pack.removeEntry(entry.id);
 */
class Compendium extends Application {
	constructor(metadata, options) {
		super(options);

		/**
		 * The compendium metadata which defines the compendium content and location
		 * @type {Object}
		 */
		this.metadata = metadata;

		/**
		 * Track whether the compendium pack is publicly visible
		 * @type {Boolean}
		 */
		this.public = true;

		/**
		 * The most recently retrieved index of the Compendium content
		 * This index is not guaranteed to be current - call getIndex() to reload the index
		 * @type {Array}
		 */
		this.index = [];

		// Internal flags
		this.searchString = null;
		this._searchTime = 0;
		this._scrollTop = 0;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the Compendium UI
	 * @private
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.template = 'templates/apps/compendium.html';
		options.width = 350;
		options.height = window.innerHeight - 100;
		options.top = 70;
		options.left = 120;
		return options;
	}

	/* ----------------------------------------- */

	/**
	 * The Compendium title
	 * @private
	 * @type {String}
	 */
	get title() {
		return this.metadata.label;
	}

	/* ----------------------------------------- */

	/**
	 * The canonical Compendium name - comprised of the originating package and the pack name
	 * @return {string}     The canonical collection name
	 */
	get collection() {
		return `${this.metadata.package}.${this.metadata.name}`;
	}

	/* ----------------------------------------- */

	/**
	 * The Entity type which is allowed to be stored in this collection
	 * @type {String}
	 */
	get entity() {
		return this.metadata.entity;
	}

	/* ----------------------------------------- */

	/**
	 * Return the Compendium index as the data for rendering
	 * First query the server to obtain the index and then return it once prepared
	 * @return {Promise.Object}     The data to render
	 */
	async getData() {
		await this.getIndex();
		return {
			collection: this.collection,
			searchString: this.searchString,
			cssClass: this.entity.toLowerCase(),
			index: this.index.map(i => {
				i.img = i.img || CONST.DEFAULT_TOKEN;
				return i;
			}),
		};
	}

	/* ----------------------------------------- */

	/**
	 * Override the default :class:`Application` rendering logic to wrap the render call in a promise which
	 * retrieves the compendium data.
	 */
	async _render(...args) {
		const ol = this._rendered ? this.element.find('.directory-list') : null;
		const scroll = ol ? ol[0].scrollTop : 0;
		await super._render(...args);
		if (this._rendered) {
			if (this.searchString) this._onSearch(this.searchString);
			this.element.find('.directory-list')[0].scrollTop = scroll;
		}
	}

	/* ----------------------------------------- */
	/*  Methods
  /* ----------------------------------------- */

	/**
	 * Create a new Compendium pack using provided
	 * @param {Object} metadata   The compendium metadata used to create the new pack
	 * @return {Promise.<Compendium>}
	 */
	static create(metadata) {
		if (!game.user.isGM)
			throw new Error('You may not create a Compendium pack');
		return SocketInterface.trigger(
			'createCompendiumPack',
			{ metadata },
			{},
			{
				context: this,
				success: response => {
					let pack = new Compendium(response.metadata);
					game.packs.push(pack);
					ui.compendium.render();
					return pack;
				},
			}
		);
	}

	/* ----------------------------------------- */

	/**
	 * Delete a world Compendium pack
	 * This is only allowed for world-level packs by a GM user
	 * @return {Promise.<Compendium>}
	 */
	async delete() {
		if (!game.user.isGM)
			throw new Error('You may not delete a Compendium pack');
		const eventData = { packName: this.metadata.name };
		return SocketInterface.trigger(
			'deleteCompendiumPack',
			eventData,
			{},
			{
				preHook: 'preDeleteCompendiumPack',
				context: this,
				success: response => {
					const idx = game.packs.findIndex(
						p => p.collection === this.collection
					);
					if (idx !== -1) game.packs.splice(idx, 1);
					ui.compendium.render();
					return this;
				},
			}
		);
	}

	/* ----------------------------------------- */

	/**
	 * Get the Compendium index
	 * Contains names and IDs of all data in the compendium
	 *
	 * @return {Promise}    A Promise containing an index of all compendium entries
	 */
	getIndex() {
		return new Promise((resolve, reject) => {
			game.socket.emit('getCompendiumIndex', this.collection, resolve);
		}).then(index => (this.index = index));
	}

	/* ----------------------------------------- */

	/**
	 * Get the complete set of content for this compendium, loading all entries in full
	 * Returns a Promise that resolves to an Array of entries
	 *
	 * @return {Promise.<Array>}
	 */
	async getContent() {
		return new Promise(resolve => {
			game.socket.emit(
				'getCompendiumContent',
				this.collection,
				entries => {
					resolve(entries.map(e => this._toEntity(e)));
				}
			);
		});
	}

	/* ----------------------------------------- */

	/**
	 * Get a single Compendium entry as an Object
	 * @param entryId {String}  The compendium entry ID to retrieve
	 *
	 * @return {Promise}        A Promise containing the return entry data, or undefined
	 */
	getEntry(entryId) {
		return new Promise((resolve, reject) => {
			game.socket.emit(
				'getCompendiumEntry',
				this.collection,
				entryId,
				resolve
			);
		});
	}

	/* ----------------------------------------- */

	/**
	 * Get a single Compendium entry as an Entity instance
	 * @param entryId {String}    The compendium entry ID to instantiate
	 *
	 * @return {Promise}          A Promise containing the returned Entity
	 */
	getEntity(entryId) {
		return this.getEntry(entryId).then(entryData =>
			this._toEntity(entryData)
		);
	}

	/* ----------------------------------------- */

	/**
	 * Cast entry data to an Entity class
	 * @param {Object} entryData
	 * @private
	 */
	_toEntity(entryData) {
		const cls = CONFIG[this.entity].entityClass;
		return new cls(entryData, { compendium: this });
	}

	/* ----------------------------------------- */

	/**
	 * Import a new Entity into a Compendium pack
	 * @param {Entity} entity     The Entity instance you wish to import
	 * @return {Promise}          A Promise which resolves to the created Entity once the operation is complete
	 */
	importEntity(entity) {
		if (entity.entity !== this.entity) {
			let err =
				'You are attempting to import the wrong type of entity into this pack';
			ui.notifications.error(err);
			throw new Error(err);
		}
		return this.createEntity(entity.data);
	}

	/* -------------------------------------------- */

	/**
	 * Create a new Entity within this Compendium Pack using provided data
	 * @param {Object} data       Data with which to create the entry
	 * @return {Promise}          A Promise which resolves to the created Entity once the operation is complete
	 */
	createEntity(data) {
		const eventData = { packName: this.collection, data: data };
		return SocketInterface.trigger(
			'createCompendiumEntry',
			eventData,
			{},
			{
				preHook: 'preCreateCompendiumEntry',
				context: this,
				success: response => {
					this.render();
					return this._toEntity(response.created);
				},
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Update a single Compendium entry programmatically by providing new data with which to update
	 * @param {Object} data       The incremental update with which to update the Entity. Must contain the _id
	 * @param {Object} options    Additional options which modify the update request
	 * @return {Promise}          A Promise which resolves with the updated Entity once the operation is complete
	 */
	updateEntity(data, options = {}) {
		if (!data._id)
			throw new Error(
				'You must specify the _id attribute for the data you wish to update'
			);
		const eventData = { packName: this.collection, data: data };
		return SocketInterface.trigger(
			'updateCompendiumEntry',
			eventData,
			options,
			{
				preHook: 'preUpdateCompendiumEntry',
				context: this,
				success: response => {
					this.render(false);
					return this.getEntity(data._id);
				},
			}
		);
	}

	/* ----------------------------------------- */

	/**
	 * Delete a single Compendium entry by its provided _id
	 * @param {String} id         The entry ID to delete
	 * @return {Promise}          A Promise which resolves to the deleted entry ID once the operation is complete
	 */
	deleteEntity(id) {
		const eventData = { packName: this.collection, id: id };
		return SocketInterface.trigger(
			'deleteCompendiumEntry',
			eventData,
			{},
			{
				preHook: 'preDeleteCompendiumEntry',
				context: this,
				success: response => {
					this.render(false);
					return response.deleted;
				},
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Request that a Compendium pack be migrated to the latest System data template
	 * @return {Promise.<Compendium>}
	 */
	migrate(options) {
		if (!game.user.isGM)
			throw new Error('You may not migrate a Compendium pack');
		ui.notifications.info(
			`Beginning migration for Compendium pack ${this.collection}, please be patient.`
		);
		return SocketInterface.trigger(
			'migrateCompendiumPack',
			{ packName: this.collection },
			options,
			{
				success: response => {
					ui.notifications.info(
						`Successfully migrated Compendium pack ${this.collection}.`
					);
				},
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Customize Compendium closing behavior to toggle the sidebar folder status icon
	 */
	close() {
		super.close();
		let li = $(`.compendium-pack[data-pack="${this.collection}"]`);
		li.attr('data-open', '0');
		li.find('i.folder')
			.removeClass('fa-folder-open')
			.addClass('fa-folder');
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Register event listeners for Compendium directories
	 * @private
	 */
	activateListeners(html) {
		// Search filtering
		html.find('input[name="search"]').keyup(ev => {
			let input = ev.currentTarget;
			this._searchTime = new Date();
			setTimeout(() => {
				if (new Date() - this._searchTime > 250)
					this._onSearch(input.value);
			}, 251);
		});

		// Open sheets
		html.find('.entry-name').click(ev => {
			let li = ev.currentTarget.parentElement;
			this._onEntry(li.getAttribute('data-entry-id'));
		});

		// Make compendium entries draggable
		if (game.user.isGM || this.entity === 'Item') {
			html.find('.directory-item').each((i, li) => {
				li.setAttribute('draggable', true);
				li.addEventListener('dragstart', this._onDragStart, false);
			});
		}

		// GM only actions below here
		if (!game.user.isGM) return;

		// Make the compendium droppable
		html[0].ondragover = this._onDragOver;
		html[0].ondrop = this._onDrop;

		// Context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Handle compendium filtering through search field
	 * Toggle the visibility of indexed compendium entries by name (for now) match
	 * @private
	 */
	_onSearch(searchString) {
		let rgx = new RegExp(searchString, 'i');
		this.element.find('li.directory-item').each((i, el) => {
			let name = el.getElementsByClassName('entry-name')[0].textContent;
			el.style.display = name.match(rgx) ? 'flex' : 'none';
		});
		this.searchString = searchString;
	}

	/* -------------------------------------------- */

	/**
	 * Handle opening a single compendium entry by invoking the configured entity class and its sheet
	 * @private
	 */
	async _onEntry(entryId) {
		const entity = await this.getEntity(entryId);
		entity.sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a new drag event from the compendium, create a placeholder token for dropping the item
	 * @private
	 */
	_onDragStart(event) {
		const li = this,
			packName = li.parentElement.parentElement.getAttribute('data-pack'),
			pack = game.packs.find(p => p.collection === packName);

		// Get the pack
		if (!pack) {
			event.preventDefault();
			return false;
		}

		// Set the transfer data
		event.dataTransfer.setData(
			'text/plain',
			JSON.stringify({
				type: pack.entity,
				pack: pack.collection,
				id: li.getAttribute('data-entry-id'),
			})
		);
	}

	/* -------------------------------------------- */

	/**
	 * Allow data transfer events to be dragged over this as a drop zone
	 * @private
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle data being dropped into a Compendium pack
	 * @private
	 */
	async _onDrop(event) {
		event.preventDefault();
		const packName = this.getAttribute('data-pack'),
			pack = game.packs.find(p => p.collection === packName);

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}

		// Ensure an entity type was indicated
		if (!data.type)
			throw new Error(
				'You must define the type of entity data being dropped'
			);
		const cls = CONFIG[data.type].entityClass;
		let ent = null;

		// Case 1 - Data explicitly provided
		if (data.data) ent = new cls(data.data);
		// Case 2 - Import from other Compendium
		else if (data.pack) {
			if (data.pack === packName) return false;
			const source = game.packs.find(p => p.collection === data.pack);
			ent = await source.getEntity(data.id);
		}

		// Case 3 - Import from World data
		else ent = cls.collection.get(data.id);

		// Create the new Compendium entry
		pack.importEntity(ent);
	}

	/* -------------------------------------------- */

	/**
	 * Render the ContextMenu which applies to each compendium entry
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, '.directory-item', [
			{
				name: 'Import',
				icon: '<i class="fas fa-download"></i>',
				callback: li => {
					let entryId = li.attr('data-entry-id');
					let entities = CONFIG[this.entity].entityClass.collection;
					entities.importFromCollection(this.collection, entryId);
				},
			},
			{
				name: 'Delete',
				icon: '<i class="fas fa-trash"></i>',
				callback: li => {
					let entryId = li.attr('data-entry-id');
					this.getEntity(entryId).then(entry => {
						new Dialog({
							title: `Delete ${entry.name}`,
							content:
								'<h3>Are you sure?</h3>' +
								'<p>This compendium entry and its data will be deleted.</p>' +
								'<p>If you do not own this compendium, your change could be reverted by future updates.</p>',
							buttons: {
								yes: {
									icon: '<i class="fas fa-trash"></i>',
									label: 'Delete',
									callback: () => this.deleteEntity(entryId),
								},
								no: {
									icon: '<i class="fas fa-times"></i>',
									label: 'Cancel',
								},
							},
							default: 'yes',
						}).render(true);
					});
				},
			},
		]);
	}
}

/**
 * An abstract class pattern for all primary data entities within the Foundry VTT Framework. An entity represents a
 * primary data concept, for example: Actor, Item, Scene, or ChatMessage. Each Entity type in Foundry Virtual
 * Tabletop extends this base Entity class which ensures similar behavior and workflow across all entity types.
 *
 * Documentation for this class is provided for reference, but developers should not extend this class directly,
 * instead work with or extend the Entity implementations that are referenced in this section of the API documentation.
 *
 * Entities are instantiated by providing their base data, and an optional Array of Application instances which should
 * be automatically refreshed when the Entity experiences an update.
 * @abstract
 *
 * @see {@link Collection} The Collection abstract class which contains Entity instances.
 * @see {@link Actor} The Actor Entity.
 * @see {@link Combat} The Combat Encounter Entity.
 * @see {@link Folder} The Folder Entity.
 * @see {@link Item} The Item Entity.
 * @see {@link JournalEntry} The Journal Entry Entity.
 * @see {@link ChatMessage} The Chat Message Entity.
 * @see {@link Playlist} The Audio Playlist Entity.
 * @see {@link Scene} The Scene Entity.
 * @see {@link RollTable} The Rollable Table Entity.
 * @see {@link User} The User Entity.
 * @see {@link Compendium} The Compendium which may contain Entities in a compendium pack.
 *
 * @param {Object} data       The data Object with which to create the Entity
 * @param {Object} options    Additional options which modify the created Entity behavior
 * @param {Compendium} [options.compendium] A reference to the Compendium pack from which this Entity was drawn.
 *
 * @example
 * let actorData = {name: "John Doe", type: "character", img: "icons/mystery-man.png"};
 * let actor = new Actor(actorData);
 */
class Entity {
	constructor(data, options) {
		/**
		 * The original source data for the object provided at initialization.
		 * @type {Object}
		 */
		this.data = data || {};

		/**
		 * The options object that was used to configure the Entity upon initialization.
		 * @type {Object}
		 */
		this.options = options || {};

		/**
		 * A collection of Application instances which should be re-rendered whenever this Entity experiences an update to
		 * its data. The keys of this object are the application ids and the values are Application instances. Each
		 * Application in this object will have its render method called by @{link Entity#render}.
		 * @type {Object.<Application>}
		 * @see {Entity#render}
		 */
		this.apps = {};

		/**
		 * The Entity may optionally the belong to a parent Compendium pack. If so this attribute will contain a reference
		 * to that Compendium object. Otherwise null.
		 * @type {Compendium|null}
		 */
		this.compendium = this.options.compendium || null;

		// Initialize Entity data
		this.initialize();
	}

	/* -------------------------------------------- */

	/**
	 * Configure the attributes of this Entity class
	 * @type {Object}
	 * @property {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @property {Collection} collection   The Collection instance to which Entities of this type belong.
	 * @property {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		throw new Error(
			`The ${this.name} subclass must define the Entity.config object`
		);
	}

	/* -------------------------------------------- */

	/**
	 * Initialize data structure for the Entity.
	 * First initialize any Embedded Entities and prepare their data.
	 * Next prepare data for the Entity itself, which may depend on Embedded Entities.
	 */
	initialize() {
		try {
			this.prepareData(); // TODO - I should try and improve this, but chicken-egg problem for now
			this.prepareEmbeddedEntities();
			this.prepareData();
		} catch (err) {
			console.error(
				`Failed to initialize data for ${this.constructor.name} ${this.id}:`
			);
			console.error(err);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Prepare data for the Entity whenever the instance is first created or later updated.
	 * This method can be used to derive any internal attributes which are computed in a formulaic manner.
	 * For example, in a d20 system - computing an ability modifier based on the value of that ability score.
	 */
	prepareData() {
		const data = this.data;
		if (data.hasOwnProperty('name') && !data.name) {
			data.name = 'New ' + this.entity;
		}
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare Embedded Entities which exist within this parent Entity.
	 * For example, in the case of an Actor, this method is responsible for preparing the Owned Items the Actor contains.
	 */
	prepareEmbeddedEntities() {
		for (let [name, collection] of Object.entries(
			this.constructor.config.embeddedEntities
		)) {
			this[collection] = this.data[collection].map(d =>
				this._constructEmbeddedEntity(name, d)
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Prepare data for a single Embedded Entity which exists within the parent Entity.
	 * @private
	 * @param {string} embeddedName   The name of the Embedded Entity type
	 * @param {Object} data           The data used to initialize it
	 * @returns                       The Embedded Entity object
	 */
	_constructEmbeddedEntity(embeddedName, data) {
		throw new Error(
			`The ${this.constructor.name} subclass must define the _constructEmbeddedEntity() method`
		);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the Array of source data within the data object for a certain Embedded Entity name
	 * @param {string} embeddedName   The name of the Embedded Entity type
	 * @return {Array}                The Array of source data where Embedded Entities of this type are stored
	 */
	getEmbeddedCollection(embeddedName) {
		const collection = this.constructor.config.embeddedEntities[
			embeddedName
		];
		if (!collection) {
			throw new Error(
				`${embeddedName} is not a valid Embedded Entity in a ${this.constructor.name}`
			);
		}
		return this.data[collection];
	}

	/* -------------------------------------------- */
	/*  Properties
	/* -------------------------------------------- */

	/**
	 * Return a reference to the Collection instance which stores Entity instances of this type. This property is
	 * available as both a static and instance method and should be overridden by subclass Entity implementations.
	 * @type {Collection}
	 * @static
	 */
	static get collection() {
		if (!this.config.collection)
			throw new Error(
				`An Entity subclass must configure the Collection it belongs to.`
			);
		return this.config.collection;
	}

	/* -------------------------------------------- */

	/** @alias {Entity.collection} */
	get collection() {
		return this.constructor.collection;
	}

	/* -------------------------------------------- */

	/**
	 * The class name of the base Entity type, for example "Actor". This is useful in cases where there is an inheritance
	 * chain. Many places throughout the framework rely upon the canonical entity name which may not always be equal
	 * to the class name. This property is available as both a static and instance method.
	 * @type {string}
	 *
	 * @example
	 * class Actor2ndGen extends Actor {...}
	 * Actor2ndGen.entity // "Actor"
	 */
	static get entity() {
		if (!this.config.baseEntity)
			throw new Error(
				`An Entity subclass must configure the baseEntity it represents.`
			);
		return this.config.baseEntity.name;
	}

	/* -------------------------------------------- */

	/** @alias {Entity.entity} */
	get entity() {
		return this.constructor.entity;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the _id attribute of the Entity data object.
	 * @type {string}
	 */
	get id() {
		return this.data._id;
	}

	/* -------------------------------------------- */

	/** @alias {Entity#id} */
	get _id() {
		return this.data._id;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the name attribute of the Entity data object
	 * @type {string}
	 */
	get name() {
		return this.data.name;
	}

	/* -------------------------------------------- */

	/**
	 * A property which gets or creates a singleton instance of the sheet class used to render and edit data for this
	 * particular entity type.
	 * @type {BaseEntitySheet}
	 *
	 * @example <caption>A subclass of the Actor entity</caption>
	 * let actor = game.entities.actors[0];
	 * actor.sheet; // ActorSheet
	 */
	get sheet() {
		const cls = this._sheetClass;
		if (!cls) return null;
		let sheet = Object.values(this.apps).find(
			app => app.constructor === cls
		);
		if (!sheet) sheet = new cls(this, { editable: this.owner });
		return sheet;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the BaseEntitySheet implementation which should be used to render the Entity instance
	 * configuration sheet.
	 * @private
	 */
	get _sheetClass() {
		const cfg = CONFIG[this.entity];
		let cls = null;
		if (!cfg) return null;

		// Case 1 - Dynamic Sheet Classes are supported
		if (cfg.sheetClasses) {
			const type = this.data.type || CONST.BASE_ENTITY_TYPE;
			const sheets = cfg.sheetClasses[type] || {};
			const override = this.getFlag('core', 'sheetClass');
			if (sheets[override]) cls = sheets[override].cls;
			else {
				let classes = Object.values(sheets);
				let def = classes.find(s => s.default) || classes.pop();
				if (def) cls = def.cls;
			}
			if (!cls)
				throw new Error(
					`No valid ${this.entity} sheet found for type ${type}`
				);
		}

		// Case 2 - Static sheets only
		else cls = cfg.sheetClass;
		return cls;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Folder which this Entity belongs to, if any.
	 * @type {Folder|null}
	 *
	 * @example <caption>Entities may belong to Folders</caption>
	 * let folder = game.folders.entities[0];
	 * let actor = await Actor.create({name: "New Actor", folder: folder.id});
	 * console.log(actor.data.folder); // folder.id;
	 * console.log(actor.folder); // folder;
	 */
	get folder() {
		if (!this.data.folder) return null;
		return game.folders.get(this.data.folder);
	}

	/* -------------------------------------------- */

	/**
	 * Return the permission level that the current game User has over this Entity.
	 * See the CONST.ENTITY_PERMISSIONS object for an enumeration of these levels.
	 * @type {Number}
	 *
	 * @example
	 * game.user.id; // "dkasjkkj23kjf"
	 * entity.data.permission; // {default: 1, "dkasjkkj23kjf": 2};
	 * entity.permission; // 2
	 */
	get permission() {
		// Game-masters and Assistants are always owners
		if (game.user.isGM) return CONST.ENTITY_PERMISSIONS.OWNER;

		// User-specific permission
		let userPerm = this.data.permission[game.user._id];
		return userPerm ? userPerm : this.data.permission['default'];
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the current game User has ownership rights for this Entity.
	 * This property has a setter which allows for ownership rights to be temporarily overridden on a per-instance basis.
	 * @type {boolean}
	 */
	get owner() {
		return !this.compendium && this.hasPerm(game.user, 'OWNER');
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the current game User has at least limited visibility for this Entity.
	 * @type {boolean}
	 */
	get visible() {
		return this.hasPerm(game.user, 'LIMITED', false);
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether the current game user has ONLY limited visibility for this Entity.
	 * Note that a GM user's perspective of an Entity is never limited.
	 * @type {boolean}
	 */
	get limited() {
		if (game.user.isGM) return false;
		return this.hasPerm(game.user, 'LIMITED', true);
	}

	/* -------------------------------------------- */
	/* Methods
	/* -------------------------------------------- */

	/**
	 * Render all of the Application instances which are connected to this Entity by calling their respective
	 * {@link Application#render} methods.
	 * @param {...*} args      Variable arguments which are forwarded to each Application's render call
	 */
	render(...args) {
		for (let app of Object.values(this.apps)) {
			app.render(...args);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a provided User a specific permission level (or greater) over the Entity instance
	 * @param {User} user                   The user to test for permission
	 * @param {string|number} permission    The permission level or level name to test
	 * @param {boolean} exact               Tests for an exact permission level match, by default this method tests for
	 *                                      an equal or greater permission level.
	 * @return {boolean}                    Whether or not the user has the permission for this Entity.
	 *
	 * @example <caption>Test whether a specific user has a certain permission</caption>
	 * // These two are equivalent
	 * entity.hasPerm(game.user, "OWNER");
	 * entity.owner;
	 * // These two are also equivalent
	 * entity.hasPerm(game.user, "LIMITED", true);
	 * entity.limited;
	 */
	hasPerm(user, permission, exact = false) {
		// Get the user's permission level
		let level = this.data.permission[user._id];
		level = Number.isInteger(level)
			? level
			: this.data.permission['default'];
		const perm = CONST.ENTITY_PERMISSIONS[permission];

		// Test permission against the target level
		if (exact) return level === perm;
		else if (user.isGM) return true;
		return level >= perm;
	}

	/* -------------------------------------------- */
	/*  Entity Management Methods                   */
	/* -------------------------------------------- */

	/**
	 * Create a new entity using provided input data
	 * The data for entity creation is typically provided from the server through the 'create<Entity>' socket
	 * Alternatively, the creation event may originate locally and the new entity can be pushed back to the server.
	 * @static
	 *
	 * @param {Object} data         The data with which to create the entity
	 * @param {Object} options      Additional options which customize the creation workflow
	 * @param {Boolean} options.temporary     Create a temporary entity which is not saved to the world database.
	 *                                        Default is false.
	 * @param {Boolean} options.displaySheet  Show the configuration sheet for the created entity once it is created.
	 *                                        Default is true.
	 *
	 * @return {Promise}            A Promise which resolves to contain the created Entity
	 *
	 * @example
	 * const createData = {name: "New Entity", img: "path/to/profile.jpg"};
	 * const created = await Entity.create(createData); // Saved to the database
	 * const temp = await Entity.create(createData, {temporary: true}); // Not saved to the database
	 */
	static async create(data, options = {}) {
		const collection = this.collection;
		const name = this.entity;
		options = mergeObject(
			{ temporary: false, displaySheet: true },
			options
		);
		return SocketInterface.trigger('create' + name, { data }, options, {
			preHook: 'preCreate' + name,
			context: collection,
			success: collection._createEntity,
			postHook: 'create' + name,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create multiple new Entities using provided input data Array, containing one Object per created Entity.
	 * @static
	 *
	 * @param {Array.<Object>} data           The data with which to create the entity
	 * @param {Object} options                Additional options which customize the creation workflow
	 * @param {Boolean} options.temporary     Created entities are temporary and not saved to the database. Default false.
	 * @param {Boolean} options.displaySheet  Display sheets of the created entities. Default false.
	 *
	 * @return {Promise}                      A Promise which resolves to contain the created Entities
	 *
	 * @example
	 * const dataArray = [{name: "Entry 1"}, {name: "Entry 2"}, {name: "Entry 3"}];
	 * const entries = await Entity.createMany(dataArray); // Saved to the database
	 * const temps = await Entity.createMany(dataArray, {temporary: true}); // Not saved to the database
	 */
	static async createMany(data, options = {}) {
		const collection = this.collection;
		const name = this.entity;
		options = mergeObject(
			{ temporary: false, displaySheet: false },
			options
		);
		return SocketInterface.triggerMany(
			'createMany' + name,
			{ data },
			options,
			{
				preHook: 'preCreate' + name,
				context: collection,
				success: collection._createManyEntities,
				postHook: 'create' + name,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Update the current entity using new data
	 * This new data is typically provided from the server through the 'update<Entity>' socket
	 * Alternatively, the update may originate locally, in which case it can be pushed back to the server
	 *
	 * @param {Object} data     The data with which to update the entity
	 * @param {Object} options  Additional options which customize the update workflow
	 * @param {Boolean} options.diff    Diff the provided data against existing entity data, only submitting the
	 *                                  difference to the server. Default is true.
	 *
	 * @return {Promise}        A Promise which resolves to the updated Entity
	 *
	 * @example
	 * const updateData = {name: "New Name"};
	 * const updated = await entity.update(updateData);
	 */
	async update(data, options = {}) {
		const collection = this.collection;
		const name = this.entity;

		// Diff the provided update data against current values
		let updateData = data;
		if (options.diff !== false) {
			const changed = diffObject(this.data, expandObject(data));
			if (!Object.keys(changed).length) return this;
			updateData = changed;
		}
		updateData._id = this._id;

		// Trigger the socket event and handle response
		return SocketInterface.trigger(
			'update' + name,
			{ data: updateData },
			options,
			{
				preHook: 'preUpdate' + name,
				context: this,
				success: collection._updateEntity.bind(collection),
				postHook: 'update' + name,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Update multiple Entities using an Array of provided update Objects which define incremental data for each Entity.
	 * @static
	 *
	 * @param {Array.<Object>} data           Data with which to update each Entity. Each Object must include the _id
	 * @param {Object} options                Additional options which customize the update workflow
	 *
	 * @return {Promise}                      A Promise which resolves to contain the updated Entities
	 *
	 * @example
	 * const updateArray = [{_id: "dgfkjt34kjdgfkjt34", name: "Name 1"}, {_id: "dfskjkj2r3kjdvkj2", name: "Name 2"}];
	 * const updated = await Entity.updateMany(updateArray);
	 */
	static async updateMany(data, options = {}) {
		const collection = this.collection;
		const name = this.entity;

		// Structure the update data
		const updateIds = new Set();
		const updates = data.reduce((obj, d) => {
			if (!d._id)
				throw new Error(
					`You must provide an _id for every ${name} in the data Array.`
				);
			updateIds.add(d._id);
			obj[d._id] = { changed: d };
			return obj;
		}, {});

		// Difference each update against the existing data
		const changes = [];
		for (let e of collection.entities) {
			if (!updateIds.has(e.id)) continue;
			let changed = diffObject(
				e.data,
				expandObject(updates[e.id].changed)
			);
			if (!isObjectEmpty(changed)) {
				changed['_id'] = e.id;
				changes.push(changed);
			}
		}

		// Dispatch the update request and return the resolution
		return SocketInterface.triggerMany(
			'updateMany' + name,
			{ data: changes },
			options,
			{
				preHook: 'preUpdate' + name,
				context: collection,
				success: collection._updateManyEntities,
				postHook: 'update' + name,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Delete the entity, removing it from its collection and deleting its data record
	 * @param {Object} options    Additional options which customize the deletion workflow
	 * @return {Promise}          A Promise which resolves to the ID of the deleted Entity once handled by the server
	 *
	 * @example
	 * const deleted = await entity.delete();
	 */
	async delete(options = {}) {
		const collection = this.collection;
		const name = this.entity;
		return SocketInterface.trigger(
			'delete' + name,
			{ id: this._id },
			options,
			{
				preHook: 'preDelete' + name,
				context: this,
				success: collection._deleteEntity.bind(collection),
				postHook: 'delete' + name,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Delete multiple Entities using a provided Array of ids, one per Entity.
	 * @static
	 *
	 * @param {Array.<string>} ids            The data with which to create the entity
	 * @param {Object} options                Additional options which customize the deletion workflow
	 * @param {boolean} options.deleteAll     An optional flag which specifies that all Entities should be deleted
	 * @return {Promise}                      A Promise which resolves to contain the created Entities
	 *
	 * @example
	 * const deleteIds = ["dskjfk23jf23kdjs", "g90klju9yujl9hj2", "23hjdfewh23rgf3"];
	 * const deleted = await Entity.deleteMany(deleteIds);
	 */
	static async deleteMany(ids, options = {}) {
		const collection = this.collection;
		const name = this.entity;
		return SocketInterface.triggerMany(
			'deleteMany' + name,
			{ data: ids },
			options,
			{
				preHook: 'preDelete' + name,
				context: collection,
				success: collection._deleteManyEntities,
				postHook: 'delete' + name,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Entity-specific actions that should occur when the Entity is first created
	 * @private
	 */
	_onCreate(data, options, userId, context) {
		if (options.displaySheet && userId === game.user._id) {
			if (this.sheet) this.sheet.render(true, context);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Entity-specific actions that should occur when the Entity is updated
	 * @private
	 */
	_onUpdate(data, options, userId, context) {
		this.prepareData();
		this.render(false, context);
	}

	/* -------------------------------------------- */

	/**
	 * Entity-specific actions that should occur when the Entity is deleted
	 * @private
	 */
	_onDelete(id, options, userId, context) {
		Object.values(this.apps).forEach(a => a.close({ submit: false }));
	}

	/* -------------------------------------------- */
	/*  Embedded Entity Management                  */
	/* -------------------------------------------- */

	/**
	 * Get an Embedded Entity by it's id from a named collection in the parent Entity.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity type to retrieve
	 * @param {string} id             The numeric ID of the child to retrieve
	 * @param {boolean} strict        Throw an Error if the requested id does not exist, otherwise return null. Default false.
	 * @return {Object|null}          Retrieved data for the requested child, or null
	 */
	getEmbeddedEntity(embeddedName, id, { strict = false } = {}) {
		const collection = this.getEmbeddedCollection(embeddedName);
		const child = collection.find(c => c._id === id);
		if (!child && strict) {
			throw new Error(
				`The ${embeddedName} ${id} does not exist in ${this.constructor.name} ${this._id}`
			);
		}
		return child || null;
	}

	/* -------------------------------------------- */

	/**
	 * Remove an Embedded Entity from the parent Entity data by it's id.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity type to retrieve
	 * @param {number} id             The numeric ID of the child to retrieve
	 * @return {Object|null}          The embedded entity data that was removed
	 */
	removeEmbeddedEntity(embeddedName, id) {
		const collection = this.getEmbeddedCollection(embeddedName);
		return collection.findSplice(c => c._id === id);
	}

	/* -------------------------------------------- */

	/**
	 * Create one EmbeddedEntity within this parent Entity.
	 * Dispatch the creation request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to create
	 * @param {Object} createData     An object of initial data from which to create the Embedded Entity
	 * @param {Object} options        Additional creation options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the creation request is successful
	 */
	async createEmbeddedEntity(embeddedName, createData, options = {}) {
		// Validate inputs
		const collection = this.getEmbeddedCollection(embeddedName);
		delete createData._id;

		// Prepare submission data
		options['embeddedName'] = embeddedName;
		const eventName = `create${embeddedName}`;
		const eventData = { parentId: this._id, data: createData };

		// Dispatch the update request and return the resolution
		return SocketInterface.trigger(eventName, eventData, options, {
			preHook: `preCreate${embeddedName}`,
			context: this,
			success: this.collection._createEmbeddedEntity.bind(
				this.collection
			),
			postHook: eventName,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Create multiple Embedded Entities within this parent Entity using an Array of creation data.
	 * Dispatch the update request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to update
	 * @param {Array} createData      An Array of initial data objects from which to create the Embedded Entities.
	 * @param {Object} options        Additional update options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the creation request is successful
	 */
	async createManyEmbeddedEntities(embeddedName, createData, options = {}) {
		// Validate inputs
		options['embeddedName'] = embeddedName;
		for (let d of createData) {
			delete d._id;
		}

		// Dispatch the update request and return the resolution
		const eventData = { parentId: this._id, data: createData };
		return SocketInterface.triggerMany(
			`createMany${embeddedName}`,
			eventData,
			options,
			{
				preHook: `preCreate${embeddedName}`,
				context: this,
				success: this.collection._createManyEmbeddedEntities.bind(
					this.collection
				),
				postHook: `create${embeddedName}`,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Update one EmbeddedEntity within this parent Entity using incremental data.
	 * Dispatch the update request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to update
	 * @param {Object} updateData     An object of incremental data from which to update the Embedded Entity
	 * @param {Object} options        Additional update options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the update request is successful
	 */
	async updateEmbeddedEntity(embeddedName, updateData, options = {}) {
		// Validate inputs
		const collection = this.getEmbeddedCollection(embeddedName);
		if (!options.currentData && !updateData._id) {
			throw new Error(
				`You must provide the child object or it's id in order to update a ${embeddedName}`
			);
		}
		const currentData =
			options.currentData ||
			this.getEmbeddedEntity(embeddedName, updateData._id);
		options['embeddedName'] = embeddedName;

		// Diff the provided update data against current values
		const changedData = diffObject(currentData, expandObject(updateData));
		if (!Object.keys(changedData).length) return this;
		changedData['_id'] = currentData._id;

		// Dispatch the update request and return the resolution
		const eventName = `update${embeddedName}`;
		const eventData = { parentId: this._id, data: changedData };
		return SocketInterface.trigger(eventName, eventData, options, {
			preHook: `preUpdate${embeddedName}`,
			context: this,
			success: this.collection._updateEmbeddedEntity.bind(
				this.collection
			),
			postHook: eventName,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Update multiple Embedded Entities within this parent Entity using incremental data.
	 * Dispatch the update request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to update
	 * @param {Array} updateData      An Array of incremental data, one per Embedded Entity, with which to update the Entity
	 * @param {Object} options        Additional update options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the update request is successful
	 */
	async updateManyEmbeddedEntities(embeddedName, updateData, options = {}) {
		// Validate inputs
		const collection = this.getEmbeddedCollection(embeddedName);
		options['embeddedName'] = embeddedName;

		// Structure the update data
		const updateIds = new Set();
		const updates = updateData.reduce((obj, d) => {
			if (!d._id)
				throw new Error(
					'You must provide an id for every Embedded Entity in an updateMany operation'
				);
			updateIds.add(d._id);
			obj[d._id] = { changed: d };
			return obj;
		}, {});

		// Difference each update against existing data
		const changes = [];
		for (let e of collection) {
			if (!updateIds.has(e._id)) continue;
			let changed = diffObject(e, expandObject(updates[e._id].changed));
			if (!isObjectEmpty(changed)) {
				changed['_id'] = e._id;
				changes.push(changed);
			}
		}

		// Dispatch the update request and return the resolution
		const eventData = { parentId: this._id, data: changes };
		return SocketInterface.triggerMany(
			`updateMany${embeddedName}`,
			eventData,
			options,
			{
				preHook: `preUpdate${embeddedName}`,
				context: this,
				success: this.collection._updateManyEmbeddedEntities.bind(
					this.collection
				),
				postHook: `update${embeddedName}`,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Delete one EmbeddedEntity within this parent Entity.
	 * Dispatch the deletion request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to delete
	 * @param {string} childId        The id of the existing Embedded Entity child to delete
	 * @param {Object} options        Additional deletion options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the deletion request is successful
	 */
	async deleteEmbeddedEntity(embeddedName, childId, options = {}) {
		// Validate inputs
		const collection = this.getEmbeddedCollection(embeddedName);
		options['embeddedName'] = embeddedName;

		// Dispatch the update request and return the resolution
		const eventName = `delete${embeddedName}`;
		const eventData = { parentId: this._id, childId: childId };
		return SocketInterface.trigger(eventName, eventData, options, {
			preHook: `preDelete${embeddedName}`,
			context: this,
			success: this.collection._deleteEmbeddedEntity.bind(
				this.collection
			),
			postHook: eventName,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Delete multiple Embedded Entities within this parent Entity by an Array of child ids.
	 * Dispatch the update request to the server for handling.
	 * The result will be acknowledged to this client, and broadcast to other connected clients.
	 *
	 * @param {string} embeddedName   The name of the Embedded Entity class to update
	 * @param {Array} deleteIds       An Array of Embedded Entity ids to delete from the parent Entity
	 * @param {Object} options        Additional update options which modify the request
	 * @return {Promise}              A Promise which resolves to this Entity once the update request is successful
	 */
	async deleteManyEmbeddedEntities(embeddedName, deleteIds, options = {}) {
		// Validate inputs
		const collection = this.getEmbeddedCollection(embeddedName);
		deleteIds = new Set(deleteIds);
		options['embeddedName'] = embeddedName;

		// Validate requested IDs
		const toDelete = [];
		for (let e of collection) {
			if (!deleteIds.has(e._id)) continue;
			toDelete.push(e._id);
		}

		// Dispatch the update request and return the resolution
		const eventData = { parentId: this._id, data: toDelete };
		return SocketInterface.triggerMany(
			`deleteMany${embeddedName}`,
			eventData,
			options,
			{
				preHook: `preDelete${embeddedName}`,
				context: this,
				success: this.collection._deleteManyEmbeddedEntities.bind(
					this.collection
				),
				postHook: `delete${embeddedName}`,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Embedded Entity creation within this Entity with specific callback steps.
	 * This callback function is triggered by Collection._createEmbeddedEntity once the source data is updated.
	 * @private
	 */
	_onCreateEmbeddedEntity(response) {}

	/* -------------------------------------------- */

	/**
	 * Handle Embedded Entity update within this Entity with specific callback steps.
	 * This callback function is triggered by Collection._updateEmbeddedEntity once the source data is updated.
	 * @private
	 */
	_onUpdateEmbeddedEntity(response) {}

	/* -------------------------------------------- */

	/**
	 * Handle Embedded Entity deletion within this Entity with specific callback steps.
	 * This callback function is triggered by Collection._deleteEmbeddedEntity once the source data is updated.
	 * @private
	 */
	_onDeleteEmbeddedEntity(response) {}

	/* -------------------------------------------- */

	/**
	 * A generic helper since we take the same actions for every type of Embedded Entity update
	 * @private
	 */
	_onModifyEmbeddedEntity({ embeddedName, renderContext } = {}) {
		this.prepareData();
		this.render(false, renderContext);
	}

	/* -------------------------------------------- */
	/*  Data Flags                                  */
	/* -------------------------------------------- */

	/**
	 * Get the value of a "flag" for this Entity
	 * See the setFlag method for more details on flags
	 *
	 * @param {String} scope    The flag scope which namespaces the key
	 * @param {String} key      The flag key
	 * @return {*}              The flag value
	 */
	getFlag(scope, key) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `${scope}.${key}`;
		return getProperty(this.data.flags, key);
	}

	/* -------------------------------------------- */

	/**
	 * Assign a "flag" to this Entity.
	 * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
	 * the core software, game systems, or user-created modules.
	 *
	 * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
	 *
	 * Flags set by the core software use the "core" scope.
	 * Flags set by game systems or modules should use the canonical name attribute for the module
	 * Flags set by an individual world should "world" as the scope.
	 *
	 * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
	 *
	 * @param {String} scope    The flag scope which namespaces the key
	 * @param {String} key      The flag key
	 * @param {*} value         The flag value
	 *
	 * @return {Promise.<Entity>} A Promise resolving to the updated Entity
	 */
	async setFlag(scope, key, value) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.${key}`;
		return this.update({ [key]: value });
	}

	/* -------------------------------------------- */

	/**
	 * Remove a flag assigned to the Entity
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {Promise}        A Promise resolving to the updated Entity
	 */
	async unsetFlag(scope, key) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.-=${key}`;
		return this.update({ [key]: null });
	}

	/* -------------------------------------------- */
	/*  Sorting                                     */
	/* -------------------------------------------- */

	/**
	 * Sort this Entity relative a target by providing the target, an Array of siblings and other options.
	 * If the Entity has an rendered sheet, record the sort change as part of a form submission
	 * See SortingHelper.performIntegerSort for more details
	 */
	async sortRelative({
		target = null,
		siblings = [],
		sortKey = 'sort',
		sortBefore = true,
		updateData = {},
	} = {}) {
		const updates = SortingHelpers.performIntegerSort(this, {
			target,
			siblings,
			sortKey,
			sortBefore,
		});
		for (let u of updates) {
			const ent = u.target;
			const update = mergeObject(updateData, u.update, {
				inplace: false,
			});
			if (ent.sheet && ent.sheet._rendered)
				await ent.sheet.submit({ updateData: update });
			else await ent.update(update);
		}
	}

	/* -------------------------------------------- */
	/*  Saving and Loading
  /* -------------------------------------------- */

	/**
	 * Clone an Entity, creating a new Entity using the current data as well as provided creation overrides.
	 *
	 * @param {Object} createData     Additional data which overrides current Entity data at the time of creation
	 * @param {Object} options        Additional creation options passed to the Entity.create method
	 * @returns {Promise.<Entity>}    A Promise which resolves to the created clone Entity
	 */
	async clone(createData = {}, options = {}) {
		createData = mergeObject(this.data, createData, { inplace: false });
		await this.constructor.create(createData, options);
	}

	/* -------------------------------------------- */

	/**
	 * Export entity data to a JSON file which can be saved by the client and later imported into a different session
	 */
	exportToJSON() {
		const data = duplicate(this.data);
		delete data.folder;
		delete data.permission;
		const filename = `fvtt-${this.entity}-${this.name.replace(
			/\s/g,
			'_'
		)}.json`;
		saveDataToFile(JSON.stringify(data, null, 2), 'text/json', filename);
	}

	/* -------------------------------------------- */

	/**
	 * Import data and update this entity
	 * @param {String} json         JSON data string
	 * @return {Promise.<Entity>}   The updated Entity
	 */
	async importFromJSON(json) {
		const data = JSON.parse(json);
		delete data._id;
		return this.update(data);
	}

	/* -------------------------------------------- */

	/**
	 * Render an import dialog for updating the data related to this Entity through an exported JSON file
	 * @return {Promise.<void>}
	 */
	async importFromJSONDialog() {
		new Dialog(
			{
				title: `Import Data: ${this.name}`,
				content: await renderTemplate(
					'templates/apps/import-data.html',
					{ entity: this.entity, name: this.name }
				),
				buttons: {
					import: {
						icon: '<i class="fas fa-file-import"></i>',
						label: 'Import',
						callback: html => {
							const form = html.find('form')[0];
							if (!form.data.files.length)
								return ui.notifications.error(
									'You did not upload a data file!'
								);
							readTextFromFile(form.data.files[0]).then(json =>
								this.importFromJSON(json)
							);
						},
					},
					no: {
						icon: '<i class="fas fa-times"></i>',
						label: 'Cancel',
					},
				},
				default: 'import',
			},
			{
				width: 400,
			}
		).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Serializing an Entity should simply serialize it's inner data, not the entire instance
	 * @return {Object}
	 */
	toJSON() {
		return this.data;
	}
}

/**
 * The virtual tabletop environment is implemented using a WebGL powered HTML 5 canvas using the powerful PIXI.js
 * library. The canvas is comprised of an ordered sequence of layers which define rendering groups and collections of
 * objects that are drawn on the canvas itself.
 *
 * @see {link CanvasLayer} An abstract class for all Canvas layers.
 * @see {link PlaceablesLayer} An abstract class for Canvas Layers which contain Placeable Objects.
 * @see {link PlaceableObject} An abstract class for objects which are placed into the Scene and drawn on the canvas.
 *
 * @example <caption>Example Canvas commands</caption>
 * canvas.ready; // Is the canvas ready for use?
 * canvas.scene; // The currently viewed Scene entity.
 * canvas.dimensions; // The dimensions of the current Scene.
 * canvas.draw(); // Completely re-draw the game canvas (this is usually unnecessary).
 * canvas.pan(x, y, zoom); // Pan the canvas to new coordinates and scale.
 * canvas.recenter(); // Re-center the canvas on the currently controlled Token.
 */
class Canvas {
	constructor() {
		// Draw the canvas
		const canvas = document.createElement('canvas');
		canvas.id = 'board';
		$('#board').replaceWith(canvas);
		canvas.ondragover = this._onDragOver;
		canvas.ondrop = this._onDrop;

		// Create PIXI Application
		this.app = new PIXI.Application({
			view: canvas,
			width: window.innerWidth,
			height: window.innerHeight,
			antialias: true,
			transparent: false,
			resolution: 1,
			backgroundColor: null,
		});

		// Confirm that WebGL is available
		if (this.app.renderer.type !== PIXI.RENDERER_TYPE.WEBGL) {
			Hooks.once('renderNotifications', app => {
				app.error(
					'WebGL support not detected, ensure you have hardware rendering support enabled.'
				);
			});
			throw new Error('No WebGL Support!');
		}

		// Create the primary canvas layers
		this.stage = this.app.stage;
		this.hud = new HeadsUpDisplay();
		this._createLayers(this.stage);

		// Record the active scene and its dimensions
		this.id = null;
		this.scene = null;
		this.dimensions = null;

		/**
		 * Track the timestamp of the last stage zoom operation
		 * @type {Number}
		 * @private
		 */
		this._zoomTime = 0;

		/**
		 * Throttle mousemove events to only fire once per 20ms
		 * @type {number}
		 * @private
		 */
		this._mouseMoveTime = 0;

		/**
		 * An object of data which is temporarily cached to be reloaded after the canvas is drawn
		 * @type {Object}
		 * @private
		 */
		this._reload = { layer: 'TokenLayer' };

		/**
		 * A flag for whether the game Canvas is ready to be used. False if the canvas is not yet drawn, true otherwise.
		 * @type {boolean}
		 */
		this.ready = false;

		/**
		 * An Array of pending canvas operations which should trigger on the next re-paint
		 * @type {Array}
		 */
		this.pendingOperations = [];

		/**
		 * A Set of unique pending operation names to ensure operations are only performed once
		 * @type {Set.<string>}
		 */
		this._pendingOperationNames = new Set();
	}

	/* -------------------------------------------- */

	/**
	 * Create the layers of the game Canvas
	 * @param {PIXI.Container} stage    The primary canvas stage
	 * @private
	 */
	_createLayers(stage) {
		this.background = stage.addChild(new BackgroundLayer());
		this.tiles = stage.addChild(new TilesLayer());
		this.drawings = stage.addChild(new DrawingsLayer());
		this.grid = stage.addChild(new GridLayer());
		this.templates = stage.addChild(new TemplateLayer());
		this.walls = stage.addChild(new WallsLayer());
		this.notes = stage.addChild(new NotesLayer());
		this.tokens = stage.addChild(new TokenLayer());
		this.lighting = stage.addChild(new LightingLayer());
		this.sight = stage.addChild(new SightLayer());
		this.sounds = stage.addChild(new SoundsLayer());
		this.effects = stage.addChild(new EffectsLayer());
		this.controls = stage.addChild(new ControlsLayer());
	}

	/* -------------------------------------------- */
	/*  Properties and Attributes
  /* -------------------------------------------- */

	get layers() {
		return this.stage.children.filter(l => l instanceof CanvasLayer);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the active Canvas Layer
	 * @type {CanvasLayer}
	 */
	get activeLayer() {
		return this.layers.find(l => l._active);
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/**
	 * When re-drawing the canvas, first tear down or discontinue some existing processes
	 */
	tearDown() {
		// Track current data which should be restored on draw
		this._reload = {
			scene: this.scene._id,
			layer: this.activeLayer.name,
			tokens: Object.keys(this.tokens._controlled),
		};

		// Stop background video playback
		if (this.background.isVideo) this.background.source.pause();

		// Release controlled objects
		canvas.activeLayer.releaseAll();

		// Conclude token animations
		this.tokens.concludeAnimation();

		// Save current fog of war progress
		this.sight.saveFog();

		// Terminate ambient audio playback
		this.sounds.stopAll();

		// Reset the collection of synthetic Token actors
		game.actors.tokens = {};
	}

	/* -------------------------------------------- */

	/**
	 * Draw the game canvas.
	 */
	async draw(scene) {
		scene = (scene === undefined ? game.scenes.viewed : scene) || null;

		// Tear down any existing scene
		if (this.ready) this.tearDown();
		this.ready = false;

		// Confirm there is an active scene
		if (scene === null) {
			canvas.app.view.style.display = 'none';
			console.log(`${vtt} | Skipping game canvas - no active scene.`);
			return;
		} else if (!(scene instanceof Scene)) {
			throw new Error(
				'You must provide a Scene entity to draw the VTT canvas.'
			);
		} else {
			canvas.app.view.style.display = 'block';
			console.log(`${vtt} | Drawing game canvas for scene ${scene.name}`);
		}

		// Configure stage dimensions
		this.id = scene._id;
		this.scene = game.scenes.viewed;
		this.dimensions = this.getDimensions();
		let ww2 = window.innerWidth / 2;
		let wh2 = window.innerHeight / 2;
		this.stage.position.set(ww2, wh2);
		this.stage.hitArea = new PIXI.Rectangle(
			0,
			0,
			this.dimensions.width,
			this.dimensions.height
		);
		this.stage.interactive = true;

		// Set background color
		if (scene.data.backgroundColor) {
			this.app.renderer.backgroundColor = colorStringToHex(
				scene.data.backgroundColor
			);
		}

		// Load required textures
		await loadSceneTextures(scene);

		// Draw layers
		for (let l of this.layers) {
			await l.draw();
		}

		// Initialize starting conditions
		Hooks.callAll('canvasInit', this);
		this._initialize();

		// Add interactivity
		this._addListeners();

		// Check if the window was re-sized before the draw operation concluded
		if (
			this.app.renderer.width !== window.innerWidth ||
			this.app.renderer.height !== window.innerHeight
		) {
			this._onResize(new Event('resize'));
		}

		// Mark the canvas as ready and call hooks
		this.ready = true;
		Hooks.call('canvasReady', this);
		this._reload = {};
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get the canvas active dimensions based on the size of the scene's map
	 * We expand the image size by a factor of 1.5 and round to the nearest 200 pixels
	 * This guarantees that walls and tokens remain positioned in the same location if the grid size changes
	 */
	getDimensions() {
		const data = this.scene.data,
			gx2 = data.grid * 2,
			w = data.width || data.grid * 30,
			h = data.height || data.grid * 20;

		// Assign dimensions
		const dims = {
			width: w + Math.ceil((0.5 * w) / gx2) * gx2,
			sceneWidth: w,
			height: h + Math.ceil((0.5 * h) / gx2) * gx2,
			sceneHeight: h,
			size: parseInt(data.grid),
			distance: parseFloat(data.gridDistance),
			shiftX: parseInt(data.shiftX),
			shiftY: parseInt(data.shiftY),
			ratio: w / h,
		};

		// Determine the padding offset as a multiple of the grid size
		dims.paddingX = (dims.width - w) * 0.5;
		dims.paddingY = (dims.height - h) * 0.5;
		return dims;
	}

	/* -------------------------------------------- */

	/**
	 * Once the canvas is drawn, initialize control, visibility, and audio states
	 */
	_initialize() {
		// Render the HUD layer
		this.hud.render(true);

		// Initialize canvas conditions
		this._initializeCanvasPosition();
		this._initializeCanvasLayer();
		this._initializeTokenControl();

		// Set the user's current scene
		game.user.update({ scene: this.id });

		// Clear the set of targeted Tokens for the current user
		game.user.targets.clear();

		// Initialize starting sight conditions
		this.sight.initialize();

		// Initialize audio
		this.sounds.initialize();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the starting view of the canvas stage
	 * If we are re-drawing a scene which was previously rendered, restore the prior view position
	 * Otherwise set the view to the top-left corner of the scene at standard scale
	 * @private
	 */
	_initializeCanvasPosition() {
		// If we are re-drawing a Scene that was already visited, use it's cached view position
		const position = this.scene._viewPosition;
		if (!isObjectEmpty(position)) return this.pan(position);

		// Otherwise use a saved initial position
		const initial = this.scene.data.initial;
		if (initial)
			return this.pan({
				x: initial.x,
				y: initial.y,
				scale: initial.scale,
			});

		// Otherwise determine a starting default based on the scene size
		this.pan({
			x: this.dimensions.paddingX + this.stage.position.x,
			y: this.dimensions.paddingY + this.stage.position.y,
			scale: 1,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a CanvasLayer in the activation state
	 * @private
	 */
	_initializeCanvasLayer() {
		let activeLayer =
			this._reload.layer || ui.controls.control.layer || 'TokenLayer';
		this.getLayer(activeLayer).activate();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a token or set of tokens which should be controlled
	 * If we are re-loading a scene which was previously rendered - restore control over prior controlled tokens
	 * Otherwise look for an impersonated (preferred) or observed (fallback) token to control
	 * @private
	 */
	_initializeTokenControl() {
		let isReload = this._reload.scene === this.scene._id;

		// Restore cached control set
		const cached = isReload ? this._reload.tokens : {};
		if (isReload) {
			canvas.tokens._controlled = cached.reduce((obj, id) => {
				obj[id] = canvas.tokens.get(id);
				return obj;
			}, {});
			Object.values(canvas.tokens._controlled).forEach(t =>
				t.control({ initializeSight: false })
			);
		}

		// Control initial token
		else if (!game.user.isGM) {
			let token = game.user.character
				? game.user.character.getActiveTokens().shift()
				: null;
			if (!token) {
				token = canvas.tokens.placeables
					.filter(
						t => t.actor && t.actor.hasPerm(game.user, 'OBSERVER')
					)
					.shift();
			}
			if (token) {
				token.control({ initializeSight: false });
				if (!isReload)
					this.animatePan({
						x: token.data.x,
						y: token.data.y,
						duration: 250,
					});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get a reference to the a specific CanvasLayer by it's name
	 * @param {string} layerName    The name of the canvas layer to get
	 * @return {CanvasLayer}
	 */
	getLayer(layerName) {
		return this.stage.getChildByName(layerName);
	}

	/* -------------------------------------------- */

	/**
	 * Given an embedded object name, get the canvas layer for that object
	 * @param {string} embeddedName
	 * @returns {PlaceablesLayer|null}
	 * @private
	 */
	getLayerByEmbeddedName(embeddedName) {
		return (
			{
				AmbientLight: this.lighting,
				AmbientSound: this.sounds,
				Drawing: this.drawings,
				Note: this.notes,
				MeasuredTemplate: this.templates,
				Tile: this.tiles,
				Token: this.tokens,
				Wall: this.walls,
			}[embeddedName] || null
		);
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Pan the canvas to a certain {x,y} coordinate and a certain zoom level
	 * @param {number|null} x      The x-coordinate of the pan destination
	 * @param {number|null} y      The y-coordinate of the pan destination
	 * @param {number|null} scale  The zoom level (max of CONFIG.maxCanvasZoom) of the action
	 */
	pan({ x = null, y = null, scale = null } = {}) {
		// Pan the canvas to the new destination
		x = Number(x) || this.stage.pivot.x;
		y = Number(y) || this.stage.pivot.y;
		this.stage.pivot.set(x, y);

		// Zoom the canvas to the new level
		if (Number.isNumeric(scale) && scale !== this.stage.scale.x) {
			scale = this._constrainScale(scale);
			this.stage.scale.set(scale, scale);
		} else scale = this.stage.scale.x;

		// Update the scene tracked position
		canvas.scene._viewPosition = { x: x, y: y, scale: scale };

		// Call canvasPan Hook
		Hooks.callAll('canvasPan', this, { x, y, scale });

		// Align the HUD
		this.hud.align();
	}

	/* -------------------------------------------- */

	/**
	 * Animate panning the canvas to a certain destination coordinate and zoom scale
	 * Customize the animation speed with additional options
	 * Returns a Promise which is resolved once the animation has completed
	 *
	 * @param {Number} x            The destination x-coordinate
	 * @param {Number} y            The destination y-coordinate
	 * @param {Number} scale        The destination zoom scale
	 * @param {Number} duration     The total duration of the animation in milliseconds; used if speed is not set
	 * @param {Number} speed        The speed of animation in pixels per second; overrides duration if set
	 * @returns {Promise}           A Promise which resolves once the animation has been completed
	 */
	async animatePan({ x, y, scale, duration = 250, speed }) {
		// Determine the animation duration to reach the target
		if (speed) {
			let ray = new Ray(this.stage.pivot, { x, y });
			duration = Math.round((ray.distance * 1000) / speed);
		}

		// Construct the animation attributes
		const attributes = [
			{ parent: this.stage.pivot, attribute: 'x', to: x },
			{ parent: this.stage.pivot, attribute: 'y', to: y },
			{ parent: this.stage.scale, attribute: 'x', to: scale },
			{ parent: this.stage.scale, attribute: 'y', to: scale },
		].filter(a => a.to !== undefined);

		// Trigger the animation function
		await CanvasAnimation.animateLinear(attributes, {
			name: 'canvas.animatePan',
			duration: duration,
			ontick: (dt, attributes) => {
				this.hud.align();
				const stage = this.stage;
				Hooks.callAll('canvasPan', this, {
					x: stage.pivot.x,
					y: stage.pivot.y,
					scale: stage.scale.x,
				});
			},
		});

		// Update the scene tracked position
		canvas.scene._viewPosition = { x: x, y: y, scale: scale };
	}

	/* -------------------------------------------- */

	/**
	 * Get the constrained zoom scale parameter which is allowed by the maxCanvasZoom value
	 * @param {Number} scale    The requested scale
	 * @return {Number}         The allowed scale
	 * @private
	 */
	_constrainScale(scale) {
		const d = canvas.dimensions;
		const max = CONFIG.maxCanvasZoom;
		const ratio = Math.max(
			d.width / window.innerWidth,
			d.height / window.innerHeight,
			max
		);
		return Math.round(Math.clamped(scale, 1 / ratio, max) * 100) / 100;
	}

	/* -------------------------------------------- */

	/**
	 * Recenter the canvas
	 * Otherwise, pan the stage to put the top-left corner of the map in the top-left corner of the window
	 */
	recenter(coordinates) {
		if (coordinates) this.pan(coordinates);
		this.animatePan({
			x: this.dimensions.paddingX + window.innerWidth / 2,
			y: this.dimensions.paddingY + window.innerHeight / 2,
			duration: 250,
		});
	}

	/* -------------------------------------------- */
	/* Event Handlers
  /* -------------------------------------------- */

	/**
	 * Attach event listeners to the game canvas to handle click and interaction events
	 * @private
	 */
	_addListeners() {
		this.stage.removeAllListeners();
		this.stage
			.on('mousedown', this._onMouseDown)
			.on('rightdown', this._onRightDown)
			.on('mousemove', this._onMouseMove.bind(this))
			.on('mouseup', this._onMouseUp)
			.on('mouseupoutside', this._onMouseUp)
			.on('rightup', this._onRightUp)
			.on('rightupoutside', this._onRightUp);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left mouse-click events occuring on the Canvas stage or it's active layer
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseDown(event) {
		// Extract event data
		const oe = event.data.originalEvent,
			layer = canvas.activeLayer,
			isRuler = game.activeTool === 'ruler',
			isCtrlRuler =
				(oe.ctrlKey || oe.metaKey) && layer.name === 'TokenLayer',
			isSelect = ['select', 'target'].includes(game.activeTool);

		// First delegate the click to the active layer unless a special tool is in use
		if (layer._onMouseDown)
			layer._onMouseDown(event, { isRuler, isCtrlRuler, isSelect });
		if (event.stopped) return;
		event.stopPropagation();

		// Record initial event position
		event.data.origin = event.data.getLocalPosition(this);
		event.data.tool = game.activeTool;

		// Handle ruler measurement
		if (isRuler || isCtrlRuler) canvas.controls.ruler._onMouseDown(event);
		// Begin a new selection
		else if (isSelect) {
			event.data._selectState = 1;
			event.data.coords = [];
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse-click events occuring on the Canvas stage or it's active layer
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onRightDown(event) {
		// First delegate the click to the active layer
		const layer = canvas.activeLayer;
		if (layer._onRightDown) layer._onRightDown(event);
		if (event.stopped) return;
		event.stopPropagation();

		// Handle ruler measurement
		let ruler = canvas.controls.ruler;
		if (ruler.active) ruler._onCancelWaypoint(event);
		// Begin a new canvas pan workflow
		else {
			event.data._panStart = {
				x: canvas.stage.pivot.x,
				y: canvas.stage.pivot.y,
			};
			event.data.origin = {
				x: event.data.global.x,
				y: event.data.global.y,
			};
			event.data._dragState = 1;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse movement events occuring on the Canvas stage or it's active layer
	 * Throttle mousemove time at 20ms (~50 frames per second)
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseMove(event) {
		const now = Date.now();
		const throttle = 20;

		// If it has been less than 20ms wait a bit before handling
		if (now - this._mouseMoveTime < throttle) {
			event.stopPropagation();
			return false;
		}
		this._mouseMoveTime = now;

		// First delegate the click to the active layer
		const layer = this.activeLayer;
		if (layer._onMouseMove) layer._onMouseMove(event);
		if (event.stopped) return;

		// Extract event data
		const { origin, cursorTime, _selectState, _dragState } = event.data;
		let p0 = origin,
			p1 = event.data.getLocalPosition(this.stage);
		event.data.destination = p1;

		// Update the client's cursor position every 100ms
		let ct = cursorTime || 0;
		if (now - ct > 100) {
			if (this.controls) canvas.controls._onMoveCursor(event, p1);
			event.data.cursorTime = now;
		}

		// Update the client's active status every 5000ms
		if (now - ct > 5000) {
			game.user.update({ active: true });
		}

		// Continue a measurement event if we have moved at least half a grid unit
		const ruler = this.controls.ruler;
		if (ruler._state > 0) ruler._onMouseMove(event);
		// Continue a select event
		else if (_selectState > 0)
			this._onMoveSelect(event, _selectState, p0, p1);
		// Continue a drag event
		else if (_dragState > 0) {
			const DRAG_SPEED_MODIFIER = 0.8;
			let dx =
					(event.data.global.x - p0.x) /
					(this.stage.scale.x * DRAG_SPEED_MODIFIER),
				dy =
					(event.data.global.y - p0.y) /
					(this.stage.scale.y * DRAG_SPEED_MODIFIER);
			this.pan({
				x: event.data._panStart.x - dx,
				y: event.data._panStart.y - dy,
			});
			this.tokens._tabCycle = false;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Determine selection coordinate rectangle during a mouse-drag workflow
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @param {Number} state    The selection workflow state
	 * @param {Object} p0       The origin coordinate
	 * @param {Object} p1       The destination coordinate
	 * @private
	 */
	_onMoveSelect(event, state, p0, p1) {
		// Determine rectangle coordinates
		let coords = {
			x: Math.min(p0.x, p1.x),
			y: Math.min(p0.y, p1.y),
			width: Math.abs(p1.x - p0.x),
			height: Math.abs(p1.y - p0.y),
		};

		// Only select if we have moved further than the minimum drag distance in some direction
		let distance = Math.hypot(coords.width, coords.height);
		if (state === 2 || distance >= canvas.dimensions.size / 2) {
			canvas.controls.drawSelect(coords);
			event.data._selectState = 2;
			event.data.coords = coords;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-mouse up events occuring on the Canvas stage or it's active layer
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseUp(event) {
		// First delegate the click to the active layer
		const layer = canvas.activeLayer;
		if (layer._onMouseUp) layer._onMouseUp(event);
		if (event.stopped) return;
		event.stopPropagation();

		// Extract event data
		const { coords, originalEvent, tool, _selectState } = event.data;
		const isCtrl = originalEvent.ctrlKey || originalEvent.metaKey;
		const ruler = canvas.controls.ruler;

		// Conclude a measurement event if we aren't holding the CTRL key
		if (ruler.active) {
			if (isCtrl) return;
			ruler._onEndMeasurement(event);
		}

		// Conclude a select event
		else if (_selectState === 2) {
			if (tool === 'select') layer.selectObjects(coords);
			else if (tool === 'target')
				layer.targetObjects(coords, {
					releaseOthers: !originalEvent.shiftKey,
				});
			canvas.controls.select.clear();
		}
		event.data._selectState = 0;
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-mouse up events occuring on the Canvas stage or it's active layer
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onRightUp(event) {
		// First delegate the click to the active layer
		const layer = canvas.activeLayer;
		if (layer._onRightUp) layer._onRightUp(event);

		// Conclude drag event on the stage
		if (event.stopped) return;
		event.stopPropagation();
		event.data._dragState = 0;
	}

	/* -------------------------------------------- */

	/**
	 * Handle window resizing with the dimensions of the window viewport change
	 * @param {Event} event   The Window resize event
	 * @private
	 */
	_onResize(event) {
		if (!this.ready) return false;

		// Resize the renderer
		let w = window.innerWidth,
			h = window.innerHeight;
		this.app.renderer.view.style.width = w + 'px';
		this.app.renderer.view.style.height = h + 'px';
		this.app.renderer.resize(w, h);

		// Re-draw the canvas
		this.draw();
	}

	/* -------------------------------------------- */
	/* Zooming (Mouse Wheel)
  /* -------------------------------------------- */

	_onMouseWheel(event) {
		let dz = event.deltaY < 0 ? 1.05 : 0.95;
		this.pan({ scale: dz * canvas.stage.scale.x });
	}

	/* -------------------------------------------- */
	/*  Drag/Drop Events
  /* -------------------------------------------- */

	/**
	 * The ondragover listener is required to make the canvas a valid drop-zone
	 * @private
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Event handler for the drop portion of a drag-and-drop event.
	 * @private
	 */
	_onDrop(event) {
		event.preventDefault();

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}

		// Dropped Actor
		if (data.type === 'Actor') canvas.tokens._onDropActorData(event, data);
		// Dropped Journal Entry
		else if (data.type === 'JournalEntry') {
			let entry = game.journal.get(data.id);
			canvas.notes._onDropEntity(event, entry);
		}

		// Dropped Macro (clear slot)
		else if (data.type === 'Macro') {
			game.user.assignHotbarMacro(null, data.slot);
		}
	}

	/* -------------------------------------------- */
	/*  Pending Operations                          */
	/* -------------------------------------------- */

	/**
	 * Add a pending canvas operation that should fire once the socket handling workflow concludes.
	 * This registers operations by a unique string name into a queue - avoiding repeating the same work multiple times.
	 * This is especially helpful for multi-object updates to avoid costly and redundant refresh operations.
	 * @param {string} name     A unique name for the pending operation, conventionally Class.method
	 * @param {Function} fn     The unbound function to execute later
	 * @param {*} scope         The scope to which the method should be bound when called
	 * @param {...*} args       Arbitrary arguments to pass to the method when called
	 */
	addPendingOperation(name, fn, scope, args) {
		if (this._pendingOperationNames.has(name)) return;
		this._pendingOperationNames.add(name);
		this.pendingOperations.push([fn, scope, args]);
	}

	/* -------------------------------------------- */

	/**
	 * Fire all pending functions that are registered in the pending operations queue and empty it.
	 */
	triggerPendingOperations() {
		for (let [fn, scope, args] of this.pendingOperations) {
			args = args || [];
			fn = fn.call(scope, ...args);
		}
		this.pendingOperations = [];
		this._pendingOperationNames.clear();
	}
}

/**
 * An abstract pattern for primary layers of the game canvas to implement
 * @type {PIXI.Container}
 */
class CanvasLayer extends PIXI.Container {
	constructor() {
		super();

		/**
		 * Track whether the canvas layer is currently active for interaction
		 * @type {Boolean}
		 */
		this._active = false;
	}

	/* -------------------------------------------- */
	/*  Properties and Attributes
  /* -------------------------------------------- */

	get name() {
		return this.constructor.name;
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the canvas layer, rendering its internal components and returning a Promise
	 * The Promise resolves to the drawn layer once its contents are successfully rendered.
	 * @return {Promise.<CanvasLayer>}
	 */
	async draw() {
		// Clear existing layer contents
		this.removeChildren().forEach(c => c.destroy({ children: true }));

		// Set basic dimensions
		const d = canvas.dimensions;
		this.width = d.width;
		this.height = d.height;
		this.hitArea = new PIXI.Rectangle(0, 0, d.width, d.height);
		return this;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	activate() {
		canvas.stage.children.forEach(layer => layer.deactivate());
		this.interactive = false;
		this.interactiveChildren = true;
		this._active = true;
		if (ui.controls)
			ui.controls.initialize({ layer: this.constructor.name });
	}

	/* -------------------------------------------- */

	deactivate() {
		this.interactive = false;
		this.interactiveChildren = false;
		this._active = false;
	}
}
/**
 * A PlaceableObject base container class
 * @type {PIXI.Container}
 */
class PlaceableObject extends PIXI.Container {
	constructor(data, scene) {
		super();

		/**
		 * The underlying data object which provides the basis for this placeable object
		 * @type {Object}
		 */
		this.data = data;

		/**
		 * Retain a reference to the Scene within which this Placeable Object resides
		 * @type {Scene}
		 */
		this.scene = scene;

		/**
		 * Track the field of vision for the placeable object.
		 * This is necessary to determine whether a player has line-of-sight towards a placeable object or vice-versa
		 * @type {PIXI.Polygon}
		 */
		this.fov = null;

		/**
		 * An indicator for whether the object is currently a hover target
		 * @type {Boolean}
		 * @private
		 */
		this._hover = false;

		/**
		 * An indicator for whether the object is currently controlled
		 * @type {Boolean}
		 * @private
		 */
		this._controlled = false;

		/**
		 * A control icon for interacting with the object
		 * @type {ControlIcon}
		 */
		this.controlIcon = null;
	}

	/* -------------------------------------------- */
	/* Properties
  /* -------------------------------------------- */

	/**
	 * The EmbeddedDocument id of the underlying data object
	 * @type {string}
	 */
	get id() {
		return this.data._id;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a reference to the canvas layer which contains placeable objects of this type
	 * @type {PlaceablesLayer}
	 */
	static get layer() {
		throw new Error(
			'A PlaceableObject subclass must provide a reference to the canvas layer which contains it.'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the singleton layer instance which contains placeables of this type
	 * @type {PlaceablesLayer}
	 */
	get layer() {
		return canvas.stage.children.find(
			l => l.constructor.name === this.constructor.layer.name
		);
	}

	/* -------------------------------------------- */

	/**
	 * The [x,y] coordinates of the placeable object within the Scene container
	 * @type {Array}
	 */
	get coords() {
		return [this.data.x, this.data.y];
	}

	/* -------------------------------------------- */

	/**
	 * The central coordinate pair of the placeable object based on it's own width and height
	 * @type {Object}
	 */
	get center() {
		return {
			x: this.data.x,
			y: this.data.y,
		};
	}

	/**
	 * A Boolean flag for whether the current game User has permission to control this token
	 * @type {Boolean}
	 */
	get owner() {
		return game.user.isGM;
	}

	/**
	 * A placeable object should define the logic to create
	 * @type {Application}
	 */
	get sheet() {
		throw new Error(
			'A PlaceableObject subclass may optionally define a configuration sheet application.'
		);
	}

	/* -------------------------------------------- */
	/* Methods
  /* -------------------------------------------- */

	/**
	 * Clear the display of the existing object
	 */
	clear() {
		this.removeChildren().forEach(c => c.destroy({ children: true }));
	}

	/* -------------------------------------------- */

	/**
	 * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
	 * @param {Boolean} multiSelect       Is this object being selected as part of a group?
	 * @param {Boolean} releaseOthers     Release any other controlled objects first
	 * @return {Boolean}                  A Boolean flag denoting whether or not control was successful.
	 */
	control({ multiSelect = false, releaseOthers = true } = {}) {
		if (this._controlled) return true;
		if (releaseOthers) this.layer.releaseAll({ resetSight: false });

		// Prevent control if the user is not an object owner
		if (!this.owner) return false;

		// Toggle control status
		this._controlled = true;
		this.layer._controlled[this.id] = this;

		// Refresh object display
		this.refresh();

		// Fire an on-control Hook
		Hooks.callAll(
			'control' + this.constructor.name,
			this,
			this._controlled
		);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the shifted position for the Object
	 * @param {Number} dx         The number of grid units to shift along the X-axis
	 * @param {Number} dy         The number of grid units to shift along the Y-axis
	 * @return {{x, y}}           The target movement coordinates subject to some offset
	 * @private
	 */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(
			this.data.x,
			this.data.y,
			dx,
			dy
		);
		return { x, y };
	}

	/* -------------------------------------------- */

	/**
	 * Release control over a PlaceableObject, removing it from the controlled set
	 * @return {Boolean}                A Boolean flag confirming the object was released.
	 */
	release() {
		delete this.layer._controlled[this.id];
		if (!this._controlled) return true;
		this._controlled = false;

		// Conceal any active HUD
		if (this.layer.hud && this.layer.hud.object === this)
			this.layer.hud.clear();

		// Refresh the object display
		this.refresh();

		// Fire an on-release Hook
		Hooks.callAll(
			'control' + this.constructor.name,
			this,
			this._controlled
		);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the placeable object into its parent container
	 * @return {PlaceableObject}    A reference to the drawn object
	 */
	draw() {
		throw new Error(
			'A PlaceableObject subclass must define initial drawing procedure.'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the visual representation of the Placeable Object
	 * @return {PlaceableObject}    A reference to the refreshed object
	 */
	refresh() {
		throw new Error(
			'A PlaceableObject subclass must define an refresh drawing procedure.'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Sort the PlaceableObject to the front of the rendering stack, above all other siblings.
	 * Update the database with the new maximal Z-index
	 */
	sortToFront() {
		const siblings = this.parent.children.filter(
			obj => Number.isFinite(obj.data.z) && obj.id !== this.id
		);
		let z = siblings.length
			? Math.max(...siblings.map(o => o.data.z)) + 1
			: 1;
		this.update({ z: z });
	}

	/* -------------------------------------------- */

	/**
	 * Sort the PlaceableObject to the back of the rendering stack, behind all other siblings.
	 * Update the database with the new minimal Z-index
	 */
	sortToBack() {
		const siblings = this.parent.children.filter(
			obj => Number.isFinite(obj.data.z) && obj.id !== this.id
		);
		let z = siblings.length
			? Math.min(...siblings.map(o => o.data.z)) - 1
			: -1;
		this.update({ z: z });
	}

	/* -------------------------------------------- */

	/**
	 * Shift the display of the PlaceableObject to the top of the rendering stack, above all other siblings
	 */
	displayToFront() {
		this.parent.addChild(this.parent.removeChild(this));
	}

	/* -------------------------------------------- */

	/**
	 * Clone the placeable object, returning a new object with identical attributes
	 * The returned object is non-interactive, and has no assigned ID
	 * If you plan to use it permanently you should call the create method
	 *
	 * @return {PlaceableObject}  A new object with identical data
	 */
	clone() {
		let data = duplicate(this.data);
		data._id = null;
		let clone = new this.constructor(data);
		clone.interactive = false;
		return clone;
	}

	/* -------------------------------------------- */

	/**
	 * Rotate the PlaceableObject to a certain angle of facing
	 * @param {number} angle    The desired angle of rotation
	 * @param {number} snap     Snap the angle of rotation to a certain target degree increment
	 * @return {Promise}        A Promise which resolves once the rotation has completed
	 */
	async rotate(angle, snap) {
		if (this.data.rotation === undefined) return;

		// Determine the new rotation angle
		angle = angle % 360;
		if (Number.isFinite(snap)) angle = Math.round(angle / snap) * snap;

		// Conceal any active hud
		const hud = this.layer.hud;
		if (hud) hud.clear();

		// Update the object
		return this.update({ rotation: angle });
	}

	/* -------------------------------------------- */

	/**
	 * Get the value of a "flag" for this PlaceableObject
	 * See the setFlag method for more details on flags
	 *
	 * @param {String} scope    The flag scope which namespaces the key
	 * @param {String} key      The flag key
	 * @return {*}              The flag value
	 */
	getFlag(scope, key) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `${scope}.${key}`;
		return getProperty(this.data.flags, key);
	}

	/* -------------------------------------------- */

	/**
	 * Assign a "flag" to this Entity.
	 * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either
	 * the core software, game systems, or user-created modules.
	 *
	 * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.
	 *
	 * Flags set by the core software use the "core" scope.
	 * Flags set by game systems or modules should use the canonical name attribute for the module
	 * Flags set by an individual world should "world" as the scope.
	 *
	 * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.
	 *
	 * @param {String} scope    The flag scope which namespaces the key
	 * @param {String} key      The flag key
	 * @param {*} value         The flag value
	 *
	 * @return {Promise}        A Promise resolving to the updated PlaceableObject
	 */
	async setFlag(scope, key, value) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.${key}`;
		return this.update({ [key]: value });
	}

	/* -------------------------------------------- */

	/**
	 * Remove a flag assigned to the Entity
	 * @param {string} scope    The flag scope which namespaces the key
	 * @param {string} key      The flag key
	 * @return {Promise}        A Promise resolving to the updated Entity
	 */
	async unsetFlag(scope, key) {
		const scopes = ['core', game.system.id, 'world'].concat(
			game.modules.map(m => m.id)
		);
		if (!scopes.includes(scope))
			throw new Error(`Invalid scope for flag ${key}`);
		key = `flags.${scope}.-=${key}`;
		return this.update({ [key]: null });
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @extends {Entity.createEmbeddedEntity} */
	static async create(...args) {
		if (typeof args[0] === 'string') {
			// TODO: Remove in 0.5.x
			console.warn(
				'You are passing the sceneId as the first argument to PlaceableObject.create() which is no longer required'
			);
			args.shift();
		}
		return canvas.scene.createEmbeddedEntity(this.name, ...args);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.updateEmbeddedEntity} */
	async update(...args) {
		if (typeof args[0] === 'string') {
			// TODO: Remove in 0.5.x
			console.warn(
				'You are passing the sceneId as the first argument to PlaceableObject.update() which is no longer required'
			);
			args.shift();
		}
		const data = args[0] || {};
		data._id = this.id;
		const options = args[1] || {};
		options.currentData = this.data;
		return this.scene.updateEmbeddedEntity(
			this.constructor.name,
			data,
			options
		);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.deleteEmbeddedEntity} */
	async delete(...args) {
		if (typeof args[0] === 'string') {
			// TODO: Remove in 0.5.x
			console.warn(
				'You are passing the sceneId as the first argument to PlaceableObject.delete() which is no longer required'
			);
			args.shift();
		}
		const options = args.pop() || {};
		return this.scene.deleteEmbeddedEntity(
			this.constructor.name,
			this.id,
			options
		);
	}

	/* -------------------------------------------- */

	/**
	 * Register pending canvas operations which should occur after a new PlaceableObject of this type is created
	 * @private
	 */
	_onCreate() {
		const layer = this.layer;
		canvas.addPendingOperation(
			`${layer.constructor.name}.sortObjects`,
			layer.sortObjects,
			layer
		);
	}

	/* -------------------------------------------- */

	/**
	 * Define additional steps taken when an existing placeable object of this type is updated with new data
	 * @private
	 */
	_onUpdate(data) {
		if (Object.keys(data).includes('z')) {
			const layer = this.layer;
			canvas.addPendingOperation(
				`${layer.constructor.name}.sortObjects`,
				layer.sortObjects,
				layer
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Define additional steps taken when an existing placeable object of this type is deleted
	 * @private
	 */
	_onDelete() {
		this.release();
		const layer = this.layer;
		canvas.addPendingOperation(
			`${layer.constructor.name}.sortObjects`,
			layer.sortObjects,
			layer
		);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle mouse-over events which trigger a hover
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseOver(event) {
		if (this._hover === true) return false;
		const layer = this.layer;

		// Register hover state, and strip that state from sibling objects
		const oe =
			event instanceof PIXI.interaction.InteractionEvent
				? event.data.originalEvent
				: event;
		if (!oe.altKey)
			layer.placeables
				.filter(o => o !== this && o._hover)
				.forEach(o => o._onMouseOut(event));
		this._hover = true;
		layer._hover = this;

		// Refresh object display
		if (this.controlIcon) this.controlIcon.border.visible = true;
		if (this.refresh) this.refresh();

		// Fire an on-hover Hook
		Hooks.callAll('hover' + this.constructor.name, this, this._hover);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out events after a hover
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseOut(event) {
		if (this._hover !== true) return false;

		// Deregister the hover state from this object
		this._hover = false;
		this.layer._hover = null;

		// Refresh object display
		if (this.controlIcon) this.controlIcon.border.visible = false;
		if (this.refresh) this.refresh();

		// Fire an off-hover Hook
		Hooks.callAll('hover' + this.constructor.name, this, this._hover);
	}

	/* -------------------------------------------- */

	/**
	 * Default handling for mouse-move event during a PlaceableObject drag workflow
	 * @param {PIXI.InteractionEvent} event   The mousemove event being handled
	 * @private
	 */
	async _onMouseMove(event) {
		const layer = this.layer;
		const dims = canvas.dimensions;
		let { handleState, origin, clone } = event.data,
			dest = event.data.getLocalPosition(layer),
			dx = dest.x - origin.x,
			dy = dest.y - origin.y;

		// Create the clone container
		if (
			handleState === 0 &&
			Math.hypot(dx, dy) >= dims.size / (layer.gridPrecision * 2)
		) {
			this.data.locked = true;
			event.data.handleState = handleState = 1;
			clone = await this.clone().draw();
			layer.preview.addChild(clone);
			event.data.clone = clone;
			clone.alpha = 0.8;
			this.alpha = 0.4;
		}

		// Update the clone position
		if (handleState > 0) {
			if (!clone) return;
			clone.data.x = this.data.x + dx;
			clone.data.y = this.data.y + dy;
			clone.refresh();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Default handling for Placeable mouse-up event concluding a drag workflow
	 * @private
	 */
	_onMouseUp(event) {
		let { origin, destination, handleState, originalEvent } = event.data;
		if (handleState === 0) return;

		// Update final coordinates
		let dx = destination.x - origin.x,
			dy = destination.y - origin.y;
		let snap = !originalEvent.shiftKey;
		if (snap) {
			destination = canvas.grid.getSnappedPosition(
				this.data.x + dx,
				this.data.y + dy,
				this.layer.gridPrecision
			);
		} else destination = { x: this.data.x + dx, y: this.data.y + dy };

		// Update data
		this.data.locked = false;
		this.update(destination).then(p => this._onDragCancel(event));
	}

	/* -------------------------------------------- */

	/**
	 * Default handling for Placeable double left-click event
	 * @private
	 */
	_onDoubleLeft(event) {
		const sheet = this.sheet;
		if (sheet) sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Default handling for Placeable drag cancel through right-click
	 * @private
	 */
	_onDragCancel(event) {
		this.layer.preview.removeChildren();
		this.data.locked = false;
		this.alpha = 1.0;
	}

	/* -------------------------------------------- */

	/**
	 * Default event-handling logic for a left-mouse click event on the PlaceableObject container
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseDown(event) {
		// Remove active HUD controls
		const hud = this.layer.hud;
		if (hud) hud.clear();

		// Attempt to control the object
		this.control();
	}

	/* -------------------------------------------- */

	/**
	 * Default event-handling logic for a right-mouse click event on the PlaceableObject container
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onRightDown(event) {
		// Display the HUD controls
		const hud = this.layer.hud;
		if (hud) {
			const state = hud._displayState;
			if (
				hud.object === this &&
				state !== hud.constructor.DISPLAY_STATES.NONE
			)
				hud.clear();
			else if (this.owner) hud.bind(this);
		}
	}
}

/**
 * The base PlaceablesLayer subclass of CanvasLayer
 * @type {CanvasLayer}
 */
class PlaceablesLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * Placeable Layer Objects
		 * @type {PIXI.Container}
		 */
		this.objects = null;

		/**
		 * Preview Object Placement
		 */
		this.preview = null;

		/**
		 * Keep track of history so that CTRL+Z can undo changes
		 * @type {Array}
		 */
		this.history = [];

		/**
		 * Track the PlaceableObject on this layer which is currently being hovered upon
		 * @type {PlaceableObject}
		 */
		this._hover = null;

		/**
		 * Track the set of PlaceableObjects on this layer which are currently controlled by their id
		 * @type {Object}
		 */
		this._controlled = {};

		/**
		 * Keep track of an object copied with CTRL+C which can be pasted later
		 * @type {Array}
		 */
		this._copy = [];

		/**
		 * PlaceableObject layer options
		 * @type {Object}
		 */
		this.options = this.constructor.layerOptions;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Customize behaviors of this PlaceablesLayer by modifying some behaviors at a class level
	 * @static
	 * @type {Object}
	 *
	 * @property {boolean} canDragCreate        Does this layer support a mouse-drag workflow to create new objects?
	 * @property {boolean} controllableObjects  Can placeable objects in this layer be controlled?
	 * @property {boolean} rotatableObjects     Can placeable objects in this layer be rotated?
	 * @property {boolean} snapToGrid           Do objects in this layer snap to the grid
	 * @property {number} gridPrecision         At what numeric grid precision do objects snap?
	 */
	static get layerOptions() {
		return {
			canDragCreate: true,
			controllableObjects: false,
			rotatableObjects: false,
			snapToGrid: true,
			gridPrecision: 2,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the active instance of this canvas layer
	 * @static
	 * @type {PlaceablesLayer}
	 */
	static get instance() {
		return canvas.stage.children.find(
			l => l.constructor.name === this.name
		);
	}

	/* -------------------------------------------- */

	/**
	 * Define the named Array within Scene.data containing the placeable objects displayed in this layer
	 * @static
	 * @type {String}
	 */
	static get dataArray() {
		throw new Error(
			'A PlaceablesLayer subclass must define the array of placeable object data it contains'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Define a Container implementation used to render placeable objects contained in this layer
	 * @static
	 * @type {PIXI.Container}
	 */
	static get placeableClass() {
		throw new Error(
			'A PlaceablesLayer subclass must define the Container implementation used to display placeables.'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Return the precision relative to the Scene grid with which Placeable objects should be snapped
	 * @return {number}
	 */
	get gridPrecision() {
		return this.constructor.layerOptions.gridPrecision;
	}

	/* -------------------------------------------- */

	/**
	 * If objects on this PlaceableLayer have a HUD UI, provide a reference to its instance
	 * @type {BasePlaceableHUD|null}
	 */
	get hud() {
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience method for accessing the placeable object instances contained in this layer
	 * @type {Array}
	 */
	get placeables() {
		if (!this.objects) return [];
		return this.objects.children;
	}

	/* -------------------------------------------- */

	/**
	 * An Array of placeable objects in this layer which have the _controlled attribute
	 * @return {Array.<PlaceableObject>}
	 */
	get controlled() {
		return Object.values(this._controlled);
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the PlaceablesLayer.
	 * Draw each Sound within the scene as a child of the sounds container.
	 */
	async draw() {
		await super.draw();

		// Reset history
		this.history = [];

		// Create objects container
		this.objects = this.addChild(new PIXI.Container());

		// Create preview container
		this.preview = this.addChild(new PIXI.Container());

		// Create and draw objects
		for (let data of canvas.scene.data[this.constructor.dataArray]) {
			await this.createObject(data);
		}

		// Sort and control objects
		this.sortObjects();
		if (this.options.controllableObjects) {
			const controlledIds = Object.keys(this._controlled);
			this._controlled = {};
			controlledIds.forEach(id =>
				this.get(id).control({ releaseOthers: false })
			);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a single placeable object
	 * @return {PlaceableObject}
	 */
	createObject(data) {
		const obj = new this.constructor.placeableClass(data, canvas.scene);
		obj.draw();
		this.objects.addChild(obj);
		return obj;
	}

	/* -------------------------------------------- */

	/**
	 * Reorder the child objects of the layer according to their z-index (if one exists)
	 */
	sortObjects() {
		this.objects.children.sort((a, b) => {
			let s = a.data.z - b.data.z;
			return Number.isNaN(s) ? 1 : s;
		});
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Override the activation behavior of the PlaceablesLayer.
	 * While active, ambient sound previews are displayed.
	 */
	activate() {
		super.activate();
		if (this.objects) this.objects.visible = true;
	}

	/* -------------------------------------------- */

	/**
	 * Override the deactivation behavior of the PlaceablesLayer.
	 * When inactive, ambient sound previews are hidden from view.
	 */
	deactivate() {
		super.deactivate();
		this.releaseAll();
		if (this.objects) this.objects.visible = false;
		if (this.preview) this.preview.removeChildren();
	}

	/* -------------------------------------------- */

	/**
	 * Get a PlaceableObject contained in this layer by it's ID
	 * @param {string} objectId   The ID of the contained object to retrieve
	 * @return {PlaceableObject}  The object instance, or undefined
	 */
	get(objectId) {
		return this.placeables.find(t => t.id === objectId);
	}

	/* -------------------------------------------- */

	/**
	 * Release all controlled PlaceableObject instance from this layer.
	 * @param {Object} options    Additional options which customize the Object releasing behavior
	 * @return {Number}           The number of PlaceableObject instances which were released
	 */
	releaseAll(options) {
		const controlled = this.placeables.filter(t => t._controlled);
		controlled.forEach(obj => obj.release(options));
		return controlled.length;
	}

	/* -------------------------------------------- */

	/**
   * Simultaneously rotate multiple PlaceableObjects using a provided angle or incremental.
   * This executes a single database operation using Scene.update.
   * If rotating only a single object, it is better to use the PlaceableObject.rotate instance method.

   * @param {Number} angle      A target angle of rotation (in degrees) where zero faces "south"
   * @param {Number} delta      An incremental angle of rotation (in degrees)
   * @param {Number} snap       Snap the resulting angle to a multiple of some increment (in degrees)      
   * @param {Array|Set} ids     An Array or Set of object IDs to target for rotation

   * @return {Promise}          The resulting Promise from the Scene.update operation
   */
	async rotateMany({
		angle = null,
		delta = null,
		snap = null,
		ids = null,
	} = {}) {
		if (
			!this.constructor.layerOptions.rotatableObjects ||
			(game.paused && !game.user.isGM)
		)
			return;
		if (angle === null && delta === null) {
			throw new Error(
				'Either a target angle or incremental delta must be provided.'
			);
		}

		// Determine the set of rotatable object IDs unless some were explicitly provided
		ids =
			ids !== null
				? Array.from(ids)
				: this.controlled.filter(o => !o.data.locked).map(o => o.id);
		if (!ids.length) return;

		// Conceal any active HUD
		const hud = this.hud;
		if (hud) hud.clear();

		// Construct updated object data Array
		const updateData = ids.map(id => {
			const obj = this.get(id);
			let degrees = angle ? angle : obj.data.rotation + delta;
			if (snap) degrees = Math.round(degrees / snap) * snap;
			return { _id: id, rotation: degrees % 360 };
		});

		// Call the updateMany method
		return this.updateMany(updateData);
	}

	/* -------------------------------------------- */

	/**
	 * Simultaneously move multiple PlaceableObjects via keyboard movement offsets.
	 * This executes a single database operation using Scene.update.
	 * If moving only a single object, this will delegate to PlaceableObject.update for performance reasons.
	 *
	 * @param {Number} dx         The number of incremental grid units in the horizontal direction
	 * @param {Number} dy         The number of incremental grid units in the vertical direction
	 * @param {Boolean} rotate    Rotate the token to the keyboard direction instead of moving
	 * @param {Array|Set} ids     An Array or Set of object IDs to target for rotation
	 *
	 * @return {Promise}          The resulting Promise from the Scene.update operation
	 */
	async moveMany({ dx = 0, dy = 0, rotate = false, ids = null } = {}) {
		if ((game.paused && !game.user.isGM) || (!dx && !dy)) return;

		// Determine the set of movable object IDs unless some were explicitly provided
		ids =
			ids !== null
				? Array.from(ids)
				: this.controlled.filter(o => !o.data.locked).map(o => o.id);
		if (!ids.length) return;

		// Determine the rotation angle
		let offsets = [dx, dy];
		let angle = 0;
		if (rotate) {
			if (offsets.equals([0, 1])) angle = 0;
			else if (offsets.equals([-1, 1])) angle = 45;
			else if (offsets.equals([-1, 0])) angle = 90;
			else if (offsets.equals([-1, -1])) angle = 135;
			else if (offsets.equals([0, -1])) angle = 180;
			else if (offsets.equals([1, -1])) angle = 225;
			else if (offsets.equals([1, 0])) angle = 270;
			else if (offsets.equals([1, 1])) angle = 315;
		}

		// Conceal any active HUD
		const hud = this.hud;
		if (hud) hud.clear();

		// Construct the update Array
		const updateData = ids.map(id => {
			let update = { _id: id };
			if (rotate) update.rotation = angle;
			else {
				let obj = this.get(id);
				mergeObject(update, obj._getShiftedPosition(...offsets));
			}
			return update;
		});

		// Call the updateMany method
		return this.updateMany(updateData, {
			updateKeys: rotate ? ['rotation'] : ['x', 'y'],
		});
	}

	/* -------------------------------------------- */

	/**
	 * Undo a change to the objects in this layer
	 * This method is typically activated using CTRL+Z while the layer is active
	 * @return {Promise}
	 */
	async undoHistory() {
		if (!this.history.length)
			return Promise.reject('No more tracked history to undo!');
		let event = this.history.pop();
		const cls = this.constructor.placeableClass;

		// Undo creation
		if (event.type === 'create') {
			let obj = this.get(event.data._id);
			if (obj)
				return obj
					.delete({ isUndo: true })
					.then(() => this.history.pop());
		} else if (event.type === 'createMany') {
			return this.deleteMany(
				event.data.map(d => d._id),
				{ isUndo: true }
			);
		}

		// Undo updates
		else if (event.type === 'update') {
			let obj = this.get(event.data._id);
			if (obj)
				return obj
					.update(event.data, { isUndo: true })
					.then(() => this.history.pop());
		} else if (event.type === 'updateMany') {
			return this.updateMany(event.data, { isUndo: true });
		}

		// Undo deletion
		else if (event.type === 'delete') {
			return cls
				.create(event.data, { isUndo: true })
				.then(() => this.history.pop());
		} else if (event.type === 'deleteMany') {
			return this.createMany(event.data, { isUndo: true }).then(() =>
				this.history.pop()
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Create multiple embedded entities in a parent Entity collection using an Array of provided data
	 *
	 * @param {Array} data          An Array of update data Objects which provide incremental data
	 * @param {Object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise}            A Promise which resolves to the returned socket response (if successful)
	 */
	async createMany(data, options = {}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.createManyEmbeddedEntities(
			embeddedName,
			data,
			options
		);
	}

	/* -------------------------------------------- */

	/**
	 * Update multiple embedded entities in a parent Entity collection using an Array of provided data
	 *
	 * @param {Array} data          An Array of update data Objects which provide incremental data
	 * @param {Object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise}            A Promise which resolves to the returned socket response (if successful)
	 */
	async updateMany(data, options = {}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.updateManyEmbeddedEntities(
			embeddedName,
			data,
			options
		);
	}

	/* -------------------------------------------- */

	/**
	 * Simultaneously delete multiple PlaceableObjects.
	 * This executes a single database operation using Scene.update.
	 * If deleting only a single object, this will delegate to PlaceableObject.delete for performance reasons.
	 *
	 * @param {Array} ids           An Array of object IDs to target for deletion
	 * @param {Object} options      Additional options which customize the update workflow
	 *
	 * @return {Promise}            A Promise which resolves to the returned socket response (if successful)
	 */
	async deleteMany(ids, options = {}) {
		const embeddedName = this.constructor.placeableClass.name;
		return canvas.scene.deleteManyEmbeddedEntities(
			embeddedName,
			ids,
			options
		);
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to prompt for deletion of all PlaceableObject instances within the Scene
	 * Renders a confirmation dialogue to confirm with the requester that all objects will be deleted
	 */
	deleteAll() {
		const cls = this.constructor.placeableClass;
		if (!game.user.isGM) {
			throw new Error(
				`You do not have permission to delete ${cls.name} placeables from the Scene.`
			);
		}
		new Dialog({
			title: 'Clear All Objects',
			content: `<p>Clear all ${cls.name} objects from this Scene?</p>`,
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: 'Yes',
					callback: () =>
						this.deleteMany(
							this.placeables.map(o => o.id),
							{}
						),
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: 'No',
				},
			},
			default: 'yes',
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Record a new CRUD event in the history log so that it can be undone later
	 * @param {String} type   The event type (create, update, delete)
	 * @param {Object} data   The object data
	 * @private
	 */
	storeHistory(type, data) {
		if (this.history.length >= 10) this.history.shift();
		this.history.push({ type, data });
	}

	/* -------------------------------------------- */

	/**
	 * Copy currently controlled PlaceableObjects to a temporary Array, ready to paste back into the scene later
	 * @returns {Array}   The Array of copied Objects
	 */
	copyObjects() {
		if (this.options.controllableObjects)
			this._copy = Array.from(this.controlled);
		else if (this._hover) this._copy = [this._hover];
		else this._copy = [];
		const cn = this.constructor.placeableClass.name;
		ui.notifications.info(
			`Copied data for ${this._copy.length} ${cn} objects.`
		);
		return this._copy;
	}

	/* -------------------------------------------- */

	/**
	 * Paste currently copied PlaceableObjects back to the layer by creating new copies
	 * @return {Promise.<Array>}      An Array of created Objects
	 */
	async pasteObjects(position, { hidden = false } = {}) {
		if (!this._copy.length) return;
		const cls = this.constructor.placeableClass;

		// Adjust the pasted position for half a grid space
		position.x -= canvas.dimensions.size / 2;
		position.y -= canvas.dimensions.size / 2;

		// Get the left-most object in the set
		this._copy.sort((a, b) => a.data.x - b.data.x);
		let { x, y } = this._copy[0].data;

		// Iterate over objects
		const toCreate = [];
		for (let c of this._copy) {
			let data = duplicate(c.data);
			let snapped = canvas.grid.getSnappedPosition(
				position.x + (data.x - x),
				position.y + (data.y - y),
				1
			);
			delete data._id;
			toCreate.push(
				mergeObject(data, {
					x: snapped.x,
					y: snapped.y,
					hidden: data.hidden || hidden,
				})
			);
		}

		// Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);

		// Create all objects
		for (let o of toCreate) {
			await cls.create(canvas.scene._id, o);
		}
		ui.notifications.info(
			`Pasted data for ${toCreate.length} ${cls.name} objects.`
		);
		return toCreate;
	}

	/* -------------------------------------------- */

	/**
	 * Select all PlaceableObject instances which fall within a coordinate rectangle.
	 *
	 * @param {Number} x      The top-left x-coordinate of the selection rectangle
	 * @param {Number} y      The top-left y-coordinate of the selection rectangle
	 * @param {Number} width  The width of the selection rectangle
	 * @param {Number} height The height of the selection rectangle
	 * @param {Object} releaseOptions   Optional arguments provided to any called release() method
	 * @param {Object} controlOptions   Optional arguments provided to any called control() method
	 * @return {Number}       The number of PlaceableObject instances which were controlled.
	 */
	selectObjects({
		x,
		y,
		width,
		height,
		releaseOptions = {},
		controlOptions = {},
	}) {
		const oldSet = Object.values(this._controlled);
		const controllable = this.placeables.filter(
			obj => obj.visible && obj.control instanceof Function
		);
		const newSet = controllable.filter(obj => {
			let c = obj.center;
			return (
				Number.between(c.x, x, x + width) &&
				Number.between(c.y, y, y + height)
			);
		});

		// Release or Control objects
		oldSet
			.filter(obj => !newSet.includes(obj))
			.forEach(obj => obj.release(releaseOptions));
		if (isObjectEmpty(controlOptions)) controlOptions.releaseOthers = false;
		newSet
			.filter(obj => !oldSet.includes(obj))
			.forEach(obj => obj.control(controlOptions));

		// Return the number of selected objects
		return controllable.length;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Default mouse-down event handling implementation
	 * @private
	 */
	_onMouseDown(event, { isRuler, isCtrlRuler, isSelect } = {}) {
		// Clear active HUD
		if (this.hud) this.hud.clear();

		// Release controlled objects
		if ([isRuler, isCtrlRuler, isSelect].includes(true)) return;
		this.releaseAll();

		// Perhaps begin a drag-creation workflow
		if (this.options.canDragCreate) {
			event.stopPropagation();
			if (event.data.createState > 0) return;
			event.data.createState = 0;
			this._onDragStart(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of drag start events by left click + dragging
	 * @private
	 */
	_onDragStart(event) {
		event.stopPropagation();

		// Identify the origin point
		let origin = event.data.getLocalPosition(this);
		if (this.options.snapToGrid) {
			origin = canvas.grid.getSnappedPosition(
				origin.x,
				origin.y,
				this.gridPrecision
			);
		}
		event.data.origin = origin;

		// Remove any existing preview
		if (this.preview) this.preview.removeChildren();

		// Listen for cancellation
		canvas.app.view.oncontextmenu = () => this._onDragCancel(event);

		// Register event state
		event.data.createState = 1;
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of mouse move events during a dragging workflow
	 * @private
	 */
	_onMouseMove(event) {
		if (event.data.createState >= 1) {
			event.stopPropagation();
			event.data.destination = event.data.getLocalPosition(this);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of drag cancel events by right clicking during a drag creation
	 * @private
	 */
	_onDragCancel(event) {
		if (this.preview) this.preview.removeChildren();
		this.off('mousemove', this._onMouseMove);
		canvas.app.view.oncontextmenu = null;
		event.data.createState = 0;
		event.data.object = null;
	}

	/* -------------------------------------------- */

	/**
	 * Handle successful creation of an object through the drag creation workflow.
	 * This logic requires that the drag exceeded some minimum distance for the new object to be created.
	 * @private
	 */
	_onDragCreate(event) {
		let distance = Math.hypot(
			event.data.destination.x - event.data.origin.x,
			event.data.destination.y - event.data.origin.y
		);
		if (distance >= canvas.dimensions.size / 2) {
			this.constructor.placeableClass.create(
				canvas.scene._id,
				event.data.object.data
			);
		}
		this._onDragCancel(event);
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of mouse-up events which conclude a new object creation after dragging
	 * @private
	 */
	_onMouseUp(event) {
		const cs = event.data.createState;
		if (cs === 2) {
			event.stopPropagation();
			this._onDragCreate(event);
			event.data.createState = 0;
		} else if (cs === 1) {
			event.stopPropagation();
			this._onDragCancel(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-wheel events at the PlaceableObjects layer level to rotate multiple objects at once.
	 * This handler will rotate all controlled objects by some incremental angle.
	 * @param {Event} event   The mousewheel event which originated the request
	 * @private
	 */
	_onMouseWheel(event) {
		// Prevent wheel rotation for non-GM users if the game is paused
		if (game.paused && !game.user.isGM) return;

		// Rate limit PlaceableObject rotation since it triggers a database update
		let t = Date.now();
		let dt = t - (keyboard._wheelTime || 0);
		if (dt < keyboard.constructor.MOUSE_WHEEL_RATE_LIMIT) return;
		keyboard._wheelTime = t;

		// Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 45 : 15;
		let delta = snap * Math.sign(event.deltaY);

		// Call the rotateMany method to handle the request
		return this.rotateMany({ delta, snap });
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse-click events which occur while this layer is active
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onRightDown(event) {
		if (this.hud) this.hud.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a DELETE keypress while a placeable object is hovered
	 * @param {Event} event    The delete key press event which triggered the request
	 * @private
	 */
	async _onDeleteKey(event) {
		let ids = null;
		if (this.options.controllableObjects)
			ids = this.controlled.map(obj => obj.id);
		else ids = this._hover ? [this._hover.id] : [];
		if (!ids.length) return;
		return canvas.activeLayer.deleteMany(ids);
	}
}

jQuery.fn.shake = function(shakes, distance, duration) {
	if (shakes > 0) {
		this.each(function() {
			let $el = $(this);
			let left = $el.css('left');
			$el.animate({ left: '-=' + distance }, duration, function() {
				$el.animate(
					{ left: '+=' + distance * 2 },
					duration,
					function() {
						$el.animate({ left: left }, duration, function() {
							$el.shake(shakes - 1, distance, duration);
						});
					}
				);
			});
		});
	}
	return this;
};

/**
 * Display a right-click activated Context Menu which provides a dropdown menu of options
 * A ContextMenu is constructed by designating a parent HTML container and a target selector
 * An Array of menuItems defines the entries of the menu which is displayed
 *
 * @param {HTMLElement|jQuery} element    The containing HTML element within which the menu is positioned
 * @param {String} selector               A CSS selector which activates the context menu.
 * @param {Array} menuItems               An Array of entries to display in the menu
 * @param {String} eventName              Optionally override the triggering event which can spawn the menu
 *
 * @param {Object} menuItem               Menu items in the array can have the following properties
 * @param {String} menuItem.name          The displayed item name
 * @param {String} menuItem.icon          An icon glyph HTML string
 * @param {Function} menuItem.condition   A function which returns a Boolean for whether or not to display the item
 * @param {Function} menuItem.callback    A callback function to trigger when the entry of the menu is clicked
 */
class ContextMenu {
	constructor(
		element,
		selector,
		menuItems,
		{ eventName = 'contextmenu' } = {}
	) {
		/**
		 * The target HTMLElement being selected
		 * @type {HTMLElement}
		 */
		this.element = element;

		/**
		 * The target CSS selector which activates the menu
		 * @type {String}
		 */
		this.selector = selector || element.attr('id');

		/**
		 * An interaction event name which activates the menu
		 * @type {String}
		 */
		this.eventName = eventName;

		/**
		 * The array of menu items being rendered
		 * @type {Array}
		 */
		this.menuItems = menuItems;

		/**
		 * Track which direction the menu is expanded in
		 * @type {Boolean}
		 */
		this._expandUp = false;

		// Bind to the current element
		this.bind();
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor to the context menu HTML object
	 * @return {*|jQuery.fn.init|jQuery|HTMLElement}
	 */
	get menu() {
		return $('#context-menu');
	}

	/* -------------------------------------------- */

	/**
	 * Attach a ContextMenu instance to an HTML selector
	 */
	bind() {
		this.element.on(this.eventName, this.selector, event => {
			event.preventDefault();
			let parent = $(event.currentTarget),
				menu = this.menu;

			// Remove existing context UI
			$('.context').removeClass('context');

			// Close the current context
			if ($.contains(parent[0], menu[0])) this.close();
			// If the new target element is different
			else {
				this.render(parent);
				ui.context = this;
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Animate closing the menu by sliding up and removing from the DOM
	 */
	async close() {
		let menu = this.menu;
		await this._animateClose(menu);
		menu.remove();
		$('.context').removeClass('context');
		delete ui.context;
	}

	/* -------------------------------------------- */

	async _animateOpen(menu) {
		menu.hide();
		return new Promise(resolve => menu.slideDown(200, resolve));
	}

	/* -------------------------------------------- */

	async _animateClose(menu) {
		return new Promise(resolve => menu.slideUp(200, resolve));
	}

	/* -------------------------------------------- */

	/**
	 * Render the Context Menu by iterating over the menuItems it contains
	 * Check the visibility of each menu item, and only render ones which are allowed by the item's logical condition
	 * Attach a click handler to each item which is rendered
	 * @param target
	 */
	render(target) {
		let html = $('#context-menu').length
			? $('#context-menu')
			: $('<nav id="context-menu"></nav>');
		let ol = $('<ol class="context-items"></ol>');
		html.html(ol);

		// Build menu items
		for (let item of this.menuItems) {
			// Determine menu item visibility (display unless false)
			let display = true;
			if (item.condition !== undefined) {
				display =
					item.condition instanceof Function
						? item.condition(target)
						: item.condition;
			}
			if (!display) continue;

			// Construct and add the menu item
			let name = game.i18n.localize(item.name);
			let li = $(`<li class="context-item">${item.icon}${name}</li>`);
			li.children('i').addClass('fa-fw');
			li.click(e => {
				e.preventDefault();
				e.stopPropagation();
				item.callback(target);
				this.close();
			});
			ol.append(li);
		}

		// Bail out if there are no children
		if (ol.children().length === 0) return;

		// Append to target
		this._setPosition(html, target);

		// Animate open the menu
		return this._animateOpen(html);
	}

	/* -------------------------------------------- */

	_setPosition(html, target) {
		const targetRect = target[0].getBoundingClientRect();

		// Append to target and get the context bounds
		target.css('position', 'relative');
		html.css('visibility', 'hidden');
		target.append(html);
		const contextRect = html[0].getBoundingClientRect();

		// Determine whether to expand down or expand up
		this._expandUp =
			window.innerHeight - targetRect.bottom - contextRect.height - 20 <
			0;

		// Display the menu
		html.addClass(this._expandUp ? 'expand-up' : 'expand-down');
		html.css('visibility', '');
		target.addClass('context');
	}

	/* -------------------------------------------- */

	static eventListeners() {
		document.addEventListener('click', ev => {
			if (ui.context) ui.context.close();
		});
	}
}

/* -------------------------------------------- */

/**
 * Create a modal dialog window displaying a title, a message, and a set of buttons which trigger callback functions.
 * @type {Application}
 *
 * @param dialogData {Object}           An object of dialog data which configures how the modal window is rendered
 * @param dialogData.title {String}     The window title
 * @param dialogData.content {String}   HTML content
 * @param dialogData.close {Function}   Common callback operations to perform when the dialog is closed
 * @param dialogData.buttons {Object}   Action buttons which trigger callback functions.
 *                                      Buttons are defined as an Object with the format ``{name: buttonData}``.
 *                                      Valid keys for buttonData include:
 *
 * @param dialogData.buttons.button.icon {String} A button icon
 * @param dialogData.buttons.button.label {String} A button label
 * @param dialogData.buttons.button.callback {Function} A callback function taking no arguments
 *
 * @param options {Object}              Dialog rendering options, see :class:`Application`
 * @param options.default               The name of the default button which should be triggered on Enter
 *
 * @example
 * let d = new Dialog({
 *  title: "Test Dialog",
 *  content: "<p>You must choose either Option 1, or Option 2</p>",
 *  buttons: {
 *   one: {
 *    icon: '<i class="fas fa-check"></i>',
 *    label: "Option One",
 *    callback: () => console.log("Chose One")
 *   },
 *   two: {
 *    icon: '<i class="fas fa-times"></i>',
 *    label: "Option Two",
 *    callback: () => console.log("Chose Two")
 *   }
 *  },
 *  default: "two",
 *  close: () => console.log("This always is logged no matter which option is chosen")
 * });
 * d.render(true);
 */
class Dialog extends Application {
	constructor(dialogData, options) {
		super(options);
		this.data = dialogData;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			template: 'templates/hud/dialog.html',
			classes: ['dialog'],
			width: 400,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return this.data.title || 'Dialog';
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		let buttons = Object.keys(this.data.buttons).reduce((obj, key) => {
			let b = this.data.buttons[key];
			if (b.condition !== false) obj[key] = b;
			return obj;
		}, {});
		return {
			content: this.data.content,
			buttons: buttons,
		};
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		html.find('.dialog-button').click(ev => {
			let id = ev.currentTarget.getAttribute('data-button'),
				button = this.data.buttons[id];
			this._submit(button, html);
		});

		// Default choice selection
		$(document).on('keydown.chooseDefault', ev => {
			if (ev.keyCode === KEYS.ENTER && this.data.default) {
				ev.preventDefault();
				this._submit(this.data.buttons[this.data.default], html);
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Submit the Dialog by selecting one of its buttons
	 * @param {Object} button     The configuration of the chosen button
	 * @param {HTMLElement }html  The button HTML element
	 * @private
	 */
	_submit(button, html) {
		try {
			if (button.callback) button.callback(html);
			this.close();
		} catch (err) {
			ui.notifications.error(err);
			throw new Error(err);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	close() {
		if (this.data.close) this.data.close(this.element);
		super.close();
		$(document).off('keydown.chooseDefault');
	}

	/* -------------------------------------------- */

	/**
	 * A helper factory method to create simple confirmation dialog windows which consist of simple yes/no prompts.
	 * If you require more flexibility, a custom Dialog instance is preferred.
	 *
	 * @param {string} title          The confirmation window title
	 * @param {string} content        The confirmation message
	 * @param {Function} yes          Callback function upon yes
	 * @param {Function} no           Callback function upon no
	 * @param {boolean} defaultYes    Make "yes" the default choice?
	 * @param {Object} options        Additional rendering options passed to the Dialog
	 *
	 * @return {Promise}              A promise which resolves once the user makes a choice or closes the window
	 */
	static async confirm(
		{ title, content, yes, no, defaultYes = true } = {},
		options = {}
	) {
		return new Promise(resolve => {
			const dialog = new this(
				{
					title: title,
					content: content,
					buttons: {
						yes: {
							icon: '<i class="fas fa-check"></i>',
							label: game.i18n.localize('Yes'),
							callback: yes,
						},
						no: {
							icon: '<i class="fas fa-times"></i>',
							label: game.i18n.localize('No'),
							callback: no,
						},
					},
					default: defaultYes ? 'yes' : 'no',
					close: resolve,
				},
				options
			);
			dialog.render(true);
		});
	}
}

/* -------------------------------------------- */

/**
 * @see {@link Dialog.confirm}
 * @deprecated since 0.4.4
 */
confirmDialog = async function(...args) {
	console.warn(
		`The confirmDialog() global method which is moved to a static factory method Dialog.confirm()`
	);
	return Dialog.confirm(...args);
};

/**
 * A UI utility to make an element draggable.
 */
class Draggable {
	constructor(app, element, handle, resizable) {
		// Setup element data
		this.app = app;
		this.element = element[0];
		this.handle = handle || this.element;

		/**
		 * Duplicate the application's starting position to track differences
		 * @type {Object}
		 */
		this.position = null;

		/**
		 * Remember event handlers associated with this Draggable class so they may be later unregistered
		 * @type {Object}
		 */
		this.handlers = {};

		// Initialize draggable state
		this._initializeDrag();

		// Initialize resiable state
		if (resizable) this._initializeResize();
	}

	/* ----------------------------------------- */

	_initializeDrag() {
		// Register handlers
		this.handlers['dragDown'] = [
			'mousedown',
			e => this._onDragMouseDown(e),
			false,
		];
		this.handlers['dragMove'] = [
			'mousemove',
			e => this._onDragMouseMove(e),
			false,
		];
		this.handlers['dragUp'] = [
			'mouseup',
			e => this._onDragMouseUp(e),
			false,
		];

		// Attach the click handler and CSS class
		this.handle.addEventListener(...this.handlers.dragDown);
		this.handle.classList.add('draggable');
	}

	/* ----------------------------------------- */

	_initializeResize() {
		// Create the handle;
		let handle = $(
			'<div class="window-resizable-handle"><i class="fas fa-arrows-alt-h"></i></div>'
		)[0];
		this.element.appendChild(handle);

		// Register handlers
		this.handlers['resizeDown'] = [
			'mousedown',
			e => this._onResizeMouseDown(e),
			false,
		];
		this.handlers['resizeMove'] = [
			'mousemove',
			e => this._onResizeMouseMove(e),
			false,
		];
		this.handlers['resizeUp'] = [
			'mouseup',
			e => this._onResizeMouseUp(e),
			false,
		];

		// Attach the click handler and CSS class
		handle.addEventListener(...this.handlers.resizeDown);
		this.handle.classList.add('resizable');
	}

	/* ----------------------------------------- */

	/**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onDragMouseDown(event) {
		event.preventDefault();

		// Float the window to a higher z-index
		this._floatToTop();

		// Record initial position
		this.position = duplicate(this.app.position);
		this._initial = { x: event.clientX, y: event.clientY };

		// Add temporary handlers
		window.addEventListener(...this.handlers.dragMove);
		window.addEventListener(...this.handlers.dragUp);
	}

	/* ----------------------------------------- */

	/**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onDragMouseMove(event) {
		event.preventDefault();
		this.app.setPosition({
			left: this.position.left + (event.clientX - this._initial.x),
			top: this.position.top + (event.clientY - this._initial.y),
		});
	}

	/* ----------------------------------------- */

	/**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onDragMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.dragMove);
		window.removeEventListener(...this.handlers.dragUp);
	}

	/* ----------------------------------------- */

	/**
	 * Handle the initial mouse click which activates dragging behavior for the application
	 * @private
	 */
	_onResizeMouseDown(event) {
		event.preventDefault();

		// Float the window to a higher z-index
		this._floatToTop();

		// Record initial position
		this.position = duplicate(this.app.position);
		if (this.position.height === 'auto')
			this.position.height = this.element.clientHeight;
		if (this.position.width === 'auto')
			this.position.width = this.element.clientWidth;
		this._initial = { x: event.clientX, y: event.clientY };

		// Add temporary handlers
		window.addEventListener(...this.handlers.resizeMove);
		window.addEventListener(...this.handlers.resizeUp);
	}

	/* ----------------------------------------- */

	/**
	 * Move the window with the mouse, bounding the movement to ensure the window stays within bounds of the viewport
	 * @private
	 */
	_onResizeMouseMove(event) {
		event.preventDefault();
		this.app.setPosition({
			width: this.position.width + (event.clientX - this._initial.x),
			height: this.position.height + (event.clientY - this._initial.y),
		});
	}

	/* ----------------------------------------- */

	/**
	 * Conclude the dragging behavior when the mouse is release, setting the final position and removing listeners
	 * @private
	 */
	_onResizeMouseUp(event) {
		event.preventDefault();
		window.removeEventListener(...this.handlers.resizeMove);
		window.removeEventListener(...this.handlers.resizeUp);
		this.app._onResize(event);
	}

	/* ----------------------------------------- */

	_floatToTop() {
		let z = Number(
			window.document.defaultView.getComputedStyle(this.element).zIndex
		);
		if (z <= _maxZ) {
			this.element.style.zIndex = ++_maxZ;
		}
	}
}
/**
 * A collection of helper functions and utility methods related to the rich text editor
 */
class TextEditor {
	/**
	 * Create a Rich Text Editor. The current implementation uses TinyMCE
	 * @param {Object} options          Configuration options provided to the Editor init
	 * @param {string} content          Initial HTML or text content to populate the editor with
	 * @return {tinyMCE.Editor}         The editor instance.
	 */
	static create(options, content) {
		let defaultOptions = {
			branding: false,
			menubar: false,
			statusbar: false,
			plugins: CONFIG.TinyMCE.plugins,
			toolbar: CONFIG.TinyMCE.toolbar,
			content_css: CONFIG.TinyMCE.css.join(','),
			save_enablewhendirty: true,
			table_default_styles: {},

			// Style Dropdown Formats
			style_formats: [
				{
					title: 'Custom',
					items: [
						{
							title: 'Secret',
							block: 'section',
							classes: 'secret',
							wrapper: true,
						},
					],
				},
			],
			style_formats_merge: true,

			// Bind callback events
			init_instance_callback: editor => {
				const window = editor.getWin();

				// Set initial content
				if (content) editor.setContent(content);

				// Prevent window zooming
				window.addEventListener(
					'wheel',
					event => {
						if (event.ctrlKey) event.preventDefault();
					},
					{ passive: false }
				);

				// Handle dropped Entity data
				window.addEventListener('drop', ev =>
					this._onDropEditorData(ev, editor)
				);
			},
		};

		const mceConfig = mergeObject(defaultOptions, options);
		mceConfig.target = options.target;
		return tinyMCE.init(mceConfig);
	}

	/* -------------------------------------------- */

	/**
	 * Enrich HTML content by replacing or augmenting components of it
	 * @param {String} content        The original HTML content (as a string)
	 * @param {Boolean} secrets       Remove secret tags?
	 * @param {Boolean} entities      Replace dynamic entity links?
	 * @param {Boolean} links         Replace hyperlink content?
	 * @return {String}               The enriched HTML content
	 */
	static enrichHTML(
		content,
		{ secrets = false, entities = true, links = true } = {}
	) {
		let html = document.createElement('div');
		html.innerHTML = content;

		// Strip secrets
		if (!secrets) {
			let elements = html.querySelectorAll('section.secret');
			elements.forEach(e => e.parentNode.removeChild(e));
		}

		// Match content links
		if (entities) {
			const entityTypes = CONST.ENTITY_LINK_TYPES.concat('Compendium');
			const entityMatchRgx = `@(${entityTypes.join(
				'|'
			)})\\[([^\\]]+)\\](?:{([^}]+)})?`;
			const rgx = new RegExp(entityMatchRgx, 'g');

			// Find and preload compendium indices
			const matches = Array.from(html.innerHTML.matchAll(rgx));
			if (matches.length) this._preloadCompendiumIndices(matches);

			// Replace content links
			html.innerHTML = html.innerHTML.replace(
				rgx,
				this._replaceContentLinks.bind(this)
			);
		}

		// Replace hyperlinks
		if (links) {
			let rgx = /(?:[^\S]|^)((?:(?:https?:\/\/)|(?:www\.))(?:\S+))/gi;
			html.innerHTML = html.innerHTML.replace(
				rgx,
				this._replaceHyperlinks
			);
		}

		return html.innerHTML;
	}

	/* -------------------------------------------- */

	/**
	 * If dynamic content links are used from a certain compendium, we will go ahead and preload the index for that
	 * Compendium pack in the background so the links can function better.
	 * @private
	 */
	static async _preloadCompendiumIndices(matches) {
		const collections = new Set([]);
		for (let m of matches) {
			if (m[1] !== 'Compendium') continue;
			collections.add(
				m[2]
					.split('.')
					.slice(0, 2)
					.join('.')
			);
		}
		for (let c of collections) {
			const pack = game.packs.find(p => p.collection === c);
			if (pack && !pack.index.length) pack.getIndex();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle replacement of content links within HTML by delegating to different helper methods based on entity type
	 * @private
	 */
	static _replaceContentLinks(match, entityType, id, name) {
		// Match Compendium content
		if (entityType === 'Compendium') {
			return this._replaceCompendiumLink(match, id, name);
		}

		// Match World content
		else {
			return this._replaceEntityLink(match, entityType, id, name);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Replace a matched Entity Link with an actual HTML link to that entity
	 * Be failure-tolerant, allowing for the possibility that the entity does not exist
	 * @param {string} match        The full matched string
	 * @param {string} id           The Entity ID or name
	 * @param {name} name           A custom text name to display
	 * @return {string}             The replacement string
	 */
	static _replaceCompendiumLink(match, id, name) {
		const [scope, packName, target] = id.split('.');
		const pack = game.packs.find(
			p => p.collection === `${scope}.${packName}`
		);
		if (!pack) return match;
		const config = CONFIG[pack.metadata.entity];
		let icon = config.sidebarIcon;

		// Case 1 - the pack Index is already queried
		let entry = null;
		if (pack.index.length) {
			entry = pack.index.find(i => i.id === target || i.name === target);
			if (entry) {
				name = name || entry.name;
				return `<a class="entity-link" data-pack=${pack.collection} data-id="${entry.id}" draggable="true"><i class="${icon}"></i> ${name}</a>`;
			}
		}

		// Case 2 - defer lookup for later, but request the Index now
		name = name || target;
		return `<a class="entity-link" data-pack=${pack.collection} data-lookup="${target}" draggable="true"><i class="${icon}"></i> ${name}</a>`;
	}

	/* -------------------------------------------- */

	/**
	 * Replace a matched Entity Link with an actual HTML link to that entity
	 * Be failure-tolerant, allowing for the possibility that the entity does not exist
	 * @param {string} match        The full matched string
	 * @param {string} entityType   The named type of Entity being embedded
	 * @param {string} id           The Entity ID or name
	 * @param {name} name           A custom text name to display
	 * @return {string}             The replacement string
	 */
	static _replaceEntityLink(match, entityType, id, name) {
		const config = CONFIG[entityType];
		const collection = config.entityClass.collection;

		// Match either on ID or by name
		let entity = null;
		if (/^[a-zA-Z0-9]{16}$/.test(id)) entity = collection.get(id);
		if (!entity) entity = collection.entities.find(e => e.data.name === id);
		if (!entity) return match;

		// Format an Entity link to the target
		name = name || entity.name;
		id = entity._id;
		let icon = config.sidebarIcon;
		return `<a class="entity-link" data-entity=${entityType} data-id=${id} draggable="true"><i class="${icon}"></i> ${name}</a>`;
	}

	/* -------------------------------------------- */

	/**
	 * Replace a hyperlink-like string with an actual HTML <a> tag
	 * @return {String}   The replacement string
	 */
	static _replaceHyperlinks(match, url) {
		let href = /^https?:\/\//.test(url) ? url : `http://${url}`;
		return `<a class="hyperlink" href="${href}" target="_blank">${url}</a>`;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	static activateListeners() {
		const body = $('body');
		body.on('click', 'a.entity-link', this._onClickEntityLink);
		body.on('dragstart', 'a.entity-link', this._onDragEntityLink);
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Entity Links
	 * @param {Event} event
	 * @private
	 */
	static async _onClickEntityLink(event) {
		event.preventDefault();
		const a = event.currentTarget;
		let entity = null;

		// Case 1 - Compendium Link
		if (a.dataset.pack) {
			const pack = game.packs.find(p => p.collection === a.dataset.pack);
			let id = a.dataset.id;
			if (a.dataset.lookup) {
				if (!pack.index.length) await pack.getIndex();
				const entry = pack.index.find(
					i =>
						i.id === a.dataset.lookup || i.name === a.dataset.lookup
				);
				id = entry.id;
			}
			entity = id ? await pack.getEntity(id) : null;
		}

		// Case 2 - World Entity Link
		else {
			const cls = CONFIG[a.dataset.entity].entityClass;
			entity = cls.collection.get(a.dataset.id);
		}

		// Render the Entity sheet
		if (!entity) return;
		if (entity.entity === 'Scene') return entity.notes.render(true);
		else entity.sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Begin a Drag+Drop workflow for a dynamic content link
	 * @param {Event} event   The originating drag event
	 * @private
	 */
	static _onDragEntityLink(event) {
		event.stopPropagation();
		const a = event.currentTarget;
		let dragData = null;

		// Case 1 - Compendium Link
		if (a.dataset.pack) {
			const pack = game.packs.find(p => p.collection === a.dataset.pack);
			let id = a.dataset.id;
			if (a.dataset.lookup && pack.index.length) {
				const entry = pack.index.find(
					i =>
						i.id === a.dataset.lookup || i.name === a.dataset.lookup
				);
				if (entry) id = entry.id;
			}
			if (!id) return false;
			dragData = { type: pack.entity, pack: pack.collection, id: id };
		}

		// Case 2 - World Entity Link
		else dragData = { type: a.dataset.entity, id: a.dataset.id };
		event.originalEvent.dataTransfer.setData(
			'text/plain',
			JSON.stringify(dragData)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Begin a a data transfer drag event with default handling
	 * @private
	 */
	_onDragStart(event) {
		event.stopPropagation();
		let li = event.currentTarget.closest('li.directory-item');
		const dragData = li.classList.contains('folder')
			? {
					type: 'Folder',
					id: li.dataset.folderId,
					entity: this.constructor.entity,
			  }
			: { type: this.constructor.entity, id: li.dataset.entityId };
		event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
		this._dragType = dragData.type;
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropping of transferred data onto the active rich text editor
	 * @param {Event} event     The originating drop event which triggered the data transfer
	 * @param {tinyMCE} editor  The TinyMCE editor instance being dropped on
	 * @private
	 */
	static async _onDropEditorData(event, editor) {
		event.preventDefault();
		const data = JSON.parse(event.dataTransfer.getData('text/plain'));
		if (!data) return;

		// Case 1 - Entity from Compendium Pack
		if (data.pack) {
			const pack = game.packs.find(p => p.collection === data.pack);
			if (!pack) return;
			const entity = await pack.getEntity(data.id);
			const link = `@Compendium[${data.pack}.${data.id}]{${entity.name}}`;
			editor.insertContent(link);
		}

		// Case 2 - Entity from World
		else {
			const config = CONFIG[data.type];
			if (!config) return false;
			const entity = config.collection.instance.get(data.id);
			if (!entity) return false;
			const link = `@${data.type}[${entity._id}]{${entity.name}}`;
			editor.insertContent(link);
		}
	}
}

/* -------------------------------------------- */
/*  Backwards Compatibility Globals             */
/* -------------------------------------------- */

function createEditor(...args) {
	console.warn(
		`You are using the createEditor(options, content) function and must migrate to TextEditor.create()`
	);
	return TextEditor.create(...args);
}

function enrichHTML(...args) {
	console.warn(
		`You are using the enrichHTML(options, content) function and must migrate to TextEditor.enrichHTML()`
	);
	return TextEditor.enrichHTML(...args);
}

/* -------------------------------------------- */

/**
 * The FilePicker application renders contents of the server-side public directory
 * This app allows for navigating and uploading files to the public path
 * @type {Application}
 */
class FilePicker extends Application {
	constructor(options = {}) {
		super(options);

		/**
		 * The full requested path given by the user
		 * @type {string}
		 */
		this.request = options.current;

		/**
		 * The file sources which are available for browsing
		 * @type {Object}
		 */
		this.sources = Object.entries({
			data: {
				target: '',
				dirs: [],
				files: [],
				label: 'User Data',
				icon: 'fas fa-database',
			},
			public: {
				target: '',
				dirs: [],
				files: [],
				label: 'Core Data',
				icon: 'fas fa-server',
			},
			s3: {
				buckets: [],
				bucket: '',
				target: '',
				dirs: [],
				files: [],
				label: 'Amazon S3',
				icon: 'fas fa-cloud',
			},
		}).reduce((obj, s) => {
			if (game.data.storages.includes(s[0])) obj[s[0]] = s[1];
			return obj;
		}, {});

		/**
		 * Track the active source tab which is being browsed
		 * @type {string}
		 */
		this.activeSource = 'public';

		/**
		 * The general file type which controls the set of extensions which will be accepted
		 * @type {String}
		 */
		this.type = options.type;

		/**
		 * The target HTML element this file picker is bound to
		 * @type {HTMLElement}
		 */
		this.field = options.field;

		/**
		 * A button which controls the display of the picker UI
		 * @type {HTMLElement}
		 */
		this.button = options.button;

		/**
		 * The current set of file extensions which are being filtered upon
		 * @type {Array}
		 */
		this.extensions = this._getExtensions(this.type);

		// Infer the source
		const [source, target] = this._inferCurrentDirectory(this.request);
		this.activeSource = source;
		this.sources[source].target = target;

		// Track whether we have loaded files
		this._loaded = false;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by this Application
	 * @type {Object}
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.template = 'templates/apps/filepicker.html';
		options.classes = ['filepicker'];
		options.width = 500;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Given a current file path, determine the directory it belongs to
	 * @param {String} target   The currently requested target path
	 * @return {Array}          An array of the inferred source and target path
	 */
	_inferCurrentDirectory(target) {
		// Infer the data source
		target = target || '';
		const publicDirs = [
			'css',
			'fonts',
			'icons',
			'lang',
			'scripts',
			'sounds',
			'ui',
		];
		const source = publicDirs.some(d => target.startsWith(d))
			? 'public'
			: 'data';

		// Infer the current target
		let ignored = [CONST.DEFAULT_TOKEN];
		if (!target || ignored.includes(target))
			target = this.constructor.LAST_BROWSED_DIRECTORY;
		else if (['http://', 'https://'].some(c => target.startsWith(c)))
			target = '';
		let dir = target.split('/');
		if (dir.length === 0) target = '';

		// Return the inferred data
		return [source, target];
	}

	/* -------------------------------------------- */

	/**
	 * Get the valid file extensions for a given named file picker type
	 * @param {string} type
	 * @return {Array}
	 * @private
	 */
	_getExtensions(type) {
		// Identify allowed extensions
		let types = [];
		if (type === 'image') types = CONST.IMAGE_FILE_EXTENSIONS;
		else if (type === 'audio') types = CONST.AUDIO_FILE_EXTENSIONS;
		else if (type === 'video') types = CONST.VIDEO_FILE_EXTENSIONS;
		else if (type === 'imagevideo')
			types = CONST.IMAGE_FILE_EXTENSIONS.concat(
				CONST.VIDEO_FILE_EXTENSIONS
			);
		if (types.length === 0) return undefined;
		// Return the allowed types
		else
			return types.reduce((arr, t) => {
				arr.push(`.${t}`);
				arr.push(`.${t.toUpperCase()}`);
				return arr;
			}, []);
	}

	/* -------------------------------------------- */
	/*  FilePicker Properties                       */
	/* -------------------------------------------- */

	/**
	 * Render a window title for the FilePicker which indicates the types of files which can be selected
	 * @return {String}
	 */
	get title() {
		let type = this.type || 'file';
		let title =
			type === 'imagevideo' ? 'Image or Video' : type.capitalize();
		return `${title} Browser`;
	}

	/* -------------------------------------------- */

	/**
	 * Return the source object for the currently active source
	 * @return {Object}
	 */
	get source() {
		return this.sources[this.activeSource];
	}

	/* -------------------------------------------- */

	/**
	 * Return the target directory for the currently active source
	 * @return {string}
	 */
	get target() {
		return this.source.target;
	}

	/* -------------------------------------------- */

	/**
	 * Return a flag for whether the current user is able to upload file content
	 * @return {boolean}
	 */
	get canUpload() {
		if (!['data', 's3'].includes(this.activeSource)) return false;
		if (game.user && game.user.isGM) return true;
		const allowTrusted = game.settings.get('core', 'allowTrustedUpload');
		return game.user && game.user.isTrusted && allowTrusted;
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Prepare and return the data object used for rendering the application template
	 * @return {Object}
	 */
	async getData() {
		// Sort directories and files alphabetically
		const source = this.source;
		const active = this.active;

		// Sort directories alphabetically and store their partial URLs
		let dirs = source.dirs.map(d => {
			return {
				name: d.split('/').pop(),
				path: d,
			};
		});
		dirs = dirs.sort((a, b) => a.name.localeCompare(b.name));

		// Sort files alphabetically and store their client URLs
		let files = source.files.map(f => {
			return {
				name: f.split('/').pop(),
				url: f,
			};
		});
		files = files.sort((a, b) => a.name.localeCompare(b.name));

		// Return rendering data
		return {
			user: game.user,
			request: this.request,
			sources: this.sources,
			source: source,
			target: source.target,
			active: active,
			dirs: dirs,
			files: files,
			extensions: this.extensions,
			canUpload: this.canUpload,
			canGoBack: active !== '',
			isS3: this.activeSource === 's3',
			noResults: dirs.length + files.length === 0,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Browse to a specific location for this FilePicker instance
	 * @param {string} target     The target within the currently active source location.
	 * @param {Object} options    Browsing options
	 */
	async browse(target, options = {}) {
		target = typeof target === 'string' ? target : this.target;
		const source = this.activeSource;
		const isS3 = source === 's3';
		options = mergeObject(
			{
				extensions: this.extensions,
				wildcard: false,
				bucket: isS3 ? this.source.bucket : null,
			},
			options
		);
		if (target.startsWith('/')) target = target.slice(1);

		// Avoid browsing certain paths
		if (target === CONST.DEFAULT_TOKEN)
			target = this.constructor.LAST_BROWSED_DIRECTORY;

		// Request files from the server
		const result = await this.constructor
			.browse(source, target, options)
			.catch(error => {
				ui.notifications.warn(error);
				return this.constructor.browse(source, '', options);
			});

		// Flag updates
		this.constructor.LAST_BROWSED_DIRECTORY = result.target;

		// Populate S3 bucket list
		if (isS3 && !this.source.buckets.length) {
			this.source.buckets = result.dirs;
			this.source.bucket = result.dirs[0];
			return this.browse('/');
		}

		// Populate browser content
		mergeObject(this.sources[source], result);
		this._loaded = true;

		// Render the application
		this.render(true);
		return result;
	}

	/* -------------------------------------------- */

	/**
	 * Browse files for a certain directory location
	 * @param {string} source     The source location in which to browse
	 * @param {string} target     The target within the source location
	 *
	 * @param {Object} options              Optional arguments
	 * @param {string} options.bucket       A bucket within which to search if using the S3 source
	 * @param {Array} options.extensions    An Array of file extensions to filter on
	 * @param {boolean} options.wildcard    The requested dir represents a wildcard path
	 *
	 * @return {Promise}          A Promise which resolves to the directories and files contained in the location
	 */
	static async browse(source, target, options = {}) {
		return new Promise((resolve, reject) => {
			game.socket.emit('getFiles', source, target, options, result => {
				if (result.error) return reject(result.error);
				result.target = decodeURI(result.target);
				result.dirs = result.dirs.map(decodeURI);
				result.files = result.files.map(decodeURI);
				resolve(result);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Additional actions performed when the file-picker UI is rendered
	 */
	render(force, options) {
		this.position.height = null;
		this.element.css({ height: '' });
		if (!this._loaded) return this.browse();
		else super.render(force, options);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate listeners to handle user interactivity for the FilePicker UI
	 * @param html
	 */
	activateListeners(html) {
		super.activateListeners(html);
		const form = html[0];

		// Activate tab navigation
		new Tabs(html.find('.tabs'), {
			initial: this.activeSource,
			callback: clicked => {
				this.activeSource = clicked.data('tab');
				this.browse(this.source.target);
			},
		});

		// Change the directory
		html.find('input[name="target"]').on(
			'keydown',
			this._onRequestTarget.bind(this)
		);

		// Filter results
		html.find('input[name="filter"]').on(
			'keyup',
			this._onFilterResults.bind(this)
		);

		// Select an entry in the directory
		html.find('.file-directory').on('click', 'li', this._onPick.bind(this));

		// Go back one directory
		html.find('.back').click(this._onBack.bind(this));

		// Change the S3 bucket
		html.find('select[name="bucket"]').change(
			this._onChangeBucket.bind(this)
		);

		// Upload new file
		if (this.canUpload) form.upload.onchange = ev => this._onUpload(ev);

		// Form submission
		form.onsubmit = ev => this._onSubmit(ev);
	}

	/* -------------------------------------------- */

	/**
	 * Handle user submission of the address bar to request an explicit target
	 * @param {Event} event     The originating keydown event
	 * @private
	 */
	_onRequestTarget(event) {
		if (event.keyCode === KEYS.ENTER) {
			event.preventDefault();
			this.browse(event.target.value);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle file or folder selection within the file picker
	 * @param {Event} event     The originating click event
	 * @private
	 */
	_onPick(event) {
		const li = event.currentTarget;
		if (li.classList.contains('dir')) return this.browse(li.dataset.path);
		else li.closest('form').file.value = encodeURI(li.dataset.path);
	}

	/* -------------------------------------------- */

	/**
	 * Handle backwards navigation of the folder structure
	 * @private
	 */
	_onBack(event) {
		event.preventDefault();
		let target = this.target.split('/');
		target.pop();
		return this.browse(target.join('/'));
	}

	/* -------------------------------------------- */

	_onChangeBucket(event) {
		event.preventDefault();
		const select = event.currentTarget;
		this.sources.s3.bucket = select.value;
		return this.browse('/');
	}

	/* -------------------------------------------- */

	/**
	 * Handle a keyup event in the filter box to restrict the set of files shown in the FilePicker
	 * @private
	 */
	_onFilterResults(event) {
		event.preventDefault();
		let input = event.currentTarget;

		// Define filtering function
		let filter = query => {
			this.element
				.find('.file-directory')
				.children()
				.each((i, li) => {
					li.hidden = !query.test(li.dataset.path);
				});
		};

		// Filter if we are done entering keys
		let query = new RegExp(RegExp.escape(input.value), 'i');
		this._filterTime = new Date();
		setTimeout(() => {
			if (new Date() - this._filterTime > 250) filter(query);
		}, 251);
	}

	/* -------------------------------------------- */

	/**
	 * Handle file picker form submission
	 * @param ev {Event}
	 * @private
	 */
	_onSubmit(ev) {
		ev.preventDefault();
		let path = ev.target.file.value;
		if (!path)
			return ui.notifications.error('You must select a file to proceed.');

		// Update the target field
		if (this.field) {
			this.field.value = path;
			this.field.dispatchEvent(new Event('change'));
		}

		// Trigger a callback and close
		if (this.options.callback) this.options.callback(path);
		this.close();
	}

	/* -------------------------------------------- */

	/**
	 * Handle file upload
	 * @param ev
	 * @private
	 */
	_onUpload(ev) {
		const form = ev.target.form,
			formData = new FormData(form),
			upload = form.upload,
			filename = formData.get('upload').name;

		// Validate file extension
		if (!this.extensions.some(ext => filename.endsWith(ext))) {
			ui.notifications.error(
				`Incorrect ${
					this.type
				} file extension. Supports ${this.extensions.join(' ')}.`
			);
			return false;
		}

		// Add the source path
		formData.append('source', this.activeSource);

		// Create a POST request
		let xhr = new XMLHttpRequest();
		xhr.open('POST', '/upload', true);
		xhr.onloadstart = event => (upload.disabled = true);
		xhr.onreadystatechange = () => {
			if (xhr.readyState !== 4) return;
			if (xhr.status === 500) ui.notifications.error(xhr.response);
			else {
				ui.notifications.info(xhr.responseText);
				this.browse();
			}
			upload.disabled = false;
		};

		// Submit the POST request
		xhr.send(formData);
	}

	/* -------------------------------------------- */
	/*  Factory Methods
  /* -------------------------------------------- */

	/**
	 * Bind the file picker to a new target field.
	 * Assumes the user will provide a <button> HTMLElement which has the data-target and data-type attributes
	 * The data-target attribute should provide the name of the input field which should receive the selected file
	 * The data-type attribute is a string in ["image", "audio"] which sets the file extensions which will be accepted
	 *
	 * @param button {HTMLElement}    The button element
	 */
	static fromButton(button, options) {
		if (!(button instanceof HTMLElement))
			throw 'You must pass an HTML button';
		let type = button.getAttribute('data-type');

		// Identify the target form field
		let form = button.form,
			target = form[button.getAttribute('data-target')];
		if (!target) return;

		// Build and return a FilePicker instance
		return new FilePicker({
			field: target,
			type: type,
			current: target.value,
			button: button,
		});
	}
}

FilePicker.LAST_BROWSED_DIRECTORY = '';

$(document).ready(function() {
	/**
	 * Support mousewheel control for range type input elements
	 */
	$('body').on('mousewheel', 'input[type="range"]', ev => {
		let rng = ev.currentTarget,
			step =
				(parseFloat(rng.step) || 1.0) *
				Math.sign(-1 * ev.originalEvent.deltaY);
		rng.value = Math.clamped(
			parseFloat(rng.value) + step,
			parseFloat(rng.min),
			parseFloat(rng.max)
		);
		rng.dispatchEvent(new Event('change'));
	});
});

/**
 * A common framework for displaying notifications to the client.
 * Submitted notifications are added to a queue, and up to 3 notifications are displayed at once.
 * Each notification is displayed for 5 seconds at which point further notifications are pulled from the queue.
 *
 * @type {Application}
 *
 * @example
 * ui.notifications.info("This is an info message");
 * ui.notifications.warn("This is a warning message");
 * ui.notifications.error("This is an error message");
 * ui.notifications.info("This is a 4th message which will not be shown until the first info message is done");
 */
class Notifications extends Application {
	constructor(options) {
		super(options);

		/**
		 * Submitted notifications which are queued for display
		 * @type {Array}
		 */
		this.queue = [];

		/**
		 * Notifications which are currently displayed
		 * @type {Array}
		 */
		this.active = [];
	}

	/* -------------------------------------------- */

	/**
	 * Configure the default behavior of the notifications application
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		return mergeObject(options, {
			popOut: false,
			id: 'notifications',
			template: 'templates/hud/notifications.html',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Push a new notification into the queue
	 * @param {String} message    The content of the notification message
	 * @param {String} type       The type of notification, currently "info", "warning", and "error" are supported
	 */
	notify(message, type) {
		// Construct notification data
		let n = {
			message: message,
			type: ['info', 'warning', 'error'].includes(type) ? type : 'info',
			timestamp: new Date().getTime(),
		};
		this.queue.push(n);

		// Call the fetch method
		this.fetch();
	}

	/* -------------------------------------------- */

	/**
	 * Display a notification with the "info" type
	 * @param {String} message    The content of the notification message
	 */
	info(message) {
		this.notify(message, 'info');
	}

	/**
	 * Display a notification with the "warning" type
	 * @param {String} message    The content of the notification message
	 */
	warn(message) {
		this.notify(message, 'warning');
	}

	/**
	 * Display a notification with the "error" type
	 * @param {String} message    The content of the notification message
	 */
	error(message) {
		this.notify(message, 'error');
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve a pending notification from the queue and display it
	 * @private
	 * @return {Promise}
	 */
	async fetch() {
		if (this.queue.length === 0 || this.active.length >= 3) return;

		// Display a new notification
		let next = this.queue.pop(),
			li = $(
				`<li class="notification ${next.type}">${next.message}</li>`
			);
		this.element.prepend(li);
		li.hide().slideDown(250);
		this.active.push(li);

		// Remove the notification 5 seconds later
		window.setTimeout(() => {
			li.fadeOut(250, () => li.remove());
			this.active.pop();
			this.fetch();
		}, 5000);
	}
}

/**
 * A helper class for creating tabbed containers.
 * Create one Tabs instance per tabbed navigation container in your application.
 *
 * @example
 * <!-- Example HTML -->
 * <nav class="tabs" data-group="group1">
 *  <a class="item" data-tab="tab1">Tab 1</li>
 *  <a class="item" data-tab="tab2">Tab 2</li>
 * </nav>
 *
 * <div class="tab" data-tab="tab1" data-group="group1">Content 1</div>
 * <div class="tab" data-tab="tab2" data-group="group1">Content 2</div>
 *
 * @example
 * // JavaScript Listener
 * let nav = $('.tabs[data-group="group1"]');
 * new Tabs(nav, {
 *   initial: "tab1",
 *   callback: t => console.log("Tab ${t} was clicked")
 * });
 *
 * @param tabs {HTMLElement|JQuery} An HTML element or JQuery object representing the tab navigation container.
 */
class Tabs {
	constructor(tabs, { initial, callback, container = null } = {}) {
		/**
		 * The collection of tabs
		 * @type {jQuery}
		 */
		this.tabs = tabs instanceof jQuery ? tabs : $(tabs);

		/**
		 * The callback function to trigger when a Tab is activated
		 * @type {Function}
		 */
		this.callback = callback instanceof Function ? callback : null;

		/**
		 * The container element within which both the tab navigation and the tab content exists
		 */
		this.container =
			container instanceof jQuery ? container : this.tabs.parents('.app');

		/**
		 * The currently active tab name
		 * @type {string}
		 */
		this.tab = initial;

		/**
		 * The currently active tab element
		 * @type {jQuery}
		 */
		this.active = initial
			? this.tabs.children(`[data-tab="${initial}"]`)
			: this.tabs.children('.active');

		// Initialize the currently active tab
		if (this.active.length === 0)
			this.active = this.tabs.children().first();
		this.activateTab(this.active);

		// Register event listeners
		this.tabs.on('click', '.item', event => {
			event.preventDefault();
			let tab = $(event.currentTarget);
			this.activateTab(tab);
			if (this.callback) this.callback(tab);
		});
	}

	/* -------------------------------------------- */

	/**
	 * The named tab group
	 * Retrieved as a property since the composition of the DOM may change over time
	 * @type {jQuery}
	 */
	get group() {
		let tabGroup = this.tabs.attr('data-group');
		if (tabGroup)
			return this.container.find(`.tab[data-group="${tabGroup}"]`);
		else return this.tabs.siblings('.tab[data-tab]');
	}

	/* -------------------------------------------- */

	/**
	 * Activate a tab by it's name. This gets called automatically when a tab in the navigation is clicked,
	 * however you may also call this function directly.
	 *
	 * @param {jQuery} tab     The tab control being activated
	 */
	activateTab(tab) {
		// If only a name was provided, get the tab
		if (typeof tab === 'string') {
			tab = this.tabs.find(`[data-tab="${tab}"]`);
		}
		if (!tab) return;

		// Flag tab as active
		tab.siblings().removeClass('active');
		tab.addClass('active');
		tab.show();

		// Show the content
		this.group.removeClass('active');
		this.group
			.filter(`[data-tab="${tab.attr('data-tab')}"]`)
			.addClass('active');

		// Assign references
		this.tab = tab.data('tab');
		this.active = tab;
	}
}

/**
 * WebRTC Handler
 * Does the basic linking between the WebRTCClient and the UI/events as well as most WebRTC related logic.
 *
 * @param {WebRTCSettings} settings   The WebRTC Settings object to use
 */
class WebRTC {
	constructor(settings) {
		/**
		 * Configuration for all settings used by the WebRTC Implementation
		 * @type {WebRTCSettings}
		 */
		this.settings = settings;

		/**
		 * Configuration sheet for the Audio/Video settings
		 * @type {AVConfig}
		 */
		this.config = new AVConfig(this);

		/**
		 * WebRTC Implementation to use for all signalling and connecting logic
		 * Must implement the WebRTCInterface interface
		 * @type {WebRTCInterface}
		 */
		this.client = new CONFIG.WebRTC.clientClass(this, this.settings);

		/**
		 * Flag to determine if we are connected to the signalling server or not
		 * Required for synchronization between connection and reconnection attempts
		 * and to know if disconnection events are due to loss of connection or
		 * @type {Boolean}
		 */
		this._connected = false;

		/**
		 * Object to keep track of which users are speaking and their volume histories
		 * Format is :
		 * {id :
		 *   {
		 *     speaking: Boolean
		 *     volumeHistories: Array.Number
		 *   }
		 * }
		 * @type {Object}
		 */
		this._speakingData = {};

		/**
		 * Push-To-Talk handlers
		 * Key Event handlers for push to talk need to be bound and cannot be anonymous functions
		 * if we want to use removeEventListener. The `.bind` returns a new function every time so we
		 * cannot use them as is with addEventListener. We save bound copies of the event handler so we
		 * can add/remove them as needed in case voice detection modes are modified.
		 * @type {Object.<Function>}
		 */
		this._pttHandlers = {};

		/**
		 * Push-To-Talk timeout ID for muting
		 * When using Push-To-Talk, we need to delay the disablement of our microphone after the user releases
		 * their PTT key. But if they press it again, we need to cancel the timeout, so we have to save its ID here
		 * @type {Number}
		 */
		this._pttMuteTimeout = 0;

		/**
		 * Cached setting on whether we are broadcasting our audio
		 * In case we unmute our microphone and we're in PTT mode, we need to know if we are to
		 * broadcast our audio to every user or not.
		 * @type {Boolean}
		 */
		this._broadcastingAudio = false;

		/**
		 * Define the amount of time in milliseconds allowed to elapse once connectivity is lost
		 * @type {number}
		 * @private
		 */
		this._reconnectPeriodMS = 5000;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WebRTC implementation.
	 * After initialization, will automatically connect and set up the calls
	 */
	async initialize() {
		await this.client.initialize();
		return this.connect(this);
	}

	/* -------------------------------------------- */

	/**
	 * Connect to the WebRTC server and initialize our local stream
	 * If connection fails, will release capture resources.
	 */
	async connect() {
		if (this.settings.mode === WebRTCSettings.WEBRTC_MODE.DISABLED)
			return false;

		// TODO: when using FVTT server, we shouldn't need to set the username/password. Auth should be session based.
		let connectionOptions = {
			host: null,
			room: null,
			username: game.user.id,
			password: game.user.data.password,
		};

		// If using custom server, replace the connection settings
		if (
			this.settings.serverType === 'custom' &&
			this.settings.serverUrl !== ''
		) {
			connectionOptions = {
				host: this.settings.serverUrl,
				room: this.settings.serverRoom,
				username: this.settings.serverUsername,
				password: this.settings.serverPassword,
			};
		}

		// Disconnect from any existing session
		await this.disconnect();

		// Connect to the session
		this.debug('Connecting to Signalling Server');
		const connected = await this.client.connect(connectionOptions);
		if (connected) {
			Hooks.callAll('rtcClientConnected', this);
			await this._initLocalStream();
		} else {
			ui.notifications.error(game.i18n.localize('WEBRTC.ConnectError'));
			await this._closeLocalStream();
		}
		return (this._connected = connected);
	}

	/* -------------------------------------------- */

	/**
	 * Disconnect from the WebRTC server and close our local stream.
	 * Prevent the disconnection from appearing as if it was a lost connection.
	 * Signal the disconnection only if we had been connected.
	 * @return {Boolean}     Returns whether there was a valid connection that was terminated
	 */
	async disconnect() {
		const wasConnected = this._connected;
		this._closeLocalStream();
		this._connected = false;
		// Always call disconnect in case there was an in-progress connection attempt
		await this.client.disconnect();
		if (wasConnected) {
			this.debug('Disconnected from Signalling Server');
			Hooks.callAll('rtcClientDisconnected', this);
		}
		return wasConnected;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize local stream according to A/V mode and user settings.
	 * Tries to fallback to using audio only or video only if capturing both fails.
	 */
	async _initLocalStream() {
		const settings = this.settings;
		if (settings.mode === WebRTCSettings.WEBRTC_MODE.DISABLED)
			return this._closeLocalStream();

		// Define Video Source
		let videoSrc = settings.videoSrc;
		if (
			settings.mode === WebRTCSettings.WEBRTC_MODE.AUDIO ||
			!settings.users[game.user.id].canBroadcastVideo
		) {
			videoSrc = null;
		}

		// Define Audio Source
		let audioSrc = settings.audioSrc;
		if (
			settings.mode === WebRTCSettings.WEBRTC_MODE.VIDEO ||
			!settings.users[game.user.id].canBroadcastAudio
		) {
			audioSrc = null;
		}

		// Get the local stream
		let stream = await this.client.initLocalStream(audioSrc, videoSrc);

		// In case of failure attempting to capture A/V, try to capture audio only or video only
		if (!stream && audioSrc && videoSrc) {
			let capturedOnly = 'Audio';
			stream = await this.client.initLocalStream(audioSrc, null); // try without video first
			if (!stream) {
				// if it fails, try video only
				capturedOnly = 'Video';
				stream = await this.client.initLocalStream(null, videoSrc);
			}
			if (stream)
				ui.notifications.warn(
					game.i18n.localize(`WEBRTC.CaptureWarning${capturedOnly}`)
				);
		}

		// If we successfully began a stream
		if (stream) {
			this.debug('Success in initializing media source : ', stream);
			this.setVideoStream(game.user.id, stream);
			this._setupVoiceDetection(stream);
		}

		// If we were not successful
		else {
			let error_type = null;
			if (audioSrc && videoSrc) error_type = 'AudioVideo';
			else if (audioSrc) error_type = 'Audio';
			else if (videoSrc) error_type = 'Video';
			if (error_type)
				ui.notifications.error(
					game.i18n.localize(`WEBRTC.CaptureError${error_type}`)
				);
		}

		// Refresh the UI now that we have (or not) a local stream
		ui.webrtc.render();
		return stream;
	}

	/* -------------------------------------------- */

	/**
	 * Closes our local stream.
	 * Stop listening to audio levels from our existing stream, then close
	 */
	async _closeLocalStream() {
		await this.client.closeLocalStream();
		this._stopVoiceDetection();
		ui.webrtc.render();
		return null;
	}

	/* -------------------------------------------- */
	/*  UI Control Methods                          */
	/* -------------------------------------------- */

	/**
	 * Connects a stream to a video element
	 * @param {String} userId         The ID of the user to whom the stream belongs to
	 * @param {MediaStream} stream    The media stream to set for the user. Can be `null` if user has no stream
	 */
	setVideoStream(userId, stream) {
		const videoElement = ui.webrtc.getUserVideoElement(userId);
		if (videoElement) {
			this.client.assignStreamToVideo(stream, videoElement);
			this.client.setAudioOutput(videoElement, this.settings.audioSink);
			videoElement.dispatchEvent(
				new CustomEvent('srcObjectSet', { detail: stream })
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Renders the webrtc streams.
	 * This should be called by the UI after it's done rendering, so the webrtc implementation
	 * can set all video elements to the appropriate streams
	 */
	render() {
		let streams = this.client.getConnectedStreams();
		const sd = this._speakingData;
		let isSpeaking = sd[game.user.id] ? sd[game.user.id].speaking : false;
		this.setVideoStream(
			game.user.id,
			this.client.getStreamForUser(game.user.id)
		);
		ui.webrtc.setUserIsSpeaking(game.user.id, isSpeaking);
		for (let info of streams) {
			isSpeaking = sd[info.id] ? sd[info.id].speaking : false;
			this.setVideoStream(info.id, info.remote);
			ui.webrtc.setUserIsSpeaking(info.id, isSpeaking);
		}
	}

	/* -------------------------------------------- */
	/*  Stream Related methods                      */
	/* -------------------------------------------- */

	/**
	 * Checks whether a stream has any video tracks
	 * @param {MediaStream} stream    The stream to check
	 * @return {boolean}
	 */
	streamHasVideo(stream) {
		return stream != null && stream.getVideoTracks().length > 0;
	}

	/* -------------------------------------------- */

	/**
	 * Checks whether a stream has any audio tracks
	 * @param {MediaStream} stream    The stream to check
	 * @return {boolean}
	 */
	streamHasAudio(stream) {
		return stream != null && stream.getAudioTracks().length > 0;
	}

	/* -------------------------------------------- */

	/**
	 * Enables or disables media tracks
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 * @param {Array} tracks          The tracks to enable/disable
	 * @param {boolean} enable        Whether to enable or disable the tracks
	 */
	_enableMediaTracks(tracks, enable) {
		for (let track of tracks || []) track.enabled = enable;
	}

	/* -------------------------------------------- */

	/**
	 * Enable or disable the video tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it. We use the term 'enable' here instead
	 * of 'mute' to match the MediaStreamTrack field name and to avoid confusion with the 'muted' read-only field of the
	 * MediaStreamTrack as well as the video element's `muted` field which only stops playing the audio.
	 *
	 * Muting by definition stops rendering any of the data, while a disabled track in this case is still rendering its
	 * data, but is simply generating disabled content (silence and black frames).
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamVideo(stream, enable = true) {
		if (stream) this._enableMediaTracks(stream.getVideoTracks(), enable);
	}

	/* -------------------------------------------- */

	/**
	 * Disables the video tracks in a stream
	 * @param {MediaStream} stream    The stream to modify
	 */
	disableStreamVideo(stream) {
		return this.enableStreamVideo(stream, false);
	}

	/* -------------------------------------------- */

	/**
	 * Checks if a stream has any video tracks enabled
	 * @param {MediaStream} stream    The stream to check
	 * @return {boolean}
	 */
	isStreamVideoEnabled(stream) {
		const tracks = stream ? stream.getVideoTracks() : [];
		return tracks.some(t => t.enabled);
	}

	/* -------------------------------------------- */

	/**
	 * Enable or disable the audio tracks in a stream
	 *
	 * Disabling a track represents what a typical user would consider muting it.
	 * We use the term 'enable' here instead of 'mute' to match the MediaStreamTrack
	 * field name and to avoid confusion with the 'muted' read-only field of the MediaStreamTrack
	 * as well as the video element's `muted` field which only stops playing the audio.
	 * Muting by definition stops rendering any of the data, while a disabled track in this case
	 * is still rendering its data, but is simply generating disabled content (silence and black frames)
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/enabled
	 *
	 * @param {MediaStream} stream    The stream to modify
	 * @param {boolean} enable        (optional) Whether to enable or disable the tracks
	 */
	enableStreamAudio(stream, enable = true) {
		if (stream) this._enableMediaTracks(stream.getAudioTracks(), enable);
	}

	/* -------------------------------------------- */

	/**
	 * Disables the audio tracks in a stream
	 * @param {MediaStream} stream    The stream to modify
	 */
	disableStreamAudio(stream) {
		return this.enableStreamAudio(stream, false);
	}

	/* -------------------------------------------- */

	/**
	 * Checks if a stream has any audio tracks enabled
	 * @param {MediaStream} stream    The stream to check
	 * @return {Boolean}
	 */
	isStreamAudioEnabled(stream) {
		const tracks = stream ? stream.getAudioTracks() : [];
		return tracks.some(t => t.enabled);
	}

	/* -------------------------------------------- */

	/**
	 * Enables or disables the sending of our own video camera capture to
	 * all users.
	 * @param {boolean} enable    (optional) Whether to enable camera or not
	 */
	enableCamera(enable = true) {
		let streamInfos = this.client.getConnectedStreams();
		let stream = this.client.getStreamForUser(game.user.id);
		// Enable/Disable the master stream so it affects new users joining in
		this.enableStreamVideo(stream, enable);
		// Enable/Disable the individual local streams on each connected calls
		for (let info of streamInfos)
			this.enableStreamVideo(info.local, enable);
	}

	/* -------------------------------------------- */

	/**
	 * Disables the sending of our own video camera capture to all users.
	 */
	disableCamera() {
		return this.enableCamera(false);
	}

	/* -------------------------------------------- */

	/**
	 * Enables or disables the sending of our own audio capture to all users.
	 * Enable/Disable the master stream so it affects new users joining in.
	 * Also Enable/Disable the individual local streams on each connected calls.
	 * @param {Boolean} enable    (optional) Whether to enable the microphone or not
	 */
	enableMicrophone(enable = true) {
		const stream = this.client.getStreamForUser(game.user.id);
		this.enableStreamAudio(stream, enable);
		this.broadcastMicrophone(enable && this._broadcastingAudio);
	}

	/* -------------------------------------------- */

	/**
	 * Disables the sending of our own audio capture to all users.
	 */
	disableMicrophone() {
		return this.enableMicrophone(false);
	}

	/* -------------------------------------------- */

	/**
	 * Enable or disable the broadcasting of our own microphone to the other users
	 * without changing the enabled state of the master stream.
	 * This is to be used with push-to-talk or voice activity detection
	 * methods.
	 *
	 * @param {Boolean} broadcast    Whether to broadcast our microphone to the other users or not
	 */
	broadcastMicrophone(broadcast) {
		const streamInfos = this.client.getConnectedStreams();
		for (let info of streamInfos)
			this.enableStreamAudio(info.local, broadcast);
	}

	/* -------------------------------------------- */

	/**
	 * Setup Voice detection for our local stream.
	 * Depending on the settings, this will either add an audio level listener or key/mouse event listeners for
	 * push-to-talk handling.
	 *
	 * Note that if the microphone is disabled (muted), then we never broadcast our audio regardless of the voice
	 * detection algorithm in use.
	 *
	 * Valid voice detection modes are :
	 * - "always": Broadcasting of audio is always on
	 * - "activity": Broadcasting only if audio level above a threshold
	 * - "ptt": Broadcasting while a keyboard or mouse button is pressed
	 */
	_setupVoiceDetection(stream) {
		this._stopVoiceDetection();
		if (!this.streamHasAudio(stream)) return;

		const mode = this.settings.voiceMode;
		if (['always', 'activity'].includes(mode)) {
			const audioLevelHandler = this._onAudioLevel.bind(
				this,
				game.user.id
			);
			game.audio.startLevelReports(
				game.user.id,
				stream,
				audioLevelHandler,
				CONFIG.WebRTC.emitVolumeInterval
			);
			this._resetSpeakingHistory(game.user.id);
		}

		if (mode === 'ptt') {
			this._pttBroadcast(stream, false);
		} else if (mode === 'always') {
			const audioEnabled = this.isStreamAudioEnabled(stream);
			this._broadcastingAudio = true;
			this.broadcastMicrophone(audioEnabled);
		} else if (mode === 'activity') {
			this._broadcastingAudio = false;
			this.broadcastMicrophone(false);
		}

		if (this.settings.voicePttMouse) {
			this._pttHandlers = {
				mousedown: this._onPTTMouseDown.bind(this),
				mouseup: this._onPTTMouseUp.bind(this),
			};
		} else {
			this._pttHandlers = {
				keydown: this._onPTTKeyDown.bind(this),
				keyup: this._onPTTKeyUp.bind(this),
			};
		}
		for (let [event, handler] of Object.entries(this._pttHandlers))
			window.addEventListener(event, handler, { capture: true });
	}

	/**
	 * Stop listening to local stream for voice detection and push to talk
	 */
	_stopVoiceDetection() {
		game.audio.stopLevelReports(game.user.id);
		this._resetSpeakingHistory(game.user.id);
		for (let [event, handler] of Object.entries(this._pttHandlers))
			window.removeEventListener(event, handler, { capture: true });
		this._pttHandlers = {};
	}

	/**
	 * Push the Push-To-Talk trigger
	 * This will enable or disable broadcasting if we are not muted depending on
	 * whether we are in push-to-talk or push-to-mute
	 */
	_pttPush() {
		if (this.settings.voiceMode === 'ptt') {
			const stream = this.client.getStreamForUser(game.user.id);
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this._pttBroadcast(stream, true);
		}

		// Always and Voice activity will use ptt trigger as a push-to-mute
		else {
			const timeoutCallback = () => this.enableMicrophone(false);
			this._pttMuteTimeout = setTimeout(
				timeoutCallback,
				this.settings.voicePttDelay
			);
		}
	}

	/**
	 * Release the Push-To-Talk trigger
	 * After the configured delay, the
	 */
	_pttRelease() {
		if (this.settings.voiceMode === 'ptt') {
			const stream = this.client.getStreamForUser(game.user.id);
			const timeoutCallback = () => this._pttBroadcast(stream, false);
			this._pttMuteTimeout = setTimeout(
				timeoutCallback,
				this.settings.voicePttDelay
			);
		}

		// Always and voice activity need to unmute right away when triggered
		else {
			if (this._pttMuteTimeout > 0) clearTimeout(this._pttMuteTimeout);
			this._pttMuteTimeout = 0;
			this.enableMicrophone(true);
		}
	}

	/**
	 * Starts or stops broadcasting audio when in Push-to-talk mode
	 * If our local stream is muted, then it will set to broadcasting mode without
	 * actually broadcasting audio
	 * @param {MediaStream} stream     Our local stream
	 * @param {Boolean} broadcast      Whether to broadcast or not
	 */
	_pttBroadcast(stream, broadcast) {
		this._broadcastingAudio = broadcast;
		ui.webrtc.setUserIsSpeaking(game.user.id, this._broadcastingAudio);
		this.broadcastMicrophone(
			this.isStreamAudioEnabled(stream) && this._broadcastingAudio
		);
	}

	/* -------------------------------------------- */
	/*  Event handlers                              */
	/* -------------------------------------------- */

	/**
	 * Notify of changes to the webrtc related settings.
	 * Handle settings changes in order of importance. If the mode changed, we reload the page and can ignore any other
	 * setting change and if the server changed and we need to reconnect, we can ignore anything that has to do with the
	 * our own stream since we'll recreate it or with the other user's settings.
	 *
	 * @param {Object} changed      Object of {key: value} of all changed settings
	 */
	onSettingsChanged(changed) {
		const keys = Object.keys(changed);

		// Change the server mode
		if (keys.includes('mode')) return window.location.reload();

		// Change the server configuration
		if (keys.includes('server')) return this.connect();

		// Change audio or video sources
		if (
			keys.some(k => ['videoSrc', 'audioSrc'].includes(k)) ||
			hasProperty(changed, `users.${game.user.id}.canBroadcastVideo`) ||
			hasProperty(changed, `users.${game.user.id}.canBroadcastAudio`)
		) {
			this._initLocalStream();
		} else if (keys.includes('voice'))
			this._setupVoiceDetection(
				this.client.getStreamForUser(game.user.id)
			);

		// Change audio output sink
		if (keys.includes('audioSink')) this.render();

		// Change connected users
		if (keys.includes('users')) {
			let streamInfo = null;
			for (let [userId, user] of Object.entries(changed.users)) {
				const userKeys = Object.keys(user);

				// If peer has new permissions, we expect them to re-init their local stream on their own, but just in case
				// audio or video has been blocked and the peer is cheating via some module that forces their video on, then
				// we can remove their tracks immediately.
				if (
					userId !== game.user.id &&
					userKeys.some(k =>
						['canBroadcastVideo', 'canBroadcastAudio'].includes(k)
					)
				) {
					streamInfo =
						streamInfo === null
							? this.client.getConnectedStreams()
							: streamInfo;
					const info = streamInfo.find(i => i.id === userId);
					if (info && info.remote)
						this.onUserStreamChange(userId, info.remote);
				}
			}
		}

		// Call client specific setting handling
		this.client.onSettingsChanged(changed);
	}

	/* -------------------------------------------- */

	/**
	 * Notify a change of a user's stream
	 * @param {string} userId         The ID of the user whose stream has changed.
	 * @param {MediaStream} stream    The new stream of the user, or null if  the user is not sending data anymore.
	 */
	onUserStreamChange(userId, stream) {
		Hooks.call('rtcUserStreamChange', this, { userId, stream });
		this.setVideoStream(userId, stream);
		const userSettings = this.settings.users[userId];

		// Remove video or audio tracks that the user does not have permission to be sharing
		if (stream) {
			if (!userSettings.canBroadcastAudio)
				stream
					.getAudioTracks()
					.forEach(track => stream.removeTrack(track));
			if (!userSettings.canBroadcastVideo)
				stream
					.getVideoTracks()
					.forEach(track => stream.removeTrack(track));
		}

		// Start/stop listening to stream audio levels depending on whether the stream (streamHasAudio is null safe) has audio tracks or not
		if (this.streamHasAudio(stream)) {
			const audioLevelHandler = this._onAudioLevel.bind(this, userId);
			game.audio.startLevelReports(
				userId,
				stream,
				audioLevelHandler,
				CONFIG.WebRTC.emitVolumeInterval
			);
		} else game.audio.stopLevelReports(userId);
		this._resetSpeakingHistory(userId);

		// Disable stream components if muted or hidden
		if (userSettings.muted) this.disableStreamAudio(stream);
		if (userSettings.hidden) this.disableStreamVideo(stream);

		// Render the AV interface
		ui.webrtc.render();
	}

	/* -------------------------------------------- */

	/**
	 * Notify when a new local stream is created for a user's call
	 * When the client creates a new local stream to share with a user, this method is
	 * called to notify the implementation of it.
	 * On voice activity mode, all user's local streams are disabled unless audio is above threshold, but
	 * the master stream is not disabled so we can detect our audio level. New users joining would get a copy
	 * of the master stream's tracks which would therefore be enabled, even if voice activity is below threshold
	 * so we need to disable them if our last voice level events were inactive.
	 *
	 * @param {String} userId        ID of the user for whom this stream was created
	 * @param {MediaStream} stream   Our new local stream
	 */
	onLocalStreamCreated(userId, stream) {
		if (!this.streamHasAudio(stream)) return;
		const masterStream = this.client.getStreamForUser(game.user.id);
		this.enableStreamAudio(
			stream,
			this.isStreamAudioEnabled(masterStream) && this._broadcastingAudio
		);
	}

	/* -------------------------------------------- */

	/**
	 * Notify of an error from the webrtc library
	 * @param {string} error   The error string
	 */
	onError(error) {
		console.error(game.i18n.localize('WEBRTC.GenericError') + error);
	}

	/* -------------------------------------------- */

	/**
	 * Notify of a disconnection with the server
	 * Only consider it a connection loss if we were supposed to be still connected
	 */
	async onDisconnect() {
		if (this._connected) {
			ui.notifications.warn(
				game.i18n.localize('WEBRTC.ConnectionLostWarning')
			);
			await this.disconnect();
			while (!this._connected) {
				await new Promise(resolve =>
					setTimeout(() => resolve(), this._reconnectPeriodMS)
				);
				if (!this._connected) await this.connect();
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Resets the speaking history of a user
	 * If the user was considered speaking, then mark them as not speaking
	 * @param {string} userId         The ID of the user
	 */
	_resetSpeakingHistory(userId) {
		ui.webrtc.setUserIsSpeaking(userId, false);
		delete this._speakingData[game.user.id];
	}

	/* -------------------------------------------- */

	/**
	 * Periodic notification of user audio level
	 *
	 * This function uses the audio level (in dB) of each stream it's listening to to determine if a user
	 * is speaking or not and notifies the UI of such changes.
	 *
	 * The User is considered speaking if they are above the decibel threshold in any of the history values.
	 * This marks them as speaking as soon as they have a high enough volume, and marks them as not speaking only after
	 * they drop below the threshold in all histories (last 4 volumes = for 200 ms).
	 *
	 * There can be more optimal ways to do this and which uses whether the user was already considered speaking before
	 * or not, in order to eliminate short bursts of audio (coughing for example).
	 *
	 * @param {String} userId          The user ID of the user whose audio levels are being reported
	 * @param {Number} dbLevel         The audio level in decibels of the user within the last 50ms
	 * @private
	 */
	_onAudioLevel(userId, dbLevel) {
		if (!this._speakingData.hasOwnProperty(userId)) {
			this._speakingData[userId] = {
				speaking: false,
				volumeHistories: [],
			};
		}
		const speakingData = this._speakingData[userId];

		// Add the current volume to the history of the user and keep the list below the history length config.
		if (
			speakingData.volumeHistories.push(dbLevel) >
			CONFIG.WebRTC.speakingHistoryLength
		)
			speakingData.volumeHistories.shift();

		// Count the number and total decibels of speaking events which exceed an activity threshold
		const threshold = this.settings.voiceActivityThreshold;
		const [count, max, total] = speakingData.volumeHistories.reduce(
			(totals, vol) => {
				if (vol >= threshold) {
					totals[0] += 1;
					totals[1] = Math.min(totals[1], vol);
					totals[2] += vol;
				}
				return totals;
			},
			[0, 0, 0]
		);

		const wasSpeaking = speakingData.speaking;
		const isSpeaking = wasSpeaking
			? count > 0
			: count >= CONFIG.WebRTC.speakingThresholdEvents;
		if (isSpeaking !== wasSpeaking) {
			ui.webrtc.setUserIsSpeaking(userId, isSpeaking);
			if (
				userId === game.user.id &&
				this.settings.voiceMode === 'activity'
			) {
				this.broadcastMicrophone(isSpeaking);
			}
		}
		speakingData.speaking = isSpeaking;
	}

	/* -------------------------------------------- */

	/**
	 * Handle Key Down event for Push-To-Talk
	 * When the right key is pressed, prevents the event from being propagated and pushes the PTT
	 * @event {KeyEvent} event   The original keydown event
	 */
	_onPTTKeyDown(event) {
		if (event.keyCode !== this.settings.voicePttKey) return;
		event.preventDefault();
		if (event.repeat) return;
		this._pttPush();
	}

	/* -------------------------------------------- */

	/**
	 * Handle Key Up event for Push-To-Talk
	 * When the right key is released, prevents the event from being propagated and releases the PTT
	 * @event {KeyEvent} event   The original keyup event
	 */
	_onPTTKeyUp(event) {
		if (event.keyCode !== this.settings.voicePttKey) return;
		event.preventDefault();
		this._pttRelease();
	}

	/* -------------------------------------------- */

	/**
	 * Handle Mouse Down event for Push-To-Talk
	 * Pushes the PTT when the right button is pressed
	 * @event {MouseEvent} event   The original mousedown event
	 */
	_onPTTMouseDown(event) {
		if (event.button !== this.settings.voicePttKey) return;
		this._pttPush();
	}

	/* -------------------------------------------- */

	/**
	 * Handle Mouse Up event for Push-To-Talk
	 * Releases the PTT when the right button is released
	 * @event {MouseEvent} event   The original mouseup event
	 */
	_onPTTMouseUp(event) {
		if (event.button !== this.settings.voicePttKey) return;
		this._pttRelease();
	}

	/* -------------------------------------------- */

	/**
	 * Display debug messages on the console if debugging is enabled
	 * @param {...*} args      Arguments to console.log
	 */
	debug(...args) {
		if (this.settings.debug) console.log('RTC : ', ...args);
	}
}
/**
 * WebRTC Implementation Interface which defines the base class for WebRTC Implementations and the interface used by
 * the WebRTC class.
 *
 * Whenever a new remote stream is received by this implementation, a call to `this.webrtc.onUserStreamChange()`
 * will be made to notify of the new or deleted stream.
 *
 * Most functions of this interface will throw not implemented errors. Do not call `super` on any of them.
 *
 * @interface
 * @param {WebRTC} webrtc             The WebRTC object
 * @param {WebRTCSettings} settings   The WebRTC Settings object
 */
class WebRTCInterface {
	constructor(webrtc, settings) {
		this.webrtc = webrtc;
		this.settings = settings;
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WebRTC implementation.
	 * This Will only be called once by the main setupGame() initialization function.
	 * @return {Promise.boolean}
	 */
	async initialize() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Connect to the signalling server.
	 * Any existing connections will be dropped and any existing calls hung up.
	 *
	 * Once a connection to the server is established and the user authenticated, join a room and automatically
	 * establish a call with other users in that same room.
	 *
	 * If a local master media stream has been created, add a copy of that stream to every peer.
	 *
	 * Whether to include audio or video in that cloned stream, or whether to enable or disable the audio and video of
	 * the remote stream from that peer will automatically be determined based on the saved settings.
	 *
	 * This will be called again in case a server configuration changed.
	 *
	 * @param {string|null} host       Server host address. Set to `null` to use current FVTT server
	 * @param {string} room            Name of the room to join on the signalling server
	 * @param {string} username        Username to authenticate to the server (if needed)
	 * @param {string} password        Password to authenticate the user (if needed)
	 * @return {Promise.boolean}       Returns success/failure to connect
	 */
	async connect({ host = null, room, username, password } = {}) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Disconnect from the signalling server, any existing calls will be terminated.
	 * This is also called whenever the server configuration is changed.
	 *
	 * @return {Promise.boolean}       Returns success/failure to connect
	 */
	async disconnect() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a local media stream
	 * Capture the local audio and video and returns the stream associated with them.
	 *
	 * If @temporary is `false` (default), then this will initialize the master stream, not the actual
	 * streams being sent to individual users. However, if a master stream was already created, it
	 * will automatically get closed and every individual streams derived from it that are being sent
	 * to connected users will be removed from the calls.
	 * Each established or subsequent calls will receive a copy of the created stream (A/V depending on user permissions)
	 *
	 * If @temporary is `true` then this only applies to a temporary stream and does not affect
	 * the master stream or any streams in existing calls.
	 * Note that this assumes only one temporary stream can be created at a time.
	 *
	 * @param {string|null} audioSrc       ID of the audio source to capture from or null to disable Audio
	 * @param {string|null} videoSrc       ID of the video source to capture from or null to disable Video
	 * @param {boolean} temporary          Whether to create a temporary stream or the master stream
	 * @return {Promise.MediaStream}       Returns the local stream or `null` if none could be created
	 */
	async initLocalStream(audioSrc, videoSrc, temporary = false) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Closes a local stream
	 * If @temporary is `false` (default), the master stream will be destroyed and all local streams removed
	 * from any existing calls.
	 * If the master stream is closed, any subsequent WebRTC calls will not have any streams sent to the peer.
	 * If @temporary is `true`, closes the temporary stream
	 *
	 * @param {Boolean} temporary          Whether to create a temporary stream or the master stream
	 * @return {Promise}
	 */
	async closeLocalStream(temporary = false) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Retreive the stream for a user
	 * Calling this with `game.user.id` is the proper way of retreiving the local master stream
	 * without re-initializing it.
	 * Any other user will return the remote stream of that user or `null` if no stream could be found.
	 *
	 * @param {String} userId            ID of the user
	 * @return {MediaStream}             The remote stream of the user
	 */
	getStreamForUser(userId) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of connected streams
	 * The result would be an array of objects in the form of {id, pc, local, remote}
	 * where id is the user's ID, pc is the RTCPeerConnection object associated to the peer,
	 * local is the local stream added to the call and remote is the remote user's stream
	 *
	 * @return {Array.Object}
	 */
	getConnectedStreams() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Assigns a stream to a video element
	 *
	 * @param {MediaStream} stream        The stream to assign
	 * @param {HTMLVideoElement} video    The video element to configure
	 */
	assignStreamToVideo(stream, video) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Sets the audio output on a video element
	 *
	 * Note: This feature is not supported by Firefox by default as it depends on the setSinkId
	 * API which is available behind the media.setsinkid.enabled settings in Firefox
	 * See https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId
	 *
	 * @param {HTMLVideoElement} video    The video element to configure
	 * @param {String} audioSinkId        ID of the audio output device
	 */
	setAudioOutput(video, audioSinkId) {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of available video sources
	 * The expected result is an object with the device id as key and its human-readable label as value
	 *
	 * @return {Promise.Object}
	 */
	async getVideoSources() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of available audio sources
	 * The expected result is an object with the device id as key and its human-readable label as value
	 *
	 * @return {Promise.Object}
	 */
	async getAudioSources() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of available audio output devices
	 * The expected result is an object with the device id as key and its human-readable label as value
	 *
	 * Note: This feature is not supported by Firefox by default as it depends on the enumerateDevices
	 * API which doesn't list output devices on Firefox 63+ unless the media.setsinkid.enabled settings
	 * is enabled.
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices
	 *
	 * @return {Promise.Object}
	 */
	async getAudioSinks() {
		throw Error('Not Implemented');
	}

	/* -------------------------------------------- */

	/**
	 * Notify of settings changes
	 * This can be used to act according
	 * @param {Object} changed     Object consisting of the changed settings in the form {key: value}
	 */
	onSettingsChanged(changed) {}
}

/**
 * WebRTC Settings abstraction class
 * This class serves to gather all webrtc related settings from
 * the world settings, client settings and user permissions and provide
 * access to them in a convenient way. It will also send notifications whenever
 * these settings change to make it easier to listen to those changes with a single hook.
 *
 * This class will also dynamically creates getters and setters for all the known webrtc world
 * and client settings and will also allow access to nested object values using a upperCase notation form.
 * There is therefore a `serverUrl` getter which can be used to access the `server.url` webrtc world setting.
 * The automatic creation of these properties allows the use of the settings object in handlebars directly
 * for example, since it's not possible to call `getUserSetting` within a template.
 *
 * The user settings can also be accessed via the `users` getter which returns a Proxy object.
 * The Proxy object will automatically generate object with their own getters and setters so that any
 * user ID being accessed will return the user setting's for that user.
 * As an example, doing `this.users['any-value-at-all'].volume` will return the default volume.
 */
class WebRTCSettings {
	constructor() {
		// Register the settings
		this.registerSettings();

		// Save the client and world settings and make a copy of the old settings so we can check for
		// changes whenever an update occurs

		/**
		 * Current client Settings
		 * This will contain any changed value via the setters on this class
		 * The client settings are all the settings that will only be saved on the client. They are things that
		 * should not affect any other player, such as the configured volume of a user, the position of a popout
		 * window, or the current client's audio and video device choices.
		 * @type {Object}
		 * @private
		 */
		this._clientSettings = this.clientSettings;

		/**
		 * Current world Settings
		 * This will contain any changed value via the setters on this class or if the world settings
		 * are modified by another user.
		 * The world settings are all the settings that affect the world, such as the AV mode, or the server
		 * settings.
		 * @type {Object}
		 * @private
		 */
		this._worldSettings = this.worldSettings;

		/**
		 * Previous client Settings
		 * This contains a saved copy of the client settings from the last onSettingsChanged notification.
		 * By comparing the current settings to the old, we can determine which values have changed.
		 * @type {Object}
		 * @private
		 */
		this._previousClientSettings = duplicate(this._clientSettings);

		/**
		 * Previous world Settings
		 * This contains a saved copy of the world settings from the last onSettingsChanged notification.
		 * By comparing the current settings to the old, we can determine which values have changed.
		 * @type {Object}
		 * @private
		 */
		this._previousWorldSettings = duplicate(this._worldSettings);

		/**
		 * Previous User entities settings
		 * This stores the user settings of all users in this world that are derived from the entity itself.
		 * This is used to compare if any of the user settings have changed.
		 * We need to store this because we could get notified of user data changes such as their 'role' which
		 * could affect (or not) their broadcasting permission, but without storing the old values based on their
		 * previous role/permissions, we can't derive which actual keys are affected by the data change.
		 * Same applies to the avatar. If a user doesn't have an avatar set and they change their character assignment,
		 * the avatar representation for that user will change, but it wouldn't if they have a custom player avatar.
		 * @type {Object}
		 * @private
		 */
		this._previousUsersEntitySettings = this._getAllUsersEntitySettings();

		/**
		 * ID of the timeout used to debounce the onSettingsChanged notification
		 * We need to debounce the settings changed notification in case multiple settings get set at once,
		 * without this we could get a spam of callbacks/hooks when simply moving or resizing a popout window.
		 * @type {Number}
		 * @private
		 */
		this._debounceId = 0;

		// Automatically create the getters and setters for this class.
		this._createProperties();

		// Always ensure there is a random server room
		if (this.serverRoom.length < 32) this.serverRoom = randomID(32);
	}

	/**
	 * Register world and client settings
	 */
	registerSettings() {
		game.settings.register('core', 'rtcWorldSettings', {
			name: 'WebRTC (Audio/Video Conferencing) World Settings',
			scope: 'world',
			default: this.constructor.getDefaultWorldSettings(),
			type: Object,
			onChange: () => this.onSettingsChanged(),
		});
		game.settings.register('core', 'rtcClientSettings', {
			name:
				'WebRTC (Audio/Video Conferencing) Client specific Configuration',
			scope: 'client',
			default: this.constructor.getDefaultClientSettings(),
			type: Object,
			onChange: () => this.onSettingsChanged(),
		});
	}

	/* -------------------------------------------- */
	/*  Default settings                            */
	/* -------------------------------------------- */

	/**
	 * Return default world settings
	 */
	static getDefaultWorldSettings() {
		return {
			mode: WebRTCSettings.WEBRTC_MODE.DISABLED,
			server: {
				type: 'FVTT',
				url: '',
				room: '',
				username: '',
				password: '',
			},
			turn: {
				type: 'server',
				url: '',
				username: '',
				password: '',
			},
		};
	}
	/**
	 * Return default client settings
	 */
	static getDefaultClientSettings() {
		return {
			videoSrc: 'default',
			audioSrc: 'default',
			audioSink: 'default',
			dockSize: 'medium',
			dockPosition: 'bottom',
			hidePlayerList: false,
			muteAll: false,
			voice: {
				mode: WebRTCSettings.VOICE_MODES.PTT,
				pttKey: 192, // Tilde
				pttName: '`',
				pttMouse: false,
				pttDelay: 100,
				activityThreshold: -45,
			},
			users: {},
		};
	}

	/**
	 * Return default user settings
	 */
	static getDefaultUserSettings() {
		return {
			popout: false,
			x: 100,
			y: 100,
			z: 0,
			width: 320,
			volume: 1.0,
			muted: false,
			hidden: false,
			blocked: false,
		};
	}

	/* -------------------------------------------- */
	/*  Get/Set APIs                                */
	/* -------------------------------------------- */

	/**
	 * Get the value of a webrtc client setting
	 * Returns the client setting if set or the default value
	 * @param {String} key   The name of the setting
	 */
	getClientSetting(key) {
		// setting name could be in dot notation
		let value = getProperty(this._clientSettings, key);
		if (value !== undefined) return value;
		return getProperty(this.constructor.getDefaultClientSettings(), key);
	}

	/**
	 * Set the value of a webrtc client setting
	 * Sets the client setting if different from the existing value
	 * @param {String} key    The name of the setting
	 * @param {Object} value  The new value
	 */
	setClientSetting(key, value) {
		// Only change the value if different from the current value.
		// This way, default values don't get defined and no settingsChanged event
		// is sent needlessly
		if (getProperty(this._clientSettings, key) === value) return;
		setProperty(this._clientSettings, key, value);
		this.clientSettings = this._clientSettings;
	}

	/**
	 * Get the value of a webrtc world setting
	 * Returns the world setting if set or the default value
	 * @param {String} key   The name of the setting
	 */
	getWorldSetting(key) {
		// setting name could be in dot notation
		let value = getProperty(this._worldSettings, key);
		if (value !== undefined) return value;
		return getProperty(this.constructor.getDefaultWorldSettings(), key);
	}

	/**
	 * Set the value of a webrtc world setting
	 * Sets the world setting if different from the existing value
	 * @param {String} key    The name of the setting
	 * @param {Object} value  The new value
	 */
	setWorldSetting(key, value) {
		// Only change the value if different from the current value.
		// This way, default values don't get defined and no settingsChanged event
		// is sent needlessly
		if (getProperty(this._worldSettings, key) === value) return;
		setProperty(this._worldSettings, key, value);
		this.worldSettings = this._worldSettings;
	}

	/**
	 * Get a specific user's configuration setting value
	 * This returns a user's setting or its default value. It will also agreggate data from the user's entity itself
	 * @param {String} userId    The ID of the user whose setting to access
	 * @param {String} key       The name of the setting to retreive
	 */
	getUserSetting(userId, key) {
		// If getting an entity field, get the user entity and return its value
		if (
			['canBroadcastAudio', 'canBroadcastVideo', 'avatar'].includes(key)
		) {
			let user = game.users.get(userId);
			// Make sure the user is valid
			if (user) {
				if (key == 'canBroadcastVideo')
					return user.hasPermission('broadcastVideo');
				if (key == 'canBroadcastAudio')
					return user.hasPermission('broadcastAudio');
				if (key == 'avatar') return user.avatar;
			}
			return undefined;
		}
		// Get user setting from client settings, or get deault value if not set
		let value = getProperty(
			this.getClientSetting('users'),
			`${userId}.${key}`
		);
		if (value !== undefined) return value;
		return getProperty(this.constructor.getDefaultUserSettings(), key);
	}

	/**
	 * Set a specific user's configuration setting value
	 * This will either set the value in the client settings or will update the user entity itself, depending on the setting
	 * @param {String} userId    The ID of the user whose setting to access
	 * @param {String} key      The name of the setting to retreive
	 * @param {Object} value     The value to set
	 */
	setUserSetting(userId, key, value) {
		if (this.getUserSetting(userId, key) === value) return;
		if (
			['canBroadcastAudio', 'canBroadcastVideo', 'avatar'].includes(key)
		) {
			let user = game.users.get(userId);
			if (user) {
				if (key === 'canBroadcastVideo')
					user.setPermission('broadcastVideo', value);
				if (key === 'canBroadcastAudio')
					user.setPermission('broadcastAudio', value);
				if (key === 'avatar') user.update({ avatar: value });
			}
			return;
		}
		// Set the new value and replace the user's dictionary
		// We duplicate it here so the setClientSetting recognizes the data as being different
		let users = duplicate(this.getClientSetting('users'));
		setProperty(users, `${userId}.${key}`, value);
		this.setClientSetting('users', users);
	}

	/* -------------------------------------------- */
	/*  Custom getters and setters                  */
	/* -------------------------------------------- */

	/**
	 * Require the server to be using https protocol in order for AV to not be disabled
	 * @type {number}
	 */
	get mode() {
		if (window.location.protocol === 'http:')
			return WebRTCSettings.WEBRTC_MODE.DISABLED;
		return this.getWorldSetting('mode');
	}
	set mode(value) {
		this.setWorldSetting('mode', value);
	}

	/**
	 * The webrtc world settings
	 * @type {Object}
	 */
	get worldSettings() {
		return game.settings.get('core', 'rtcWorldSettings');
	}
	set worldSettings(value) {
		game.settings.set('core', 'rtcWorldSettings', value);
	}

	/**
	 * The webrtc client settings
	 * @type {Object}
	 */
	get clientSettings() {
		return game.settings.get('core', 'rtcClientSettings');
	}
	set clientSettings(value) {
		// Since settings has a client scope, this should technically be synchronous
		game.settings.set('core', 'rtcClientSettings', value);
	}

	/**
	 * Get the webrtc debug configuration
	 * @type {Object}
	 */
	get debug() {
		return CONFIG.debug.av;
	}
	set debug(value) {
		if (CONFIG.debug.av !== value) {
			let changed = { debug: value };
			CONFIG.debug.av = value;
			Hooks.callAll('rtcSettingsChanged', this, changed);
			game.webrtc.onSettingsChanged(changed);
		}
	}

	/**
	 * Get the webrtc debug value in CONFIG for the AV Client
	 * @type {Object}
	 */
	get debugClient() {
		return CONFIG.debug.avclient;
	}
	set debugClient(value) {
		if (CONFIG.debug.avclient !== value) {
			let changed = { debugClient: value };
			CONFIG.debug.avclient = value;
			Hooks.callAll('rtcSettingsChanged', this, changed);
			game.webrtc.onSettingsChanged(changed);
		}
	}

	/* -------------------------------------------- */
	/*  Settings changed handlers                   */
	/* -------------------------------------------- */

	/**
	 * Get notified that a setting has changed
	 */
	onSettingsChanged() {
		/* Debounce a setting change so if config is changed via multiple setter calls, we have time
		 * to save all the config changes and send one changed event instead of multiple.
		 * This also prevents a reload from happening before all settings are saved in case a mode
		 * change happens for example.
		 */
		if (this._debounceId > 0) clearTimeout(this._debounceId);
		this._debounceId = setTimeout(
			this._onSettingsChangedDebounced.bind(this),
			100
		);
	}

	/**
	 * Get notified that a setting has changed and no changes occured within the last 100ms
	 * This will do a diff of all settings and send a notification to the game.webrtc and via a hook
	 * that shows which settings have been changed.
	 * @private
	 */
	_onSettingsChangedDebounced() {
		this._debounceId = 0;

		// Update our values in case they were changed by a remote user (in the case of world settings)
		this._clientSettings = this.clientSettings;
		this._worldSettings = this.worldSettings;

		// Find the changed values of the client, world and user db-stored settings (permissions and avatar)
		let changedClient = diffObject(
			this._previousClientSettings,
			this._clientSettings
		);
		let changedWorld = diffObject(
			this._previousWorldSettings,
			this._worldSettings
		);
		let changedUsers = diffObject(
			this._previousUsersEntitySettings,
			this._getAllUsersEntitySettings()
		);

		// Find all the changed values
		let changed = mergeObject(changedClient, changedWorld, {
			inplace: false,
		});
		if (Object.keys(changedUsers).length > 0)
			changed = mergeObject(changed, { users: changedUsers });

		// If there were no actual changes, no need to notify anyone
		if (isObjectEmpty(changed)) return;

		// Flatten the changed values to match the getters/setters we use.
		// We don't need to flatten the users dictionary though since we can't use upperCase notation for the users object.
		delete changedClient.users;
		let flat_changes = flattenObject(
			mergeObject(changedClient, changedWorld)
		);
		for (let key in flat_changes) {
			let name = WebRTCSettings._dotNotationToUpperCase(key);
			changed[name] = flat_changes[key];
		}

		// If a custom server is chosen but no URL is specified, change the server Type back to 'FVTT'
		// we will get debounced and called again, so we can return now.
		if (this.serverUrl === '' && this.serverType === 'custom') {
			this.serverType = 'FVTT';
			return;
		}

		// If server URL changed, then we need to generate a new room ID to avoid leaking
		// the room ID when switching servers. The onSettingsChanged will get debounced again.
		if (
			changed.serverUrl !== undefined &&
			(changed.serverRoom === undefined || changed.serverRoom.length < 32)
		) {
			this.serverRoom = randomID(32);
			return;
		}

		// Store the new settings values and notify game.webrtc and hooks of the new changes.
		this._previousClientSettings = duplicate(this._clientSettings);
		this._previousWorldSettings = duplicate(this._worldSettings);
		this._previousUsersEntitySettings = this._getAllUsersEntitySettings();
		game.webrtc.onSettingsChanged(changed);
		Hooks.callAll('rtcSettingsChanged', this, changed);
	}

	/**
	 * Converts a property name from the "dot.notation.format" into an "upperaseNotationFormat" instead.
	 * This is used to convert properties such as "server.url" into a suitable getter "serverUrl" name
	 * for example.
	 * @param {String} name    The property name to convert
	 * @return {String}
	 * @private
	 */
	static _dotNotationToUpperCase(name) {
		return name.replace(/\.[a-z]/g, match => match[1].toUpperCase());
	}

	/**
	 * Get all the entity related user settings
	 * This is used to compare when an entity setting has changed, such as the avatar
	 * or the permissions of a user
	 *
	 * @private
	 */
	_getAllUsersEntitySettings() {
		let all_permissions = {};
		for (let user of game.users.entities) {
			for (let key of [
				'canBroadcastAudio',
				'canBroadcastVideo',
				'avatar',
			]) {
				setProperty(
					all_permissions,
					`${user.id}.${key}`,
					this.getUserSetting(user.id, key)
				);
			}
		}
		return all_permissions;
	}

	/* -------------------------------------------- */
	/*  Magic                                       */
	/* -------------------------------------------- */

	/**
	 * Create properties on this object for accessing client and world settings
	 * This creates getters and setters for the client and world settings based on the default values
	 * The getters/setters functions get bound in the _createGettersAndSetters so we can pass them directly
	 * @private
	 */
	_createProperties() {
		WebRTCSettings._createGettersAndSetters(
			this,
			this.constructor.getDefaultClientSettings(),
			this.getClientSetting,
			this.setClientSetting
		);
		WebRTCSettings._createGettersAndSetters(
			this,
			this.constructor.getDefaultWorldSettings(),
			this.getWorldSetting,
			this.setWorldSetting
		);
	}

	/**
	 * Define getters and setters on an object based on the keys in the `settings` dictionary.
	 * Each key in the `settings` object will get its own getter and setter as well
	 * as a getter/setter for each sub-field in a upperCase notation to make it easier to
	 * access any of the values through a getter/setter.
	 *
	 * @param {Object} obj           The object to create setters and getters on
	 * @param {Object} settings      The settings to create getters and setters from
	 * @param {Function} getter      The getter callback
	 * @param {Function} setter      The setter callback
	 * @private
	 */
	static _createGettersAndSetters(obj, settings, getter, setter) {
		// Creater a getter and a setter for every key in the settings
		for (let key in settings) {
			// Don't overwrite custom functions or custom getters/setters
			if (
				obj.hasOwnProperty(key) ||
				obj.constructor.prototype.hasOwnProperty(key)
			)
				continue;
			Object.defineProperty(obj, key, {
				get: getter.bind(obj, key),
				set: setter.bind(obj, key),
			});
		}

		// flatten the settings keys and create a getter/setter for each flat key in upperCase notation
		let flat_settings = flattenObject(settings);
		let flat_keys = Object.keys(flat_settings);
		for (let key of flat_keys) {
			// Replace names from dot notation to upperCase notation, so 'server.url'
			// can be accessed as 'serverUrl' for example
			let name = WebRTCSettings._dotNotationToUpperCase(key);
			// Don't overwrite custom functions or previously set getters/setters
			if (
				obj.hasOwnProperty(name) ||
				obj.constructor.prototype.hasOwnProperty(name)
			)
				continue;
			Object.defineProperty(obj, name, {
				get: getter.bind(obj, key),
				set: setter.bind(obj, key),
			});
		}
	}

	/**
	 * Create a proxy object that calls a getter and setter function whenever one of its fields is accessed
	 * @param {Object} obj        The object to proxy
	 * @param {Function} getter   The getter to call
	 * @param {Function} setter   The setter to call
	 * @private
	 */
	_createProxy(obj, getter, setter) {
		var proxyHandler = {
			get: function(obj, name) {
				return getter(name);
			},
			set: function(obj, name, value) {
				setter(name, value);
				// We need to return true to tell the Proxy that the set was handled
				return true;
			},
		};
		return new Proxy(obj, proxyHandler);
	}

	/* -------------------------------------------- */
	/*  User specific getters and setters           */
	/* -------------------------------------------- */

	/**
   * Get the users configuration settings
   * This returns a proxy object which will automatically call _getUserProxy and _setUserObject for each user entry that is accessed.
   * @type {Object}

   */
	get users() {
		let obj = this.getClientSetting('users');
		return this._createProxy(
			obj,
			this._getUserProxy.bind(this),
			this._setUserObject.bind(this)
		);
	}
	set users(value) {
		this.setClientSetting('users', value);
	}

	/**
	 * Get a specific user's configuration settings
	 * This returns a proxy object which will automatically call `this.getUserSetting` and `this.setUserSetting` for each user setting accessed
	 * @param {String} userId    The ID of the user whose settings to access
	 * @private
	 */
	_getUserProxy(userId) {
		let obj = this.getClientSetting('users')[userId] || {};
		return this._createProxy(
			obj,
			this.getUserSetting.bind(this, userId),
			this.setUserSetting.bind(this, userId)
		);
	}

	/**
	 * Set a specific user's configuration settings
	 *
	 * @param {String} userId    The ID of the user whose settings to set
	 * @param {Object} value     The user's settings to set
	 * @private
	 */
	_setUserObject(userId, value) {
		// Need to duplicate, otherwise we modify the local value and the setClientSetting thinks nothing has changed
		// We also can't use the `this.users` getter since it returns the proxy object. But we can use its setter.
		let users = duplicate(this.getClientSetting('users'));
		users[userId] = value;
		this.users = users;
	}
}

/**
 * WebRTC Mode, Disabled, Audio only, Video only, Audio & Video
 * @type {Object}
 */
WebRTCSettings.WEBRTC_MODE = {
	DISABLED: 0,
	AUDIO: 1,
	VIDEO: 2,
	AUDIO_VIDEO: 3,
};

WebRTCSettings.VOICE_MODES = {
	ALWAYS: 'always',
	ACTIVITY: 'activity',
	PTT: 'ptt',
};
/**
 * The default Actor Sheet
 *
 * This Application is responsible for rendering an actor's attributes and allowing the actor to be edited.
 *
 * System modifications may elect to override this class to better suit their own game system by re-defining the value
 * ``CONFIG.Actor.sheetClass``.

 * @type {BaseEntitySheet}
 *
 * @param actor {Actor}                 The Actor instance being displayed within the sheet.
 * @param [options] {Object}            Additional options which modify the rendering of the Actor's sheet.
 * @param [options.editable] {Boolean}  Is the Actor editable? Default is true.
 */
class ActorSheet extends BaseEntitySheet {
	constructor(...args) {
		super(...args);

		/**
		 * If this Actor Sheet represents a synthetic Token actor, reference the active Token
		 * @type {Token}
		 */
		this.token = this.object.token;
	}

	/* -------------------------------------------- */

	/**
	 * Default rendering and configuration options used for the ActorSheet and its subclasses.
	 * See Application.defaultOptions and FormApplication.defaultOptions for more details.
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			height: 720,
			width: 800,
			template: 'templates/sheets/actor-sheet.html',
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnUnfocus: true,
			resizable: true,
			baseApplication: 'ActorSheet',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Define a unique and dynamic element ID for the rendered ActorSheet application
	 * @return {string}
	 */
	get id() {
		const actor = this.actor;
		let id = `actor-${actor.id}`;
		if (actor.isToken) id += `-${actor.token.id}`;
		return id;
	}

	/* -------------------------------------------- */

	/**
	 * The displayed window title for the sheet - the entity name by default
	 * @type {String}
	 */
	get title() {
		return this.token && !this.token.data.actorLink
			? `[Token] ${this.actor.name}`
			: this.actor.name;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Actor entity
	 * @type {Actor}
	 */
	get actor() {
		return this.object;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare data for rendering the Actor sheet
	 * The prepared data object contains both the actor data as well as additional sheet options
	 */
	getData() {
		const data = super.getData();

		// Entity data
		data.actor = data.entity;
		data.data = data.entity.data;

		// Owned items
		data.items = data.actor.items;
		data.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));
		return data;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();

		// Token Configuration
		let canConfigure =
			this.options.editable &&
			(game.user.isGM || (this.actor.owner && game.user.isTrusted));
		if (canConfigure) {
			buttons = [
				{
					label: 'Sheet',
					class: 'configure-sheet',
					icon: 'fas fa-cog',
					onclick: ev => this._onConfigureSheet(ev),
				},
				{
					label: this.token ? 'Token' : 'Prototype Token',
					class: 'configure-token',
					icon: 'fas fa-user-circle',
					onclick: ev => this._onConfigureToken(ev),
				},
			].concat(buttons);
		}
		return buttons;
	}

	/* -------------------------------------------- */

	/**
	 * Remove references to an active Token when the sheet is closed
	 * See Application.close for more detail
	 * @return {Promise}
	 */
	async close() {
		this.token = null;
		return super.close();
	}

	/* -------------------------------------------- */
	/*  Event Listeners                             */
	/* -------------------------------------------- */

	/**
	 * Activate the default set of listeners for the Actor Sheet
	 * These listeners handle basic stuff like form submission or updating images
	 *
	 * @param html {JQuery}     The rendered template ready to have listeners attached
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Everything below is only needed if the sheet is editable
		if (!this.options.editable) return;

		// Update the sheet when we un-focus an input unless we have acquired focus on another input
		html.find('input').focusout(this._onUnfocus.bind(this));

		// Update the sheet when a select field is changed
		html.find('select').change(this._onSubmit.bind(this));

		// Make the Actor sheet droppable for Items
		this.form.ondragover = ev => this._onDragOver(ev);
		this.form.ondrop = ev => this._onDrop(ev);

		// Support Image updates
		html.find('img[data-edit="img"]').click(ev => this._onEditImage(ev));
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the prototype Token for the Actor
	 * @private
	 */
	_onConfigureToken(event) {
		event.preventDefault();

		// Determine the Token for which to configure
		const token = this.token || new Token(this.actor.data.token);

		// Render the Token Config application
		new TokenConfig(token, {
			left: Math.max(this.position.left - 560 - 10, 10),
			top: this.position.top,
			configureDefault: !this.token,
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the default sheet used by this Actor
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.actor, {
			top: this.position.top + 40,
			left: this.position.left + (this.position.width - 400) / 2,
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		new FilePicker({
			type: 'image',
			current: this.actor.data.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
		}).browse(this.actor.data.img);
	}

	/* -------------------------------------------- */

	/**
	 * Default handler for beginning a drag-drop workflow of an Owned Item on an Actor Sheet
	 * @param event
	 * @private
	 */
	_onDragItemStart(event) {
		const li = event.currentTarget;
		const item = this.actor.getOwnedItem(li.dataset.itemId);
		const dragData = {
			type: 'Item',
			actorId: this.actor.id,
			data: item.data,
		};
		if (this.actor.isToken) dragData.tokenId = this.actor.token.id;
		event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
	}

	/* -------------------------------------------- */

	/**
	 * Allow the Actor sheet to be a displayed as a valid drop-zone
	 * @private
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle dropped data on the Actor sheet
	 * @private
	 */
	async _onDrop(event) {
		event.preventDefault();

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
			if (data.type !== 'Item') return;
		} catch (err) {
			return false;
		}

		// Case 1 - Import from a Compendium pack
		const actor = this.actor;
		if (data.pack) {
			return actor.importItemFromCollection(data.pack, data.id);
		}

		// Case 2 - Data explicitly provided
		else if (data.data) {
			let sameActor = data.actorId === actor._id;
			if (sameActor && actor.isToken)
				sameActor = data.tokenId === actor.token.id;
			if (sameActor) return this._onSortItem(event, data.data);
			// Sort existing items
			else
				return actor.createEmbeddedEntity(
					'OwnedItem',
					duplicate(data.data)
				); // Create a new Item
		}

		// Case 3 - Import from World entity
		else {
			let item = game.items.get(data.id);
			if (!item) return;
			return actor.createEmbeddedEntity(
				'OwnedItem',
				duplicate(item.data)
			);
		}
	}

	/* -------------------------------------------- */
	/*  Owned Item Sorting
  /* -------------------------------------------- */

	/**
	 * Handle a drop event for an existing Owned Item to sort that item
	 * @param {Event} event
	 * @param {Object} itemData
	 * @private
	 */
	_onSortItem(event, itemData) {
		// TODO - for now, don't allow sorting for Token Actor ovrrides
		if (this.actor.isToken) return;

		// Get the drag source and its siblings
		const source = this.actor.getOwnedItem(itemData._id);
		const siblings = this._getSortSiblings(source);

		// Get the drop target
		const dropTarget = event.target.closest('.item');
		const targetId = dropTarget ? Number(dropTarget.dataset.itemId) : null;
		const target = siblings.find(s => s.data._id === targetId);

		// Ensure we are only sorting like-types
		if (target && source.data.type !== target.data.type) return;

		// Perform the sort
		const sortUpdates = SortingHelpers.performIntegerSort(source, {
			target: target,
			siblings,
		});
		const updateData = sortUpdates.map(u => {
			const update = u.update;
			update._id = u.target.data._id;
			return update;
		});

		// Perform the update
		return this.actor.updateManyEmbeddedEntities('OwnedItem', updateData);
	}

	/* -------------------------------------------- */

	_getSortSiblings(source) {
		return this.actor.items.filter(
			i =>
				i.data.type === source.data.type &&
				i.data._id !== source.data._id
		);
	}
}
/**
 * Audio/Video Conferencing Configuration Sheet
 * @type {FormApplication}
 */
class AVConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize('WEBRTC.Title'),
			id: 'av-config',
			template: 'templates/sheets/av-config.html',
			popOut: true,
			width: 480,
			height: 'auto',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Prepare rendering data for the AVConfig form
	 * @return {Promise.Object}
	 */
	async getData() {
		const videoSources = await this.object.client.getVideoSources();
		const audioSources = await this.object.client.getAudioSources();
		const audioSinks = await this.object.client.getAudioSinks();
		const { videoSrc, audioSrc, audioSink } = this.object.settings;

		// If the currently chosen device is unavailable, display a separate option for 'unavailable device (use default)'
		const videoSrcUnavailable =
			videoSrc &&
			videoSrc !== 'default' &&
			!Object.keys(videoSources).includes(videoSrc);
		const audioSrcUnavailable =
			audioSrc &&
			audioSrc !== 'default' &&
			!Object.keys(audioSources).includes(audioSrc);
		const audioSinkUnavailable =
			audioSink &&
			audioSink !== 'default' &&
			!Object.keys(audioSinks).includes(audioSink);
		const isSSL = window.location.protocol === 'https:';

		// Return data to the template
		return {
			user: game.user,
			settings: this.object.settings,
			canSelectMode: game.user.isGM && isSSL,
			noSSL: !isSSL,
			videoSources,
			audioSources,
			audioSinks: isObjectEmpty(audioSinks) ? false : audioSinks,
			videoSrcUnavailable,
			audioSrcUnavailable,
			audioSinkUnavailable,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate event listeners for the AVConfig sheet
	 * Listen to tab event changes and server/turn config changes
	 * @param html {jQuery|HTMLElement}   The rendered HTML for the app
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Tabbed navigation
		new Tabs(html.find('.tabs'), {
			initial:
				this._tab ||
				(this.object.settings.mode > 0 ? 'devices' : 'general'),
			callback: clicked => (this._tab = clicked.data('tab')),
		});

		// Push-to-talk key assignment
		html.find('input[name="voicePttName"]')
			.keydown(this._onPTTKeyDown.bind(this))
			.mousedown(this._onPTTMouseDown.bind(this));

		// Options below are GM only
		if (!game.user.isGM) return;

		// Change the server type
		html.find('select[name=serverType]').change(
			this._onServerTypeChanged.bind(this)
		);

		// Change the turn type
		html.find('select[name=turnType]').change(
			this._onTurnTypeChanged.bind(this)
		);

		// Activate or de-activate the custom server and turn configuration sections based on current settings
		this._setConfigSectionEnabled(
			'.webrtc-custom-server-config',
			this.object.settings.serverType === 'custom'
		);
		this._setConfigSectionEnabled(
			'.webrtc-custom-turn-config',
			this.object.settings.turnType === 'custom'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Set a section's input to enabled or disabled
	 * @param {string} selector    Selector for the section to enable or disable
	 * @param {boolean} enabled    Whether to enable or disable this section
	 * @private
	 */
	_setConfigSectionEnabled(selector, enabled = true) {
		let section = this.element.find(selector);
		if (section) {
			section.css('opacity', enabled ? 1.0 : 0.5);
			section.find('input').prop('disabled', !enabled);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Callback when the server type changes
	 * Will enable or disable the server section based on whether the user selected a custom server or not
	 * @param {Event} event   The event that triggered the server type change
	 * @private
	 */
	_onServerTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(
			'.webrtc-custom-server-config',
			choice === 'custom'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Callback when the turn server type changes
	 * Will enable or disable the turn section based on whether the user selected a custom turn or not
	 * @param {Event} event   The event that triggered the turn server type change
	 * @private
	 */
	_onTurnTypeChanged(event) {
		event.preventDefault();
		const choice = event.currentTarget.value;
		this._setConfigSectionEnabled(
			'.webrtc-custom-turn-config',
			choice === 'custom'
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the assignment of a push-to-talk/push-to-mute key
	 * @param {Event} event
	 * @private
	 */
	_onPTTKeyDown(event) {
		event.preventDefault();
		event.target.value = event.originalEvent.key.toUpperCase();
		const form = event.target.form;
		form['voicePttKey'].value = event.originalEvent.keyCode;
		form['voicePttMouse'].value = false;
	}

	/**
	 * Handle the assignment of a push-to-talk/push-to-mute mouse key
	 * @param {Event} event
	 * @private
	 */
	_onPTTMouseDown(event) {
		if (document.activeElement !== event.target) return;
		event.preventDefault();
		const button = event.originalEvent.button;
		event.target.value = `MOUSE-${button}`;
		const form = event.target.form;
		form['voicePttKey'].value = button;
		form['voicePttMouse'].value = true;
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * For audio and video sources, an empty string option indicates sending is disabled.
	 * This is stored in the setting as null, rather than ""
	 *
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		formData.videoSrc = formData.videoSrc || null;
		formData.audioSrc = formData.audioSrc || null;
		for (let key in formData) this.object.settings[key] = formData[key];
	}
}
/**
 * Configure the Combat tracker to display additional information as appropriate
 * @type {FormApplication}
 */
class CombatTrackerConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'combat-config',
			title: game.i18n.localize('COMBAT.Settings'),
			classes: ['sheet', 'combat-sheet'],
			template: 'templates/sheets/combat-config.html',
			width: 420,
		});
	}

	/* -------------------------------------------- */

	async getData() {
		return {
			settings: game.settings.get('core', Combat.CONFIG_SETTING),
		};
	}

	/* -------------------------------------------- */

	_updateObject(event, formData) {
		game.settings.set('core', Combat.CONFIG_SETTING, {
			resource: formData.resource,
			skipDefeated: formData.skipDefeated,
		});
	}
}

/**
 * Edit a folder, configuring its name and appearance
 * @type {FormApplication}
 */
class FolderConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'folder-edit';
		options.classes = ['sheet'];
		options.template = 'templates/sidebar/folder-edit.html';
		options.width = 400;
		return options;
	}

	/* -------------------------------------------- */

	get title() {
		if (this.object._id)
			return `${game.i18n.localize('FOLDER.Update')}: ${
				this.object.name
			}`;
		return game.i18n.localize('FOLDER.Create');
	}

	/* -------------------------------------------- */

	async getData() {
		return {
			folder: this.object.data,
			submitText: game.i18n.localize(
				this.object._id ? 'FOLDER.Update' : 'FOLDER.Create'
			),
		};
	}

	/* -------------------------------------------- */

	_updateObject(event, formData) {
		if (!formData.parent) formData.parent = null;
		if (!this.object._id) Folder.create(formData);
		else this.object.update(formData);
	}
}

/**
 * An Image Popout Application
 * Provides optional support to edit the image path being viewed
 * @type {Application}
 * @param image {String}       The image being viewed
 * @param options {Object}     Standard Application rendering options
 */
class ImagePopout extends FormApplication {
	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		mergeObject(options, {
			template: 'templates/apps/image-popout.html',
			classes: ['image-popout', 'dark'],
			editable: false,
			resizable: true,
			shareable: false,
		});
		return options;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = super.getData();
		data.image = this.object;
		data.title = this.title;
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		this.position = await this.constructor.getPosition(this.object);
		return super._render(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		if (game.user.isGM && this.options.shareable) {
			buttons.unshift({
				label: 'Show Players',
				class: 'share-image',
				icon: 'fas fa-eye',
				onclick: ev => this.shareImage(),
			});
		}
		return buttons;
	}

	/* -------------------------------------------- */
	/*  Helper Methods
  /* -------------------------------------------- */

	/**
	 * Determine the correct position and dimensions for the displayed image
	 * @returns {Object}    The positioning object which should be used for rendering
	 * @private
	 */
	static async getPosition(img) {
		if (!img) return { width: 720, height: window.innerHeight * 0.8 };
		const position = {};
		let size;
		try {
			size = await this.getImageSize(img);
		} catch (err) {
			return { width: 720, height: window.innerHeight * 0.8 };
		}
		let wh = window.innerHeight,
			ww = window.innerWidth,
			wr = window.innerWidth / window.innerHeight,
			ir = size[0] / size[1];
		if (ir > wr) {
			position.width = Math.min(size[0] * 2, parseInt(0.95 * ww));
			position.height = parseInt(position.width / ir);
		} else {
			position.height = Math.min(size[1] * 2, parseInt(0.95 * wh));
			position.width = parseInt(position.height * ir);
		}
		position.top = (wh - position.height) / 2;
		position.left = (ww - position.width) / 2;
		return position;
	}

	/* -------------------------------------------- */

	/**
	 * Determine the Image dimensions given a certain path
	 * @return {Promise<Array.<Number>>}
	 */
	static getImageSize(path) {
		return new Promise((resolve, reject) => {
			let img = new Image();
			img.onload = function() {
				resolve([this.width, this.height]);
			};
			img.onerror = reject;
			img.src = path;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Share the displayed image with other connected Users
	 */
	shareImage() {
		game.socket.emit('shareImage', {
			image: this.object,
			title: this.options.title,
			entity: this.options.entity || null,
		});
	}
}

/**
 * The default Item Sheet
 *
 * This Application is responsible for rendering an item's attributes and allowing the item to be edited.
 *
 * System modifications may elect to override this class to better suit their own game system by re-defining the value
 * ``CONFIG.Item.sheetClass``.

 * @type {BaseEntitySheet}
 *
 * @param item {Item}                   The Item instance being displayed within the sheet.
 * @param [options] {Object}            Additional options which modify the rendering of the item.
 * @param [options.editable] {Boolean}  Is the item editable? Default is true.
 */
class ItemSheet extends BaseEntitySheet {
	/** @extends {BaseEntitySheet.defaultOptions} */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			template: 'templates/sheets/item-sheet.html',
			width: 500,
			closeOnSubmit: false,
			submitOnClose: true,
			submitOnUnfocus: true,
			resizable: true,
			baseApplication: 'ItemSheet',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Provide a unique CSS ID for owned Item sheets
	 * @type {String}
	 */
	get id() {
		if (this.actor) return `actor-${this.actor.id}-item-${this.item.id}`;
		else return super.id;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Item entity
	 * @type {Item}
	 */
	get item() {
		return this.object;
	}

	/* -------------------------------------------- */

	/**
	 * The Actor instance which owns this item. This may be null if the item is unowned.
	 * @type {Actor}
	 */
	get actor() {
		return this.item.actor;
	}

	/* -------------------------------------------- */

	/**
	 * Customize the data provided to the item sheet for rendering. By default we just duplicate the item data.
	 */
	getData() {
		const data = super.getData();
		data.item = data.entity;
		data.data = data.entity.data;
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Extend the Header Button configuration for the ActorSheet to add Token configuration buttons
	 * See Application._getHeaderButtons for documentation of the return Array structure.
	 * @return {Array.<Object>}
	 * @private
	 */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		let canConfigure = this.isEditable && game.user.isTrusted;
		if (!canConfigure) return buttons;

		// Add a Sheet Configuration button
		buttons.unshift({
			label: 'Sheet',
			class: 'configure-sheet',
			icon: 'fas fa-cog',
			onclick: ev => this._onConfigureSheet(ev),
		});

		// Compendium Import
		if (this.entity.compendium) {
			buttons.unshift({
				label: 'Import',
				class: 'import',
				icon: 'fas fa-download',
				onclick: async () => {
					await this.close();
					this.entity.collection.importFromCollection(
						this.options.compendium,
						this.entity._id
					);
				},
			});
		}
		return buttons;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate listeners which provide interactivity for item sheet events
	 * @param html {jQuery}   The HTML object returned by template rendering
	 */
	activateListeners(html) {
		super.activateListeners(html);
		if (!this.options.editable) return;

		// Update the sheet when a select field is changed
		html.find('select').change(ev => this._onSubmit(ev));

		// Update when we change the image
		html.find('img[data-edit="img"]').click(ev => this._onEditImage(ev));
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to configure the default sheet used by this Item
	 * @private
	 */
	_onConfigureSheet(event) {
		event.preventDefault();
		new EntitySheetConfig(this.item, {
			top: this.position.top + 40,
			left: this.position.left + (this.position.width - 400) / 2,
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the item image
	 * @private
	 */
	_onEditImage(event) {
		new FilePicker({
			type: 'image',
			current: this.item.data.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
		}).browse(this.item.data.img);
	}
}

CONFIG.Item.sheetClass = ItemSheet;

/**
 * A Macro configuration sheet
 * @extends {BaseEntitySheet}
 *
 * @see {@link Macro} The Macro Entity which is being configured
 */
class MacroConfig extends BaseEntitySheet {
	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['sheet', 'macro-sheet'],
			template: 'templates/sheets/macro-config.html',
			width: 560,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		return `macro-config-${this.object._id}`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = super.getData();
		data.macroTypes = duplicate(game.system.entityTypes.Macro);
		if (!Macros.canUseScripts(game.user))
			data.macroTypes.findSplice(t => t === 'script');
		data.macroScopes = CONST.MACRO_SCOPES;
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		// Support Image updates
		html.find('img[data-edit="img"]').click(ev => this._onEditImage(ev));
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @private
	 */
	_onEditImage(event) {
		new FilePicker({
			type: 'image',
			current: this.object.data.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
		}).browse(this.object.data.img);
	}

	/* -------------------------------------------- */

	/** @override */
	_updateObject(event, formData) {
		if (!this.object.data._id) {
			return Macro.create(formData, { displaySheet: false });
		} else {
			super._updateObject(event, formData);
		}
	}
}

CONFIG.Macro.sheetClass = MacroConfig;

/**
 * Template Measurement Config Sheet
 * @type {FormApplication}
 *
 * @param template {MeasureTemplate} The template object being configured
 * @param options {Object}           Additional application rendering options
 * @param options.preview {Boolean}  Configure a preview version of a sound which is not yet saved
 */
class MeasuredTemplateConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'template-config';
		options.classes = ['sheet', 'template-sheet'];
		options.title = 'Measurement Template Configuration';
		options.template = 'templates/scene/template-config.html';
		options.width = 400;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			templateTypes: CONFIG.templateTypes,
			gridUnits: canvas.scene.data.gridUnits,
			submitText: this.options.preview ? 'Create' : 'Update',
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (!game.user.isTrusted)
			throw 'You do not have the ability to configure a MeasurementTemplate.';
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(canvas.scene._id, formData);
		} else this.object.constructor.create(canvas.scene._id, formData);
	}
}

/* -------------------------------------------- */

/**
 * A generic application for configuring permissions for various Entity types
 * @type {BaseEntitySheet}
 *
 * @param entity {Entity}               The Entity instance for which permissions are being configured.
 * @param [options] {Object}            Application options.
 */
class PermissionControl extends BaseEntitySheet {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'permission';
		options.template = 'templates/apps/permission.html';
		return options;
	}

	/* -------------------------------------------- */

	get title() {
		return `${this.entity.name}: Permission Control`;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare permissions data as an array of users and levels for which to configure the entity
	 */
	getData() {
		const e = this.entity;
		const data = {
			entity: e,
			users: [],
			levels: [{ level: '-1', name: 'Default' }],
		};

		// Configure permission levels
		for (let [n, l] of Object.entries(CONST.ENTITY_PERMISSIONS)) {
			data.levels.push({ level: l, name: n.titleCase() });
		}

		// Get the users and their current permission level and name
		for (let u of game.users) {
			if (u.isGM) continue;
			data.users.push({ user: u, level: e.data.permission[u._id] });
		}
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		event.preventDefault();
		if (!game.user.isGM)
			throw 'You do not have the ability to configure permissions.';

		// Collect user permissions
		const perms = {};
		for (let [user, level] of Object.entries(formData)) {
			if (name !== 'default' && level === '-1') {
				delete perms[user];
				continue;
			}
			perms[user] = parseInt(level);
		}

		// Update the entity
		this.entity.update({ permission: perms }, { diff: false });
	}
}

/**
 * The Player Configuration application provides a form used to allow the current client to
 * edit preferences and configurations about their own User entity.
 * @type {FormApplication}
 *
 * @param {User} user       The User entity being configured.
 * @param {Object} options  Additional rendering options which modify the behavior of the form.
 */
class PlayerConfig extends FormApplication {
	constructor(user, options) {
		super(user, options);
		this.user = this.object;
		game.actors.apps.push(this);
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the entity edit sheet
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'player-config',
			template: 'templates/user/player-config.html',
			width: 400,
			height: 'auto',
		});
	}

	/* -------------------------------------------- */

	get title() {
		return `${game.i18n.localize('PLAYERS.ConfigTitle')}: ${
			this.user.name
		}`;
	}

	/* -------------------------------------------- */

	/**
	 * Provide data to the form
	 * @return {Object}   The data provided to the template when rendering the form
	 */
	getData() {
		const controlled = game.users.entities
			.map(e => e.data.character)
			.filter(a => a);
		const actors = game.actors.entities.filter(
			a => a.hasPerm(this.user, 'OBSERVER') && !controlled.includes(a._id)
		);
		return {
			user: this.user,
			actors: actors,
			options: this.options,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Activate the default set of listeners for the Entity sheet
	 * These listeners handle basic stuff like form submission or updating images
	 *
	 * @param html {JQuery}     The rendered template ready to have listeners attached
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// When a character is clicked, record it's ID in the hidden input
		let input = html.find('[name="character"]');
		html.find('.actor').click(ev => {
			// Record the selected actor
			let li = ev.currentTarget;
			let actorId = li.getAttribute('data-actor-id');
			input.val(actorId);

			// Add context to the selection
			for (let a of html[0].getElementsByClassName('actor')) {
				a.classList.remove('context');
			}
			li.classList.add('context');
		});

		// Release the currently selected character
		html.find('button[name="release"]').click(ev => {
			if (canvas.tokens) canvas.tokens.releaseAll();
			if (canvas.sight) canvas.sight.initialize();
			this.user
				.update({ character: null })
				.then(() => this.render(false));
		});

		// Support Image updates
		html.find('img[data-edit="avatar"]').click(ev =>
			this._onEditAvatar(ev)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the user avatar image by opening a FilePicker
	 * @private
	 */
	_onEditAvatar(event) {
		event.preventDefault();
		new FilePicker({
			type: 'image',
			current: this.user.data.avatar,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event, { preventClose: true });
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
		}).browse(this.user.data.avatar);
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		this.user.update(formData);
	}
}

/* -------------------------------------------- */
/**
 * Playlist Configuration Sheet
 * @extends {BaseEntitySheet}
 */
class PlaylistConfig extends BaseEntitySheet {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'playlist-config';
		options.template = 'templates/playlist/edit-playlist.html';
		options.width = 360;
		return options;
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return `Edit ${this.object.name} Playlist`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = duplicate(this.object.data);
		data.modes = Object.keys(CONST.PLAYLIST_MODES).reduce((obj, val) => {
			obj[val.titleCase()] = CONST.PLAYLIST_MODES[val];
			return obj;
		}, {});
		return data;
	}
}

/* -------------------------------------------- */

/**
 * Playlist Sound Configuration Sheet
 * @type {FormApplication}
 *
 * @param {Playlist} playlist   The Playlist entity within which the Sound is configured
 * @param {Object} sound        An Object for the Playlist Sound data
 * @param {Object} options      Additional application rendering options
 */
class PlaylistSoundConfig extends FormApplication {
	constructor(playlist, sound, options) {
		super(sound, options);
		this.playlist = playlist;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'track-config',
			template: 'templates/playlist/edit-track.html',
			width: 360,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		return `${this.playlist.name} Playlist: ${this.object.name ||
			'New Track'}`;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = duplicate(this.object);
		data.lvolume = AudioHelper.volumeToInput(data.volume);
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	_updateObject(event, formData) {
		if (!game.user.isGM)
			throw 'You do not have the ability to edit playlist sounds.';
		formData['volume'] = AudioHelper.inputToVolume(formData['lvolume']);
		if (this.object._id) {
			formData['_id'] = this.object._id;
			this.playlist.updateEmbeddedEntity('PlaylistSound', formData, {});
		} else
			this.playlist.createEmbeddedEntity('PlaylistSound', formData, {});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
  /* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('input[name="path"]').change(this._onSourceChange.bind(this));
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * Auto-populate the track name using the provided filename, if a name is not already set
	 * @param {Event} event
	 * @private
	 */
	_onSourceChange(event) {
		event.preventDefault();
		const field = event.target;
		const form = field.form;
		if (!form.name.value)
			form.name.value = field.value
				.split('/')
				.pop()
				.split('.')
				.shift();
	}
}

/**
 * The RollTable configuration sheet
 * @type {BaseEntitySheet}
 *
 * @param table {RollTable}          The rollable table entity being configured
 * @param options {Object}           Additional application rendering options
 */
class RollTableConfig extends BaseEntitySheet {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.classes = options.classes.concat(['roll-table-config']);
		options.template = 'templates/sheets/roll-table-config.html';
		options.width = 720;
		options.height = 'auto';
		options.closeOnSubmit = false;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Return a dynamic application title for the configuration sheet
	 * @return {String}
	 */
	get title() {
		return `${game.i18n.localize('TABLE.SheetTitle')}: ${this.entity.name}`;
	}

	/* -------------------------------------------- */

	/**
	 * Default data preparation logic for the entity sheet
	 */
	getData() {
		const results = this.entity.results.map(r => {
			r = duplicate(r);
			r.isText = r.type === CONST.TABLE_RESULT_TYPES.TEXT;
			r.isEntity = r.type === CONST.TABLE_RESULT_TYPES.ENTITY;
			r.isCompendium = r.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM;
			r.img = r.img || CONFIG.RollTable.resultIcon;
			return r;
		});
		results.sort((a, b) => a.range[0] - b.range[1]);

		// Merge data and return;
		return mergeObject(super.getData(), {
			results: results,
			resultTypes: Object.entries(CONST.TABLE_RESULT_TYPES).reduce(
				(obj, v) => {
					obj[v[1]] = v[0].titleCase();
					return obj;
				},
				{}
			),
			entityTypes: CONST.COMPENDIUM_ENTITY_TYPES,
			compendiumPacks: game.packs.map(p => p.collection),
		});
	}

	/* -------------------------------------------- */
	/* 	Event Listeners and Handlers								*/
	/* -------------------------------------------- */

	/**
	 * Activate event listeners for the RollTable Configuration Sheet
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Roll the Table
		const button = html.find('button.roll');
		button.click(this._onRollTable.bind(this));
		button[0].disabled = false;

		// The below options require an editable sheet
		if (!this.options.editable) return;

		// Reset the Table
		html.find('button.reset').click(this._onResetTable.bind(this));

		// Save the sheet on checkbox change
		html.find('input[type="checkbox"]').change(this._onSubmit.bind(this));

		// Create a new Result
		html.find('a.create-result').click(this._onCreateResult.bind(this));

		// Delete a Result
		html.find('a.delete-result').click(this._onDeleteResult.bind(this));

		// Support Image updates
		html.find('.result-image img[data-edit]').click(
			this._onEditImage.bind(this)
		);

		// Lock or Unlock a Result
		html.find('a.lock-result').click(this._onLockResult.bind(this));

		// Modify Result Type
		html.find('.result-type select').change(
			this._onChangeResultType.bind(this)
		);

		// Re-normalize Table Entries
		html.find('.normalize-results').click(
			this._onNormalizeResults.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle creating a TableResult in the RollTable entity
	 * @param event
	 * @return {Promise}
	 * @private
	 */
	async _onCreateResult(event) {
		event.preventDefault();

		// Save any pending changes
		await this._onSubmit(event);

		// Get existing results
		const results = this.entity.results;
		let last = results[results.length - 1];

		// Get weight and range data
		let weight = last ? last.weight || 1 : 1;
		let totalWeight = results.reduce((t, r) => t + r.weight, 0) || 1;
		let minRoll = results.length
			? Math.min(...results.map(r => r.range[0]))
			: 0;
		let maxRoll = results.length
			? Math.max(...results.map(r => r.range[1]))
			: 0;

		// Determine new starting range
		let spread = maxRoll - minRoll + 1,
			perW = Math.round(spread / totalWeight);
		let range = [maxRoll + 1, maxRoll + weight * perW];

		// Create the new Result
		return this.entity.createEmbeddedEntity('TableResult', {
			type: last ? last.type : CONST.TABLE_RESULT_TYPES.TEXT,
			collection: last ? last.collection : null,
			weight: weight,
			range: range,
			drawn: false,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle deleting a TableResult from the RollTable entity
	 * @param event
	 * @return {Promise}
	 * @private
	 */
	async _onDeleteResult(event) {
		event.preventDefault();
		await this._onSubmit(event);
		const li = event.currentTarget.closest('.table-result');
		return this.entity.deleteEmbeddedEntity(
			'TableResult',
			li.dataset.resultId
		);
	}

	/* -------------------------------------------- */

	/**
	 * Submit the entire form when a table result type is changed, in case there are other active changes
	 * @param {Event} event
	 * @private
	 */
	_onChangeResultType(event) {
		event.preventDefault();
		const rt = CONST.TABLE_RESULT_TYPES;
		const select = event.target;
		const value = parseInt(select.value);
		const key = select.name.replace('.type', '.collection');
		let collection = '';
		if (value === rt.ENTITY) collection = 'Actor';
		else if (value === rt.COMPENDIUM) collection = game.packs[0].collection;
		const updateData = { [key]: collection, resultId: '' };
		return this._onSubmit(event, { updateData });
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the actor profile image by opening a FilePicker
	 * @param {Event} event
	 * @private
	 */
	_onEditImage(event) {
		const li = event.currentTarget.closest('.table-result');
		const result = this.entity.getTableResult(li.dataset.resultId);
		if (result.type !== CONST.TABLE_RESULT_TYPES.TEXT) return;
		const fp = new FilePicker({
			type: 'image',
			current: result.img,
			callback: path => {
				event.currentTarget.src = path;
				this._onSubmit(event);
			},
			top: this.position.top + 40,
			left: this.position.left + 10,
		});
		fp.browse(result.img);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a button click to re-normalize dice result ranges across all RollTable results
	 * @param {Event} event
	 * @private
	 */
	async _onNormalizeResults(event) {
		event.preventDefault();
		if (!this._rendered || this._submitting) return false;

		// Save any pending changes
		await this._onSubmit(event);

		// Normalize the RollTable
		return this.entity.normalize();
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the drawn status of the result in the table
	 * @param {Event} event
	 * @private
	 */
	_onLockResult(event) {
		event.preventDefault();
		const li = event.currentTarget.closest('li.table-result');
		const result = this.entity.getTableResult(li.dataset.resultId);
		return this.entity.updateEmbeddedEntity('TableResult', {
			_id: result._id,
			drawn: !result.drawn,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Reset the Table to it's original composition with all options unlocked
	 * @param {Event} event
	 * @private
	 */
	_onResetTable(event) {
		event.preventDefault();
		return this.entity.reset();
	}

	/* -------------------------------------------- */

	/**
	 * Handle drawing a result from the RollTable
	 * @param {Event} event
	 * @private
	 */
	async _onRollTable(event) {
		event.preventDefault();
		await this._onSubmit(event);
		event.currentTarget.disabled = true;
		let [roll, result] = this.entity.roll();
		if (result !== null) {
			if (game.settings.get('core', 'animateRollTable'))
				await this._animateRoll(result);
			await this.entity.draw({ roll, result });
		}
		event.currentTarget.disabled = false;
	}

	/* -------------------------------------------- */

	/**
	 * Configure the update object workflow for the Roll Table configuration sheet
	 * Additional logic is needed here to reconstruct the results array from the editable fields on the sheet
	 * @param {Event} event            The form submission event
	 * @param {Object} formData        The validated FormData translated into an Object for submission
	 * @return {Promise}
	 * @private
	 */
	async _updateObject(event, formData) {
		// Expand the data to update the results array
		const expanded = expandObject(formData);
		expanded.results = expanded.hasOwnProperty('results')
			? Object.values(expanded.results)
			: [];
		for (let r of expanded.results) {
			// Update the Range array
			r.range = [r.rangeL, r.rangeH];

			// Link entity types
			if (r.type === CONST.TABLE_RESULT_TYPES.ENTITY) {
				const config = r.collection ? CONFIG[r.collection] : null;
				const collection = config ? config.collection.instance : null;
				if (!collection) continue;

				// Get the original entity, if the name still matches - take no action
				const original = r.resultId ? collection.get(r.resultId) : null;
				if (original && original.name === r.text) continue;

				// Otherwise find the entity by ID or name (id preferred)
				const ent =
					collection.entities.find(
						e => e._id === r.text || e.name === r.text
					) || null;
				r.resultId = ent ? ent._id : null;
				r.text = ent ? ent.name : null;
				r.img = ent ? ent.img : null;
				r.img = ent ? ent.data.thumb || ent.data.img : null;
			}

			// Link Compendium types
			else if (r.type === CONST.TABLE_RESULT_TYPES.COMPENDIUM) {
				const pack = game.packs.find(
					p => p.collection === r.collection
				);
				if (pack) {
					const index = await pack.getIndex();

					// Get the original entry, if the name still matches - take no action
					const original = r.resultId
						? index.find(i => i.id === r.resultId)
						: null;
					if (original && original.name === r.text) continue;

					// Otherwise find the entity by ID or name (id preferred)
					const ent =
						index.find(i => i.id === r.text || i.name === r.text) ||
						null;
					r.resultId = ent ? ent.id : null;
					r.text = ent ? ent.name : null;
					r.img = ent ? ent.img : null;
				}
			}
		}

		// Update the object
		return this.entity.update(expanded);
	}

	/* -------------------------------------------- */

	/**
	 * Display a roulette style animation when a Roll Table result is drawn from the sheet
	 * @param {Object} result      The result which was drawn from the table
	 * @return {Promise}
	 * @private
	 */
	async _animateRoll(result) {
		// Get the list of results and their indices
		const ol = this.element.find('.table-results')[0];
		let targetIdx =
			this.entity.results.findIndex(r => r._id === result._id) + 1;

		// Set the animation timing
		const nResults = this.object.results.length;
		const maxTime = 2000;
		let animTime = 50;
		let animOffset = Math.round(
			ol.offsetHeight / (ol.children[1].offsetHeight * 2)
		);
		const nLoops = Math.min(Math.ceil(maxTime / (animTime * nResults)), 4);
		if (nLoops === 1) animTime = maxTime / nResults;

		// Animate it
		return new Promise(resolve => {
			let loop = 0;
			let idx = 1;
			let item = null;
			let animId = setInterval(() => {
				if (idx === 1) loop++;
				if (item) item.classList.remove('roulette');
				item = ol.children[idx];
				if (idx === targetIdx && loop === nLoops) {
					clearInterval(animId);
					ol.scrollTop = (targetIdx - animOffset) * item.offsetHeight;
					return this._flashResult(item).then(resolve);
				}
				ol.scrollTop = (idx - animOffset) * item.offsetHeight;
				item.classList.add('roulette');
				idx = idx < ol.children.length - 1 ? idx + 1 : 1;
			}, animTime);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Display a flashing animation on the selected result to emphasize the draw
	 * @param {HTMLElement} item      The HTML <li> item of the winning result
	 * @return {Promise}
	 * @private
	 */
	async _flashResult(item) {
		return new Promise(resolve => {
			let count = 0;
			let animId = setInterval(() => {
				if (count % 2) item.classList.remove('roulette');
				else item.classList.add('roulette');
				if (count === 7) {
					clearInterval(animId);
					resolve();
				}
				count++;
			}, 50);
		});
	}
}

CONFIG.RollTable.sheetClass = RollTableConfig;

/**
 * A Scene configuration sheet
 * @extends {BaseEntitySheet}
 * @see {@link Scene} The Scene Entity which is being configured
 */
class SceneSheet extends BaseEntitySheet {
	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['sheet', 'scene-sheet'],
			template: 'templates/scene/config.html',
			width: 720,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		return `scene-config-${this.object._id}`;
	}

	/* -------------------------------------------- */

	/**
	 * Get an enumeration of the available grid types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	_getGridTypes() {
		const labels = {
			GRIDLESS: 'Gridless',
			SQUARE: 'Square',
			HEXODDR: 'Hexagonal Rows - Odd',
			HEXEVENR: 'Hexagonal Rows - Even',
			HEXODDQ: 'Hexagonal Columns - Odd',
			HEXEVENQ: 'Hexagonal Columns - Even',
		};
		return Object.keys(CONST.GRID_TYPES).reduce((obj, t) => {
			obj[CONST.GRID_TYPES[t]] = labels[t];
			return obj;
		}, {});
	}

	/* -------------------------------------------- */

	/**
	 * Get the available weather effect types which can be applied to this Scene
	 * @return {Object}
	 * @private
	 */
	_getWeatherTypes() {
		const types = {};
		for (let [k, v] of Object.entries(CONFIG.weatherEffects)) {
			types[k] = v.label;
		}
		return types;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = super.getData();
		data.gridTypes = this._getGridTypes();
		data.weatherTypes = this._getWeatherTypes();
		data.playlists = game.playlists.entities;
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('button.capture-position').click(
			this._onCapturePosition.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Capture the current Scene position and zoom level as the initial view in the Scene config
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onCapturePosition(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const form = btn.form;
		form['initial.x'].value = parseInt(canvas.stage.pivot.x);
		form['initial.y'].value = parseInt(canvas.stage.pivot.y);
		form['initial.scale'].value = canvas.stage.scale.x;
		ui.notifications.info(
			'Captured canvas position as initial view in the Scene configuration form.'
		);
	}
}

/* -------------------------------------------- */

/**
 * Long-form Scene notes
 * @type {BaseEntitySheet}
 */
class SceneNotes extends BaseEntitySheet {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.template = 'templates/scene/scene-notes.html';
		options.width = 600;
		options.height = window.innerHeight * 0.9;
		options.top = 10;
		options.left = window.innerWidth - 600 - 320;
		options.classes = ['sheet', 'scene-notes'];
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Give each Scene Configuration sheet a unique css ID based on their entity ID
	 * @return {string}
	 */
	get id() {
		return `scene-notes-${this.object._id}`;
	}

	/* -------------------------------------------- */

	/**
	 * Put the Scene name in the window title
	 * @return {String}
	 */
	get title() {
		return `${this.entity.name}: Notes`;
	}
}

CONFIG.Scene.sheetClass = SceneSheet;
CONFIG.Scene.notesClass = SceneNotes;

/**
 * Entity Sheet Configuration Application
 * @type {FormApplication}
 * @param entity {Entity}      The Entity object for which the sheet is being configured
 * @param options {Object}     Additional Application options
 */
class EntitySheetConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'sheet-config';
		options.template = 'templates/sheets/sheet-config.html';
		options.width = 400;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Add the Entity name into the window title
	 * @type {String}
	 */
	get title() {
		return `${this.object.name}: Sheet Configuration`;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		const entityName = this.object.entity;
		const config = CONFIG[entityName];
		const type = this.object.data.type || CONST.BASE_ENTITY_TYPE;
		const classes = Object.values(config.sheetClasses[type]);
		const defcls = classes.find(c => c.default);
		return {
			entityName: entityName,
			isGM: game.user.isGM,
			object: duplicate(this.object.data),
			options: this.options,
			sheetClass: this.object.getFlag('core', 'sheetClass'),
			sheetClasses: classes.map(c => c.id),
			defaultClass: defcls ? defcls.id : null,
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	async _updateObject(event, formData) {
		event.preventDefault();
		const original = this.getData();

		// De-register the current sheet class
		const sheet = this.object.sheet;
		await sheet.close();
		this.object._sheet = null;
		delete this.object.apps[sheet.appId];

		// Update world settings
		if (game.user.isGM && formData.defaultClass !== original.defaultClass) {
			const setting =
				(await game.settings.get('core', 'sheetClasses')) || {};
			mergeObject(setting, {
				[`${this.object.entity}.${this.object.data.type}`]: formData.defaultClass,
			});
			await game.settings.set('core', 'sheetClasses', setting);
		}

		// Update the Entity-specific override
		if (formData.sheetClass !== original.sheetClass) {
			await this.object.setFlag(
				'core',
				'sheetClass',
				formData.sheetClass
			);
		}

		// Re-draw the updated sheet
		this.object.sheet.render(true);
	}

	/* -------------------------------------------- */
	/*  Configuration Methods
  /* -------------------------------------------- */

	/**
	 * Initialize the configured Sheet preferences for Entities which support dynamic Sheet assignment
	 * Create the configuration structure for supported entities
	 * Process any pending sheet registrations
	 * Update the default values from settings data
	 */
	static initializeSheets() {
		// Create placeholder entity/type mapping
		const entities = [Actor, Item];
		for (let ent of entities) {
			const types = this._getEntityTypes(ent);
			CONFIG[ent.name].sheetClasses = types.reduce((obj, type) => {
				obj[type] = {};
				return obj;
			}, {});
		}

		// Register any pending sheets
		this._pending.forEach(p => {
			if (p.action === 'register') this._registerSheet(p);
			else if (p.action === 'unregister') this._unregisterSheet(p);
		});
		this._pending = [];

		// Update default sheet preferences
		const defaults = game.settings.get('core', 'sheetClasses');
		this._updateDefaultSheets(defaults);
	}

	/* -------------------------------------------- */

	/**
	 * Register a sheet class as a candidate which can be used to display entities of a given type
	 * @param {Entity} entityClass      The Entity for which to register a new Sheet option
	 * @param {String} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {Object} options          Additional options used for sheet registration
	 */
	static registerSheet(
		entityClass,
		scope,
		sheetClass,
		{ types = [], makeDefault = false } = {}
	) {
		const id = `${scope}.${sheetClass.name}`;
		const config = { entityClass, id, sheetClass, types, makeDefault };

		// If the game is ready, register the sheet with the configuration object, otherwise add to pending
		if (game instanceof Game && game.ready) this._registerSheet(config);
		else {
			config['action'] = 'register';
			this._pending.push(config);
		}
	}

	static _registerSheet({
		entityClass,
		id,
		sheetClass,
		types,
		makeDefault,
	} = {}) {
		types = this._getEntityTypes(entityClass, types);
		let classes = CONFIG[entityClass.name].sheetClasses;
		for (let t of types) {
			classes[t][id] = {
				id: id,
				cls: sheetClass,
				default: makeDefault,
			};
		}
	}

	/* -------------------------------------------- */

	/**
	 * Unregister a sheet class, removing it from the list of available Applications to use for an Entity type
	 * @param {Entity} entityClass      The Entity for which to register a new Sheet option
	 * @param {String} scope            Provide a unique namespace scope for this sheet
	 * @param {Application} sheetClass  A defined Application class used to render the sheet
	 * @param {Array} types             An Array of types for which this sheet should be removed
	 */
	static unregisterSheet(
		entityClass,
		scope,
		sheetClass,
		{ types = [] } = {}
	) {
		const id = `${scope}.${sheetClass.name}`;
		const config = { entityClass, id, types };

		// If the game is ready remove the sheet directly, otherwise remove from pending
		if (game instanceof Game && game.ready) this._unregisterSheet(config);
		else {
			config['action'] = 'unregister';
			this._pending.push(config);
		}
	}

	static _unregisterSheet({ entityClass, id, types } = {}) {
		types = this._getEntityTypes(entityClass, types);
		let classes = CONFIG[entityClass.name].sheetClasses;
		for (let t of types) {
			delete classes[t][id];
		}
	}

	/* -------------------------------------------- */

	static _getEntityTypes(entityClass, types = []) {
		if (types.length) return types;
		const systemTypes = game.system.entityTypes[entityClass.name];
		return systemTypes.length ? systemTypes : [CONST.BASE_ENTITY_TYPE];
	}

	/* -------------------------------------------- */

	/**
	 * Update the currently default Sheets using a new core world setting
	 * @param {Object} setting
	 * @private
	 */
	static _updateDefaultSheets(setting) {
		if (!Object.keys(setting).length) return;
		const entities = [Actor, Item];
		for (let ent of entities) {
			let classes = CONFIG[ent.name].sheetClasses;
			let defaults = setting[ent.name];
			if (!defaults) continue;

			// Update default preference for registered sheets
			for (let [type, sheetId] of Object.entries(defaults)) {
				const sheets = Object.values(classes[type]);
				let requested = sheets.find(s => s.id === sheetId);
				if (requested)
					sheets.forEach(s => (s.default = s.id === sheetId));
			}

			// Close and de-register any existing sheets
			ent.collection.entities.forEach(e => {
				Object.values(e.apps).forEach(e => e.close());
				e.apps = {};
			});
		}
	}
}

EntitySheetConfig._pending = [];
/**
 * Abstraction of the Application interface to be used with the Draggable class as a substitute for the app
 * This class will represent one popout feed window and handle its positioning and draggability
 * @param {CameraViews} view      The CameraViews application that this popout belongs to
 * @param {String} userId         ID of the user this popout belongs to
 * @param {jQuery} element        The div element of this specific popout window
 */
class CameraPopoutAppWrapper {
	constructor(view, userId, element) {
		this.view = view;
		this.element = element;
		this.userId = userId;
		let setting = this.view.webrtc.settings.users[userId];
		this.setPosition({
			left: setting.x,
			top: setting.y,
			width: setting.width,
		});
		let draggable = new Draggable(
			this,
			element.find('.camera-view'),
			element.find('.video-container')[0],
			true
		);
		draggable._floatToTop = this.displayToFront.bind(this);
	}
	/**
	 * Get the current position of this popout window
	 */
	get position() {
		return mergeObject(this.element.position(), {
			width: this.element.outerWidth(),
			height: this.element.outerHeight(),
			scale: 1,
		});
	}
	/**
	 * Set the position of the popout window.
	 * Note: scale is ignored here.
	 */
	setPosition({ left, top, width, height, scale } = {}) {
		if (width || height) {
			// TODO: handle this better somehow? very ugly to have this here.
			// Height is based on the width of the camera with a 3:4 aspect ratio + 30px for the player name.
			if (width) height = Math.floor((width * 3) / 4 + 30);
			else if (height) width = Math.floor(((height - 30) * 4) / 3);
			this.element.outerWidth(width);
			this.element.outerHeight(height);
			this.view.webrtc.settings.users[this.userId].width = width;
		}
		this.element.css({ left, top });
		if (left) this.view.webrtc.settings.users[this.userId].x = left;
		if (top) this.view.webrtc.settings.users[this.userId].y = top;
	}

	_onResize(event) {}

	/**
	 * The z-index trick wouldn't work here because all popout divs are children of the
	 * #camera-views div itself, which has its own z-index. The z-index that gets respected is the one
	 * from camera-views, then the order of those popout windows are based on their position as children
	 * of the #camera-views.
	 * To float a window to the top, we need to add it to the end of the list of elements in the camera views
	 */
	displayToFront() {
		let parent = this.element.parent();
		let children = parent.children();
		let lastElement = children[children.length - 1];
		if (lastElement != this.element[0]) {
			this.view.webrtc.settings.users[this.userId].z = ++this.view.maxZ;
			parent.append(this.element);
		}
	}
}

/**
 * The Camera UI View that displays all the camera feeds and provides the video elements to the WebRTC.
 * @type {Application}
 *
 * @param {WebRTC} webrtc     The WebRTC Implementation to display
 */
class CameraViews extends Application {
	constructor(webrtc, options) {
		super(options);

		/**
		 * The WebRTCImplementation to display
		 * @type {WebRTC}
		 */
		this.webrtc = webrtc;

		// Render the camera views app when Users change
		game.users.apps.push(this);
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the CameraViews UI
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'camera-views',
			template: 'templates/hud/camera-views.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */
	/* Public API                                   */
	/* -------------------------------------------- */

	/**
	 * Sets whether a user is currently speaking or not
	 *
	 * @param {string} userId     The ID of the user
	 * @param {boolean} speaking  Whether the user is speaking
	 */
	setUserIsSpeaking(userId, speaking) {
		let box = this._getCameraBox(userId)[0];
		if (box) box.classList.toggle('speaking', speaking);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the div.camera-view which is used to portray a given Foundry User.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLElement|null}
	 */
	getUserCameraView(userId) {
		return (
			this.element.find(`.camera-view[data-user=${userId}]`)[0] || null
		);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain a reference to the video.user-camera which displays the video channel for a requested Foundry User.
	 * If the user is not broadcasting video this will return null.
	 * @param {string} userId     The ID of the User entity
	 * @return {HTMLVideoElement|null}
	 */
	getUserVideoElement(userId) {
		return (
			this.element.find(
				`.camera-view[data-user=${userId}] video.user-camera`
			)[0] || null
		);
	}

	/* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */

	/**
	 * Extend the render logic to first check whether a render is necessary based on the context
	 * If a specific context was provided, make sure an update to the navigation is necessary before rendering
	 */
	render(force, context = {}) {
		const { renderContext, renderData } = context;
		if (this.webrtc.settings.mode === WebRTCSettings.WEBRTC_MODE.DISABLED)
			return;
		if (renderContext) {
			if (renderContext !== 'updateUser') return;
			const updateKeys = [
				'name',
				'permissions',
				'role',
				'active',
				'color',
				'sort',
				'character',
				'avatar',
			];
			if (!updateKeys.some(k => renderData.hasOwnProperty(k))) return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/**
	 * Render the CameraViews UI, set volumes and render accompanying objects.
	 * After the app is rendered, update PlayerList visibility and render video frames
	 */
	async _render(force = false, options = {}) {
		await super._render(force, options);
		this._setPlayerListVisibility();
		this.webrtc.render();
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the default data which is required to render the CameraViews ui
	 */
	getData(options) {
		const settings = this.webrtc.settings;

		// Get the sorted array of connected users
		let users = game.users.entities.reduce((arr, user) => {
			const userData = this._getDataForUser(user);
			if (userData) arr.push(userData);
			return arr;
		}, []);
		users = this._sortUsersData(users);

		// Maximum Z of all user popout windows, so we can set correct Z when floating popouts to the front
		this.maxZ = Math.max(
			...users.map(u => this.webrtc.settings.users[u.id].z)
		);

		// Define a dynamic class for the camera dock container which affects it's rendered style
		let dockClass = `camera-size-${settings.dockSize} camera-position-${settings.dockPosition}`;
		if (!users.some(u => !u.settings.popout))
			dockClass += ' webrtc-dock-empty';

		// Alter the body class depending on whether the players list is hidden
		if (settings.hidePlayerList)
			document.body.classList.add('players-hidden');
		else document.body.classList.remove('players-hidden');

		// Return data for rendering
		return {
			self: game.user,
			users: users,
			dockClass: dockClass,
			anyVideo: users.some(u => u.hasVideo),
			muteAll: settings.muteAll,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Get rendering template daa for one user
	 * @param {User} user      The User to transform into rendering data
	 * @return {Object}
	 * @private
	 */
	_getDataForUser(user) {
		// Ensure the user has an active stream
		const stream = this.webrtc.client.getStreamForUser(user.id);
		const isConnected = !!stream;
		if (!isConnected && !user.active) return null;

		// Get data for the user
		const charname = user.character
			? user.character.name.split(' ')[0]
			: '';
		const settings = this.webrtc.settings.users[user.id];
		const isMuted = !this.webrtc.isStreamAudioEnabled(stream);
		const isHidden = !this.webrtc.isStreamVideoEnabled(stream);
		const hasVideo = this.webrtc.streamHasVideo(stream);
		const hasAudio = this.webrtc.streamHasAudio(stream);

		// Return structured User data
		return {
			user: user,
			id: user.id,
			local: user.isSelf,
			name: user.name,
			color: user.data.color,
			colorAlpha: hexToRGBAString(colorStringToHex(user.data.color), 0.2),
			charname: user.isGM ? game.i18n.localize('GM') : charname,
			avatar: user.avatar,
			connected: isConnected,
			settings: settings,
			volume: AudioHelper.volumeToInput(settings.volume),
			hasVideo: hasVideo,
			hasAudio: hasAudio,
			isMuted: isMuted,
			isHidden: isHidden,
			canToggleSources: game.user.isGM && !user.isSelf && !user.isGM,
			videoToggleClass: this._getToggleIcon('toggle-video', !isHidden),
			videoToggleTooltip: this._getToggleTooltip(
				'toggle-video',
				isHidden
			),
			audioToggleClass: this._getToggleIcon('toggle-audio', !isMuted),
			audioToggleTooltip: this._getToggleTooltip('toggle-audio', isMuted),
			videoToggleGlobalClass: this._getToggleIcon(
				'block-video',
				settings.canBroadcastVideo
			),
			videoToggleGlobalTooltip: this._getToggleTooltip(
				'block-video',
				!settings.canBroadcastVideo
			),
			audioToggleGlobalClass: this._getToggleIcon(
				'block-audio',
				settings.canBroadcastAudio
			),
			audioToggleGlobalTooltip: this._getToggleTooltip(
				'block-audio',
				!settings.canBroadcastAudio
			),
			cameraViewClass: [
				settings.popout ? 'camera-box-popout' : 'camera-box-dock',
				hasVideo && isHidden ? 'no-video' : null,
				hasAudio && isMuted ? 'no-audio' : null,
			].filterJoin(' '),
		};
	}

	/* -------------------------------------------- */

	/**
	 * Returns user's data sorted according to sort order, but always show local user as the first one,
	 * remote users with a camera before those without, and sort the popout windows according to their Z order.
	 * @return {Array.Object}
	 * @private
	 */
	_sortUsersData(users) {
		const settings = this.webrtc.settings.users;
		return users.sort((a, b) => {
			if (settings[a.id].popout && settings[b.id].popout)
				// Sort popouts by Z order
				return settings[a.id].z - settings[b.id].z;
			else if (settings[a.id].popout)
				// Show popout feeds first
				return -1;
			else if (settings[b.id].popout)
				// Show local feed first
				return 1;
			else if (a.user.isSelf) return -1;
			else if (b.user.isSelf) return 1;
			else if (a.hasVideo && !b.hasVideo)
				// Show remote users with a camera before those without
				return -1;
			else if (b.hasVideo && !a.hasVideo) return 1;
			// Sort according to user order
			else return a.user.data.sort - b.user.data.sort;
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Listen to UI events, mute/hide, volume controls, popout, etc..
	 */
	activateListeners(html) {
		// Display controls when hovering over the video container
		let cvh = this._onCameraViewHover.bind(this);
		html.find('.camera-view').hover(cvh, cvh);

		// Handle clicks on AV control buttons
		html.find('.av-control').click(this._onClickControl.bind(this));

		// Handle volume changes
		html.find('.webrtc-volume-slider').change(
			this._onVolumeChange.bind(this)
		);

		// Hide Global permission icons depending on the A/V mode
		if (this.webrtc.settings.mode === WebRTCSettings.WEBRTC_MODE.VIDEO)
			html.find('[data-action="toggle-audio"]').hide();
		if (this.webrtc.settings.mode === WebRTCSettings.WEBRTC_MODE.AUDIO)
			html.find('[data-action="toggle-video"]').hide();

		// Make each popout window draggable
		for (let popout of this.element.find('.app.camera-view-popout')) {
			let box = popout.querySelector('.camera-view');
			new CameraPopoutAppWrapper(this, box.dataset.user, $(popout));
		}

		// Listen to the video's srcObjectSet event to set the display mode of the user.
		for (let video of this.element.find('video')) {
			const view = video.closest('.camera-view');
			const userId = view.dataset.user;
			video.addEventListener('srcObjectSet', ev => {
				this._setVideoDisplayMode(
					view,
					this.webrtc.isStreamVideoEnabled(event.detail)
				);
				this._setAudioDisplayMode(
					view,
					this.webrtc.isStreamAudioEnabled(event.detail)
				);
			});

			// Adjust user volume attributes
			video.volume = this.webrtc.settings.users[userId].volume;
			if (userId !== game.user.id)
				video.muted = this.webrtc.settings.muteAll;
		}
	}

	/* -------------------------------------------- */

	/**
	 * On hover in a camera container, show/hide the controls.
	 * @event {Event} event   The original mouseover or mouseout hover event
	 * @private
	 */
	_onCameraViewHover(event) {
		this._toggleControlVisibility(
			event.currentTarget,
			event.type === 'mouseenter',
			null
		);
	}

	/* -------------------------------------------- */

	/**
	 * On clicking on a toggle, disable/enable the audio or video stream.
	 * @event {Event} event   The originating click event
	 * @private
	 */
	_onClickControl(event) {
		event.preventDefault();
		const button = event.currentTarget;
		const view = button.closest('.camera-view');
		const userId = view.dataset.user;
		const action = button.dataset.action;
		const settings = this.webrtc.settings.users[userId];

		// Handle different actions
		let enabled = false;
		switch (action) {
			// Globally block video
			case 'block-video':
				if (!game.user.isGM) break;
				enabled = settings[
					'canBroadcastVideo'
				] = !settings.canBroadcastVideo;
				break;

			// Globally block audio
			case 'block-audio':
				if (!game.user.isGM) break;
				enabled = settings[
					'canBroadcastAudio'
				] = !settings.canBroadcastAudio;
				break;

			// Toggle video display
			case 'toggle-video':
				enabled = settings.hidden;
				settings.hidden = !enabled;
				if (userId === game.user.id) {
					this.webrtc.enableCamera(enabled);
				} else {
					const stream = this.webrtc.client.getStreamForUser(userId);
					this.webrtc.enableStreamVideo(stream, enabled);
				}
				this._setVideoDisplayMode(view, enabled);
				view.classList.toggle('no-video', !enabled);
				break;

			// Toggle audio output
			case 'toggle-audio':
				enabled = settings.muted;
				settings.muted = !enabled;
				if (userId === game.user.id) {
					this.webrtc.enableMicrophone(enabled);
				} else {
					const stream = this.webrtc.client.getStreamForUser(userId);
					this.webrtc.enableStreamAudio(stream, enabled);
				}
				this._setAudioDisplayMode(view, enabled);
				view.classList.toggle('no-audio', !enabled);
				break;

			// Toggle mute all peers
			case 'mute-peers':
				enabled = this.webrtc.settings.muteAll = !this.webrtc.settings
					.muteAll;
				for (let video of this.element.find('video')) {
					let userId = video.closest('.camera-view').dataset.user;
					if (userId !== game.user.id) video.muted = enabled;
				}
				break;

			// Configure settings
			case 'configure':
				this.webrtc.config.render(true);
				break;

			// Toggle popout
			case 'toggle-popout':
				settings.popout = !settings.popout;
				return this.render();

			// Hide players
			case 'toggle-players':
				this.webrtc.settings.hidePlayerList = !this.webrtc.settings
					.hidePlayerList;
				return this.render();

			// Change size
			case 'change-size':
				const sizes = ['large', 'medium', 'small'];
				const size = sizes.indexOf(this.webrtc.settings.dockSize);
				const next = size + 1 >= sizes.length ? 0 : size + 1;
				this.webrtc.settings.dockSize = sizes[next];
				return this.render();
		}

		// Swap the toggle button icons and reset the tooltip according to the new values
		if (!button.classList.contains('toggle')) return;
		const icon = button.children[0];
		icon.classList.toggle(this._getToggleIcon(action, !enabled), false);
		icon.classList.toggle(this._getToggleIcon(action, enabled), true);
		button.setAttribute('title', this._getToggleTooltip(action, enabled));
	}

	/* -------------------------------------------- */

	/**
	 * Change volume control for a stream
	 * @param {Event} event   The originating change event from interaction with the range input
	 * @private
	 */
	_onVolumeChange(event) {
		const input = event.currentTarget;
		const box = input.closest('.camera-view');
		const userId = box.dataset.user;

		// Map volume control to logarithmic value and set it
		let exp_volume = AudioHelper.inputToVolume(input.value);
		box.getElementsByTagName('video')[0].volume = exp_volume;
		this.webrtc.settings.users[userId].volume = exp_volume;
	}

	/* -------------------------------------------- */
	/*  Internal Helpers                            */
	/* -------------------------------------------- */

	/**
	 * Sets the display mode for a user's video box to toggle between
	 * showing the player's avatar or video stream instead
	 *
	 * @param {HTMLElement} view    The camera view HTML container
	 * @param {boolean} enabled     Is video output enabled?
	 * @private
	 */
	_setVideoDisplayMode(view, enabled) {
		const video = view.querySelector('video.user-camera');
		const avatar = view.querySelector('img.user-avatar');
		if (video && avatar) {
			video.style.visibility = enabled ? 'visible' : 'hidden';
			video.style.display = enabled ? 'block' : 'none';
			avatar.style.display = enabled ? 'none' : 'unset';
		}
		const statusIcon = view.querySelector('.status-hidden');
		statusIcon.classList.toggle('hidden', enabled);
	}

	/* -------------------------------------------- */

	/**
	 * Configure display of the camera view depending on the audio configuration
	 *
	 * @param {HTMLElement} view    The camera view HTML container
	 * @param {boolean} enabled     Is audio output enabled?
	 * @private
	 */
	_setAudioDisplayMode(view, enabled) {
		const statusIcon = view.querySelector('.status-muted');
		statusIcon.classList.toggle('hidden', enabled);
	}

	/* -------------------------------------------- */

	/**
	 * Render changes needed to the PlayerList ui.
	 * Show/Hide players depending on option.
	 * @private
	 */
	_setPlayerListVisibility() {
		let players = document.getElementById('players');
		if (players)
			players.classList.toggle(
				'hidden',
				this.webrtc.settings.hidePlayerList
			);
	}

	/* -------------------------------------------- */

	/**
	 * Get the av-control icon that should be used for various action buttons with different toggled states
	 * @param {string} action     The named av-control button action
	 * @param {boolean} enabled   Is the action currently enabled?
	 * @return {string}           The icon class to use
	 * @private
	 */
	_getToggleIcon(action, enabled) {
		const actionMapping = {
			'block-video': ['fa-video', 'fa-video-slash'],
			'block-audio': ['fa-microphone', 'fa-microphone-slash'],
			'toggle-video': ['fa-video', 'fa-video-slash'],
			'toggle-audio': ['fa-microphone', 'fa-microphone-slash'],
			'mute-peers': ['fa-volume-mute', 'fa-volume-up'],
		};
		const icons = actionMapping[action];
		return icons ? icons[enabled ? 0 : 1] : null;
	}

	/* -------------------------------------------- */

	/**
	 * Completement to getToggleClass(), returns the tooltip to show on the toggle icon
	 * @param {string} action     The named av-control button action
	 * @param {boolean} enabled   Is the action currently enabled?
	 * @return {string}           The tooltip label to use
	 * @private
	 */
	_getToggleTooltip(action, enabled) {
		const actionMapping = {
			'block-video': ['AllowUserVideo', 'BlockUserVideo'],
			'block-audio': ['AllowUserAudio', 'BlockUserAudio'],
			'toggle-video': ['EnableMyVideo', 'DisableMyVideo'],
			'toggle-audio': ['EnableMyAudio', 'DisableMyAudio'],
			'mute-peers': ['MutePeers', 'UnmutePeers'],
		};
		const labels = actionMapping[action];
		return game.i18n.localize(
			`WEBRTC.Tooltip${labels ? labels[enabled ? 0 : 1] : ''}`
		);
	}

	/* -------------------------------------------- */

	/**
	 * Get the camera-view for a user
	 * @param {String} userId     ID of the user to get its camera feed
	 * @param {String} selector   (optional) A selector to further further select an element in the camera box
	 * @return {jQuery}
	 * @private
	 */
	_getCameraBox(userId, selector = '') {
		return this.element.find(
			`.camera-view[data-user=${userId}] ${selector}`
		);
	}

	/* -------------------------------------------- */

	/**
	 * Show or hide UI control elements
	 * This replaces the use of jquery.show/hide as it simply adds a class which has display:none
	 * which allows us to have elements with display:flex which can be hidden then shown without
	 * breaking their display style.
	 * This will show/hide the toggle buttons, volume controls and overlay sidebars
	 * @param {jQuery} container    The container for which to show/hide control elements
	 * @param {Boolean} show        Whether to show or hide the controls
	 * @param {String} selector     Override selector to specify which controls to show or hide
	 * @private
	 */
	_toggleControlVisibility(container, show, selector) {
		selector = selector || `.control-bar`;
		container
			.querySelectorAll(selector)
			.forEach(c => c.classList.toggle('hidden', !show));
	}
}

/**
 * The Chat Bubble Class
 * This application displays a temporary message sent from a particular Token in the active Scene.
 * The message is displayed on the HUD layer just above the Token.
 */
class ChatBubbles {
	constructor() {
		this.template = 'templates/hud/chat-bubble.html';

		/**
		 * Track active Chat Bubbles
		 * @type {Object}
		 */
		this.bubbles = {};

		/**
		 * Track which Token was most recently panned to highlight
		 * Use this to avoid repeat panning
		 * @type {Token}
		 * @private
		 */
		this._panned = null;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the chat bubbles HTML container in which rendered bubbles should live
	 * @return {jQuery}
	 */
	get container() {
		return $('#chat-bubbles');
	}

	/* -------------------------------------------- */

	/**
	 * Speak a message as a particular Token, displaying it as a chat bubble
	 * @param {Token} token       The speaking Token
	 * @param {String} message    The spoken message text
	 * @param {Boolean} emote     Whether to style the speech bubble as an emote
	 * @return {Promise}          A Promise which resolves once the chat bubble has been created
	 */
	async say(token, message, { emote = false } = {}) {
		if (!token || !message) return;
		let allowBubbles = game.settings.get('core', 'chatBubbles');
		if (!allowBubbles) return;
		const panToSpeaker = game.settings.get('core', 'chatBubblesPan');

		// Clear any existing bubble for the speaker
		await this._clearBubble(token);

		// Create the HTML
		let html = $(await this._renderHTML({ token, message, emote }));

		// Set initial dimensions
		let dimensions = this._getMessageDimensions(message);
		this._setPosition(token, html, dimensions);

		// Append to DOM
		this.container.append(html);

		// Pan to the speaker
		if (panToSpeaker && this._panned !== token) {
			canvas.animatePan({
				x: token.x,
				y: token.y,
				scale: Math.max(1, canvas.stage.scale.x),
				duration: 1000,
			});
			this._panned = token;
		}

		// Get animation duration and settings
		let duration = this._getDuration(html),
			scroll = dimensions.unconstrained - dimensions.height;

		// Animate the bubble
		html.fadeIn(250, () => {
			// Animate scrolling the content
			if (scroll > 0) {
				html.find('.bubble-content').animate(
					{ top: -1 * scroll },
					duration - 1000,
					'linear'
				);
			}

			// Set a timer to fade out and remove the bubble
			setTimeout(
				() =>
					html.fadeOut(250, () => {
						html.remove();
					}),
				duration
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Clear any existing chat bubble for a certain Token
	 * @param {Token} token
	 * @private
	 */
	async _clearBubble(token) {
		let existing = $(`.chat-bubble[data-token-id="${token.id}"]`);
		if (!existing.length) return;
		return new Promise(resolve => {
			existing.fadeOut(100, () => {
				existing.remove();
				resolve();
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Render the HTML template for the chat bubble
	 * @param {Object} data     Template data
	 * @return {Promise}        The rendered HTML
	 * @private
	 */
	async _renderHTML(data) {
		data.cssClasses = [data.emote ? 'emote' : null]
			.filter(c => c !== null)
			.join(' ');
		return renderTemplate(this.template, data);
	}

	/* -------------------------------------------- */

	/**
	 * Before displaying the chat message, determine it's constrained and unconstrained dimensions
	 * @param {String} message    The message content
	 * @return {Object}           The rendered message dimensions
	 * @private
	 */
	_getMessageDimensions(message) {
		let div = $(
			`<div class="chat-bubble" style="visibility:hidden">${message}</div>`
		);
		$('body').append(div);
		let dims = {
			width: div[0].clientWidth + 8,
			height: div[0].clientHeight,
		};
		div.css({ maxHeight: 'none' });
		dims.unconstrained = div[0].clientHeight;
		div.remove();
		return dims;
	}

	/* -------------------------------------------- */

	/**
	 * Assign styling parameters to the chat bubble, toggling either a left or right display (randomly)
	 * @private
	 */
	_setPosition(token, html, dimensions) {
		let cls = Math.random() > 0.5 ? 'left' : 'right';
		html.addClass(cls);
		const pos = {
			height: dimensions.height,
			width: dimensions.width,
			top: token.y - dimensions.height - 8,
		};
		if (cls === 'right') pos.left = token.x - (dimensions.width - token.w);
		else pos.left = token.x;
		html.css(pos);
	}

	/* -------------------------------------------- */

	/**
	 * Determine the length of time for which to display a chat bubble.
	 * Research suggests that average reading speed is 200 words per minute.
	 * Since these are short-form messages, we multiply reading speed by 1.5.
	 * Clamp the result between 1 second (minimum) and 20 seconds (maximum)
	 * @param {jQuery}     The HTML message
	 * @returns {Number}   The number of milliseconds for which to display the message
	 */
	_getDuration(html) {
		let words = html
			.text()
			.split(' ')
			.map(w => w.trim()).length;
		let ms = (words * 60 * 1000) / 300;
		return Math.clamped(1000, ms, 20000);
	}
}

/**
 * Render the HUD container
 * @type {Application}
 */
class HeadsUpDisplay extends Application {
	constructor(...args) {
		super(...args);

		/**
		 * Token HUD
		 * @type {TokenHUD}
		 */
		this.token = new TokenHUD();

		/**
		 * Tile HUD
		 * @type {TileHUD}
		 */
		this.tile = new TileHUD();

		/**
		 * Drawing HUD
		 * @type {DrawingHUD}
		 */
		this.drawing = new DrawingHUD();

		/**
		 * Chat Bubbles
		 * @type {ChatBubbles}
		 */
		this.bubbles = new ChatBubbles();
	}

	/* -------------------------------------------- */

	/**
	 * Define default options which configure the HUD
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'hud';
		options.template = 'templates/hud/hud.html';
		options.popOut = false;
		return options;
	}

	/* -------------------------------------------- */

	getData() {
		if (!canvas.ready) return {};
		return {
			width: canvas.dimensions.width,
			height: canvas.dimensions.height,
		};
	}

	/* -------------------------------------------- */

	async _render(...args) {
		await super._render(...args);
		this.align();
	}

	/* -------------------------------------------- */

	align() {
		const hud = this.element[0];
		let { x, y } = canvas.background.getGlobalPosition();
		let scale = canvas.stage.scale.x;
		hud.style.left = x + 'px';
		hud.style.top = y + 'px';
		hud.style.transform = `scale(${scale})`;
	}
}

/**
 * Scene controls navigation menu
 * @type {Application}
 */
class SceneControls extends Application {
	constructor(options) {
		super(options);

		/**
		 * The name of the active Scene Control toolset
		 * @type {String}
		 */
		this.activeControl = 'token';

		/**
		 * The Array of Scene Control buttons which are currently rendered
		 * @type {Array}
		 */
		this.controls = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the SceneControls ui
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			width: 100,
			id: 'controls',
			template: 'templates/hud/controls.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return the active control set
	 * @type {Object|null}
	 */
	get control() {
		if (!this.controls) return null;
		return this.controls.find(c => c.name === this.activeControl) || null;
	}

	/* -------------------------------------------- */

	/**
	 * Return the name of the active tool within the active control set
	 * @type {String|null}
	 */
	get activeTool() {
		const control = this.control;
		return control ? control.activeTool : null;
	}

	/* -------------------------------------------- */

	/**
	 * Return the actively controled tool
	 * @return {Object|null}
	 */
	get tool() {
		const control = this.control;
		if (!control) return null;
		const tool = control.tools.find(t => t.name === control.activeTool);
		return tool || null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference for whether the currently active tool is a Ruler
	 * @return {Boolean}
	 */
	get isRuler() {
		return this.activeTool === 'ruler';
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Initialize the Scene Controls by obtaining the set of control buttons and rendering the HTML
	 * @param {String} control  An optional control set to set as active
	 * @param {String} layer    An optional layer name to target as the active control
	 */
	initialize({ control = null, layer = null } = {}) {
		if (control) this.activeControl = control;
		else if (layer && this.controls) {
			const control = this.controls.find(c => c.layer === layer);
			if (control) this.activeControl = control.name;
		}
		this.controls = this._getControlButtons();
		this.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of Control sets and tools that are rendered as the Scene Controls.
	 * These controls may be extended using the "getSceneControlButtons" Hook.
	 * @return {Array}
	 * @private
	 */
	_getControlButtons() {
		const controls = [];
		const isGM = game.user.isGM;
		const isTrusted = game.user.isTrusted;

		// Token Controls
		controls.push({
			name: 'token',
			title: 'CONTROLS.GroupBasic',
			layer: 'TokenLayer',
			icon: 'fas fa-user-alt',
			tools: [
				{
					name: 'select',
					title: 'CONTROLS.BasicSelect',
					icon: 'fas fa-expand',
				},
				{
					name: 'target',
					title: 'CONTROLS.TargetSelect',
					icon: 'fas fa-bullseye',
				},
				{
					name: 'ruler',
					title: 'CONTROLS.BasicMeasure',
					icon: 'fas fa-ruler',
				},
			],
			activeTool: 'select',
		});

		// Measurement Layer Tools
		controls.push({
			name: 'measure',
			title: 'CONTROLS.GroupMeasure',
			layer: 'TemplateLayer',
			icon: 'fas fa-ruler-combined',
			visible: isTrusted,
			tools: [
				{
					name: 'circle',
					title: 'CONTROLS.MeasureCircle',
					icon: 'far fa-circle',
				},
				{
					name: 'cone',
					title: 'CONTROLS.MeasureCone',
					icon: 'fas fa-angle-left',
				},
				{
					name: 'rect',
					title: 'CONTROLS.MeasureRect',
					icon: 'far fa-square',
				},
				{
					name: 'ray',
					title: 'CONTROLS.MeasureRay',
					icon: 'fas fa-arrows-alt-v',
				},
				{
					name: 'clear',
					title: 'CONTROLS.MeasureClear',
					icon: 'fas fa-trash',
					visible: isGM,
					onClick: () => canvas.templates.deleteAll(),
					button: true,
				},
			],
			activeTool: 'circle',
		});

		// Tiles Layer
		controls.push({
			name: 'tiles',
			title: 'CONTROLS.GroupTile',
			layer: 'TilesLayer',
			icon: 'fas fa-cubes',
			visible: isGM,
			tools: [
				{
					name: 'select',
					title: 'CONTROLS.TileSelect',
					icon: 'fas fa-expand',
				},
				{
					name: 'tile',
					title: 'CONTROLS.TilePlace',
					icon: 'fas fa-cube',
				},
			],
			activeTool: 'select',
		});

		// Drawing Tools
		controls.push({
			name: 'drawings',
			title: 'CONTROLS.GroupDrawing',
			layer: 'DrawingsLayer',
			icon: 'fas fa-pencil-alt',
			visible: isTrusted,
			tools: [
				{
					name: 'select',
					title: 'CONTROLS.DrawingSelect',
					icon: 'fas fa-expand',
				},
				{
					name: 'rect',
					title: 'CONTROLS.DrawingRect',
					icon: 'fas fa-square',
				},
				{
					name: 'ellipse',
					title: 'CONTROLS.DrawingEllipse',
					icon: 'fas fa-circle',
				},
				{
					name: 'polygon',
					title: 'CONTROLS.DrawingPoly',
					icon: 'fas fa-draw-polygon',
				},
				{
					name: 'freehand',
					title: 'CONTROLS.DrawingFree',
					icon: 'fas fa-signature',
				},
				{
					name: 'configure',
					title: 'CONTROLS.DrawingConfig',
					icon: 'fas fa-cog',
					onClick: () => canvas.drawings.configureDefault(),
					button: true,
				},
				{
					name: 'clear',
					title: 'CONTROLS.DrawingClear',
					icon: 'fas fa-trash',
					visible: isGM,
					onClick: () => canvas.drawings.deleteAll(),
					button: true,
				},
			],
			activeTool: 'select',
		});

		// Walls Layer Tools
		controls.push({
			name: 'walls',
			title: 'CONTROLS.GroupWall',
			layer: 'WallsLayer',
			icon: 'fas fa-university',
			visible: isGM,
			tools: [
				{
					name: 'walls',
					title: 'CONTROLS.WallDraw',
					icon: 'fas fa-bars',
				},
				{
					name: 'invisible',
					title: 'CONTROLS.WallInvisible',
					icon: 'fas fa-eye-slash',
				},
				{
					name: 'terrain',
					title: 'CONTROLS.WallTerrain',
					icon: 'fas fa-mountain',
				},
				{
					name: 'ethereal',
					title: 'CONTROLS.WallEthereal',
					icon: 'fas fa-mask',
				},
				{
					name: 'doors',
					title: 'CONTROLS.WallDoors',
					icon: 'fas fa-door-open',
				},
				{
					name: 'secret',
					title: 'CONTROLS.WallSecret',
					icon: 'fas fa-user-secret',
				},
				{
					name: 'clone',
					title: 'CONTROLS.WallClone',
					icon: 'far fa-clone',
				},
				{
					name: 'clear',
					title: 'CONTROLS.WallClear',
					icon: 'fas fa-trash',
					onClick: () => canvas.walls.deleteAll(),
					button: true,
				},
			],
			activeTool: 'walls',
		});

		// Lighting Layer Tools
		controls.push({
			name: 'lighting',
			title: 'CONTROLS.GroupLighting',
			layer: 'LightingLayer',
			icon: 'far fa-lightbulb',
			visible: isGM,
			tools: [
				{
					name: 'light',
					title: 'CONTROLS.LightDraw',
					icon: 'fas fa-lightbulb',
				},
				{
					name: 'clear',
					title: 'CONTROLS.LightClear',
					icon: 'fas fa-trash',
					onClick: () => canvas.lighting.deleteAll(),
					button: true,
				},
				{
					name: 'reset',
					title: 'CONTROLS.LightReset',
					icon: 'fas fa-cloud',
					onClick: () => {
						new Dialog({
							title: game.i18n.localize('CONTROLS.FOWResetTitle'),
							content: `<p>${game.i18n.localize(
								'CONTROLS.FOWResetDesc'
							)}</p>`,
							buttons: {
								yes: {
									icon: '<i class="fas fa-check"></i>',
									label: 'Yes',
									callback: () => canvas.sight.resetFog(),
								},
								no: {
									icon: '<i class="fas fa-times"></i>',
									label: 'No',
								},
							},
						}).render(true);
					},
					button: true,
				},
			],
			activeTool: 'light',
		});

		// Sounds Layer Tools
		controls.push({
			name: 'sounds',
			title: 'CONTROLS.GroupSound',
			layer: 'SoundsLayer',
			icon: 'fas fa-music',
			visible: isGM,
			tools: [
				{
					name: 'sound',
					title: 'CONTROLS.SoundDraw',
					icon: 'fas fa-volume-up',
				},
				{
					name: 'clear',
					title: 'CONTROLS.SoundClear',
					icon: 'fas fa-trash',
					onClick: () => canvas.sounds.deleteAll(),
					button: true,
				},
			],
			activeTool: 'sound',
		});

		// Notes Layer Tools
		controls.push({
			name: 'notes',
			title: 'CONTROLS.GroupNotes',
			layer: 'NotesLayer',
			icon: 'fas fa-bookmark',
			tools: [
				{
					name: 'select',
					title: 'CONTROLS.NoteSelect',
					icon: 'fas fa-expand',
				},
				{
					name: 'toggle',
					title: 'CONTROLS.NoteToggle',
					icon: 'fas fa-map-pin',
					toggle: true,
					active: game.settings.get(
						'core',
						NotesLayer.TOGGLE_SETTING
					),
					onClick: toggled =>
						game.settings.set(
							'core',
							NotesLayer.TOGGLE_SETTING,
							toggled
						),
				},
				{
					name: 'clear',
					title: 'CONTROLS.NoteClear',
					icon: 'fas fa-trash',
					visible: isGM,
					onClick: () => canvas.notes.deleteAll(),
					button: true,
				},
			],
			activeTool: 'select',
		});

		// Pass the Scene Controls to a hook function to allow overrides or changes
		Hooks.callAll(`getSceneControlButtons`, controls);
		return controls;
	}

	/* -------------------------------------------- */

	/**
	 * Provide data to the HTML template for rendering
	 * @return {Object}
	 */
	getData() {
		// Filter to control tool sets which can be displayed
		let controls = this.controls
			.filter(s => s.visible !== false)
			.map(s => {
				s = duplicate(s);

				// Add styling rules
				s.css = this.activeControl === s.name ? 'active' : '';

				// Prepare contained tools
				s.tools = s.tools
					.filter(t => t.visible !== false)
					.map(t => {
						let active =
							s.activeTool === t.name || (t.toggle && t.active);
						t.css = [
							t.toggle ? 'toggle' : null,
							active ? 'active' : null,
						]
							.filter(t => !!t)
							.join(' ');
						return t;
					});
				return s;
			});

		// Restrict to sets which have at least 1 tool remaining
		controls = controls.filter(s => s.tools.length);

		// Return data for rendering
		return {
			active: canvas.scene,
			controls: controls,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	activateListeners(html) {
		html.find('.scene-control').click(this._onClickLayer.bind(this));
		html.find('.control-tool').click(this._onClickTool.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on a Control set
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickLayer(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const controlName = li.dataset.control;
		this.activeControl = controlName;
		const control = this.controls.find(c => c.name === controlName);
		if (control && control.layer) canvas.getLayer(control.layer).activate();
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Tool controls
	 * @param {Event} event   A click event on a tool control
	 * @private
	 */
	_onClickTool(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const control = this.control;
		const toolName = li.dataset.tool;
		const tool = control.tools.find(t => t.name === toolName);

		// Handle Toggles
		if (tool.toggle) {
			tool.active = !tool.active;
			if (tool.onClick instanceof Function) tool.onClick(tool.active);
		}

		// Handle Buttons
		else if (tool.button) {
			if (tool.onClick instanceof Function) tool.onClick();
		}

		// Handle Tools
		else {
			control.activeTool = toolName;
			if (tool.onClick instanceof Function) tool.onClick();
		}

		// Render the controls
		this.render();
	}
}

/**
 * The global action bar displayed at the bottom of the game view.
 * The Hotbar is a UI element at the bottom of the screen which contains Macros as interactive buttons.
 * The Hotbar supports 5 pages of global macros which can be dragged and dropped to organize as you wish.
 *
 * Left clicking a Macro button triggers its effect.
 * Right clicking the button displays a context menu of Macro options.
 * The number keys 1 through 0 activate numbered hotbar slots.
 * Pressing the delete key while hovering over a Macro will remove it from the bar.
 *
 * @extends {Application}
 *
 * @see {@link Macros}
 * @see {@link Macro}
 */
class Hotbar extends Application {
	constructor(options) {
		super(options);
		game.macros.apps.push(this);

		/**
		 * The currently viewed macro page
		 * @type {number}
		 */
		this.page = 1;

		/**
		 * The currently displayed set of macros
		 * @type {Array}
		 */
		this.macros = [];

		/**
		 * Track collapsed state
		 * @type {boolean}
		 */
		this._collapsed = false;

		/**
		 * Track which hotbar slot is the current hover target, if any
		 * @type {number|null}
		 */
		this._hover = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'hotbar',
			template: 'templates/hud/hotbar.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		this.macros = this._getMacrosByPage(this.page);
		return {
			page: this.page,
			macros: this.macros,
			barClass: this._collapsed ? 'collapsed' : '',
		};
	}

	/* -------------------------------------------- */

	/**
	 * Get the Array of Macro (or null) values that should be displayed on a numbered page of the bar
	 * @param {number} page
	 * @returns {Array}
	 * @private
	 */
	_getMacrosByPage(page) {
		const macros = game.user.getHotbarMacros(page);
		for (let [i, m] of macros.entries()) {
			m.key = i < 9 ? i + 1 : 0;
			m.cssClass = m.macro ? 'active' : 'inactive';
			m.icon = m.macro ? m.macro.data.img : null;
		}
		return macros;
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the Hotbar, minimizing its display.
	 * @return {Promise}    A promise which resolves once the collapse animation completes
	 */
	async collapse() {
		if (this._collapsed) return true;
		const toggle = this.element.find('#bar-toggle');
		const icon = toggle.children('i');
		const bar = this.element.find('#action-bar');
		return new Promise(resolve => {
			bar.slideUp(200, () => {
				bar.addClass('collapsed');
				icon.removeClass('fa-caret-down').addClass('fa-caret-up');
				this._collapsed = true;
				resolve(true);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Expand the Hotbar, displaying it normally.
	 * @return {Promise}    A promise which resolves once the expand animation completes
	 */
	expand() {
		if (!this._collapsed) return true;
		const toggle = this.element.find('#bar-toggle');
		const icon = toggle.children('i');
		const bar = this.element.find('#action-bar');
		return new Promise(resolve => {
			bar.slideDown(200, () => {
				bar.css('display', '');
				bar.removeClass('collapsed');
				icon.removeClass('fa-caret-up').addClass('fa-caret-down');
				this._collapsed = false;
				resolve(true);
			});
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		html.find('#bar-toggle').click(this._onToggleBar.bind(this));
		html.find('#macro-directory').click(ev => ui.macros.renderPopout(true));
		html.find('.macro')
			.click(this._onClickMacro.bind(this))
			.hover(this._onHoverMacro.bind(this));
		html.find('.page-control').click(this._onClickPageControl.bind(this));

		// Activate context menu
		this._contextMenu(html);

		// Make the Hotbar and it's contained Macro buttons drag&drop-able
		html.find('.macro').each((i, li) => {
			li.setAttribute('draggable', true);
			li.addEventListener(
				'dragstart',
				ev => this._onDragStart(ev),
				false
			);
		});
		const bar = html.find('#macro-list');
		bar[0].ondragover = this._onDragOver.bind(this);
		bar[0].ondrop = this._onDrop.bind(this);
	}

	/* -------------------------------------------- */

	/**
	 * Create a Context Menu attached to each Macro button
	 * @param html
	 * @private
	 */
	_contextMenu(html) {
		new ContextMenu(html, '.macro', [
			{
				name: 'Edit',
				icon: '<i class="fas fa-edit"></i>',
				condition: li => {
					const macro = game.macros.get(li.data('macro-id'));
					return macro ? macro.owner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data('macro-id'));
					macro.sheet.render(true);
				},
			},
			{
				name: 'Remove',
				icon: '<i class="fas fa-times"></i>',
				callback: li => {
					game.user.assignHotbarMacro(null, li.data('slot'));
				},
			},
			{
				name: 'Delete',
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					const macro = game.macros.get(li.data('macro-id'));
					return macro ? macro.owner : false;
				},
				callback: li => {
					const macro = game.macros.get(li.data('macro-id'));
					Dialog.confirm({
						title: `${game.i18n.localize('MACRO.Delete')} ${
							macro.name
						}`,
						content: game.i18n.localize('MACRO.DeleteConfirm'),
						yes: macro.delete.bind(macro),
					});
				},
			},
		]);
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events to
	 * @param event
	 * @private
	 */
	async _onClickMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;

		// Case 1 - create a new Macro
		if (li.classList.contains('inactive')) {
			const macro = await Macro.create({
				name: 'New Macro',
				type: 'chat',
				scope: 'global',
			});
			await game.user.assignHotbarMacro(macro, li.dataset.slot);
			macro.sheet.render(true);
		}

		// Case 2 - trigger a Macro
		else {
			const macro = game.macros.get(li.dataset.macroId);
			return macro.execute();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle hover events on a macro button to track which slot is the hover target
	 * @param {Event} event   The originating mouseover or mouseleave event
	 * @private
	 */
	_onHoverMacro(event) {
		event.preventDefault();
		const li = event.currentTarget;
		if (event.type === 'mouseenter') this._hover = li.dataset.slot;
		else this._hover = null;
	}

	/* -------------------------------------------- */

	/**
	 * Handle pagination controls
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onClickPageControl(event) {
		const a = event.currentTarget;
		if (a.dataset.action === 'page-up') {
			this.page = this.page < 5 ? this.page + 1 : 1;
		} else {
			this.page = this.page > 1 ? this.page - 1 : 5;
		}
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a drag operation for Macro buttons in the Hotbar
	 * @param {Event} event   The originating dragstart event
	 * @private
	 */
	_onDragStart(event) {
		event.stopPropagation();
		const li = event.currentTarget.closest('.macro');
		const dragData = {
			type: 'Macro',
			id: li.dataset.macroId,
			slot: li.dataset.slot,
		};
		event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
	}

	/* -------------------------------------------- */

	/**
	 * Allow data transfer events to be dragged over this as a drop zone
	 * @private
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle data being dropped onto the Hotbar
	 * @param {Event} event   The originating drop event
	 * @private
	 */
	_onDrop(event) {
		event.preventDefault();

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return;
		}

		// Get the drop target
		const li = event.target.closest('.macro');

		// Allow for a Hook function to handle the event
		if (Hooks.call('hotbarDrop', this, data, li.dataset.slot) === false)
			return;

		// Only handle Macro drops
		if (data.type !== 'Macro') return;
		const macro = game.macros.get(data.id);
		if (!macro) return;
		game.user.assignHotbarMacro(macro, li.dataset.slot, {
			fromSlot: data.slot,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to toggle display of the macro bar
	 * @param {Event} event
	 * @private
	 */
	_onToggleBar(event) {
		event.preventDefault();
		if (this._collapsed) this.expand();
		else this.collapse();
	}
}

/**
 * An abstract base class for displaying a heads-up-display interface bound to a Placeable Object on the canvas
 * @type {Application}
 */
class BasePlaceableHUD extends Application {
	constructor(...args) {
		super(...args);

		/**
		 * Reference a PlaceableObject this HUD is currently bound to
		 * @type {PlaceableObject}
		 */
		this.object = null;

		/**
		 * Track the HUD display state
		 * @type {Number}
		 */
		this._displayState = null;
	}

	/* -------------------------------------------- */

	/**
	 * Define the default options which are supported by any BasePleaceableHUD subclass
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['placeable-hud'],
			popOut: false,
		});
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Bind the HUD to a new PlaceableObject and display it
	 * @param {PlaceableObject} object    A PlaceableObject instance to which the HUD should be bound
	 */
	bind(object) {
		this.clear();

		// Record the new object
		if (
			!(object instanceof PlaceableObject) ||
			object.scene !== canvas.scene
		) {
			throw new Error(
				'You may only bind a HUD instance to a PlaceableObject in the currently viewed Scene.'
			);
		}
		this.object = object;

		// Render the HUD
		this.render(true);
		this._displayState = this.constructor.DISPLAY_STATES.RENDERING;
		this.element.hide().fadeIn(200, () => {
			this._displayState = this.constructor.DISPLAY_STATES.RENDERED;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Clear the HUD by fading out it's active HTML and recording the new display state
	 */
	clear() {
		const el = this.element;
		let states = this.constructor.DISPLAY_STATES;
		if (!el.is(':visible')) return;
		this._displayState = states.CLEARING;
		this.element.fadeOut(200, () => (this._displayState = states.NONE));
	}

	/* -------------------------------------------- */

	/**
	 * Set the position of the HUD element after rendering it and flag the latest display state
	 * @private
	 */
	async _render(...args) {
		await super._render(...args);
		this.setPosition();
		this._displayState = this.constructor.DISPLAY_STATES.RENDERED;
	}

	/* -------------------------------------------- */

	getData() {
		const data = duplicate(this.object.data);
		return mergeObject(data, {
			id: this.id,
			classes: this.options.classes.join(' '),
			appId: this.appId,
			isGM: game.user.isGM,
			icons: CONFIG.controlIcons,
		});
	}

	/* -------------------------------------------- */

	setPosition(options = {}) {
		const position = {
			width: options.width || this.object.width,
			height: options.height || this.object.height,
			left: options.left || this.object.x,
			top: options.top || this.object.y,
		};
		this.element.css(position);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate event listeners which provide interactivity for the Token HUD application
	 * @param html
	 */
	activateListeners(html) {
		html.find('.visibility').click(this._onToggleVisibility.bind(this));
		html.find('.locked').click(this._onToggleLocked.bind(this));
		html.find('.sort-up').click(this._onSort.bind(this, true));
		html.find('.sort-down').click(this._onSort.bind(this, false));
	}

	/* -------------------------------------------- */

	/**
	 * Toggle Drawing visibility state
	 * @private
	 */
	async _onToggleVisibility(event) {
		event.preventDefault();
		await this.object.update(canvas.scene._id, {
			hidden: !this.object.data.hidden,
		});
		$(event.currentTarget).toggleClass('active');
	}

	/* -------------------------------------------- */

	/**
	 * Toggle Drawing locked state
	 * @private
	 */
	async _onToggleLocked(event) {
		event.preventDefault();
		await this.object.update(canvas.scene._id, {
			locked: !this.object.data.locked,
		});
		$(event.currentTarget).toggleClass('active');
	}

	/* -------------------------------------------- */

	/**
	 * Handle sorting the z-order of the object
	 * @param event
	 * @param up
	 * @return {Promise<void>}
	 * @private
	 */
	async _onSort(up, event) {
		event.preventDefault();
		if (up) this.object.sortToFront();
		else this.object.sortToBack();
	}
}

/* -------------------------------------------- */

/**
 * BasePlaceableHUD display states
 * @type {Object}
 */
BasePlaceableHUD.DISPLAY_STATES = {
	NONE: 0,
	RENDERING: 1,
	RENDERED: 2,
	CLEARING: 3,
};
/**
 * A simple main menu application
 * @type {Application}
 */
class MainMenu extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'menu';
		options.template = 'templates/hud/menu.html';
		options.popOut = false;
		return options;
	}

	/* -------------------------------------------- */

	getData() {
		return {
			items: this.items,
		};
	}

	/* ----------------------------------------- */

	get items() {
		return {
			reload: {
				label: 'MENU.Reload',
				icon: '<i class="fas fa-redo"></i>',
				enabled: true,
				onClick: () => window.location.reload(),
			},
			player: {
				label: 'MENU.Logout',
				icon: '<i class="fas fa-user"></i>',
				enabled: true,
				onClick: () => (window.location.href = './join'),
			},
			players: {
				label: 'MENU.Players',
				icon: '<i class="fas fa-users"></i>',
				enabled: game.user.isGM,
				onClick: () => (window.location.href = './players'),
			},
			world: {
				label: 'MENU.Setup',
				icon: '<i class="fas fa-globe"></i>',
				enabled: game.user.isGM,
				onClick: () => game.shutDown(),
			},
		};
	}

	/* ----------------------------------------- */

	activateListeners(html) {
		for (let [k, v] of Object.entries(this.items)) {
			html.find('.menu-' + k).click(ev => v.onClick());
		}
	}

	/* ----------------------------------------- */

	/**
	 * Toggle display of the menu (or render it in the first place)
	 */
	toggle() {
		let menu = this.element;
		if (!menu.length) this.render(true);
		else menu.slideToggle(150);
	}
}
/**
 * Top menu scene navigation
 * @type {Application}
 */
class SceneNavigation extends Application {
	constructor(options) {
		super(options);
		game.scenes.apps.push(this);

		/**
		 * Navigation collapsed state
		 * @type {Boolean}
		 */
		this._collapsed = false;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the SceneNavigation UI
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'navigation',
			template: 'templates/hud/navigation.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of Scenes which are displayed in the Navigation bar
	 * @return {Array}
	 */
	get scenes() {
		const scenes = game.scenes.entities.filter(
			s => s.data.navigation || s.active || s.isView
		);
		scenes.sort((a, b) => a.data.navOrder - b.data.navOrder);
		return scenes;
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/**
	 * Extend the Application.render logic to first check the rendering context to see what was changed
	 * If a specific context was provided, make sure an update to the navigation is necessary before rendering
	 */
	render(force, context = {}) {
		let { renderContext, renderData } = context;
		if (renderContext) {
			const events = ['createScene', 'updateScene', 'deleteScene'];
			if (!events.includes(renderContext)) return;
			const updateKeys = [
				'name',
				'permission',
				'permission.default',
				'active',
				'navigation',
				'navName',
				'navOrder',
			];
			if (
				renderContext === 'updateScene' &&
				!updateKeys.some(k => renderData.hasOwnProperty(k))
			)
				return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the default data which is required to render the SceneNavigation menu
	 * @return {Object}
	 */
	getData() {
		// Modify Scene data
		const scenes = this.scenes.map(s => {
			let data = duplicate(s.data);
			let users = game.users.entities.filter(
				u => u.active && u.data.scene === s._id
			);
			data.name = data.navName || data.name;
			data.users = users.map(u => {
				return { letter: u.name[0], color: u.data.color };
			});
			data.visible = game.user.isGM || s.owner || s.active;
			data.css = [
				s.isView ? 'view' : null,
				s.active ? 'active' : null,
				data.permission.default === 0 ? 'gm' : null,
			]
				.filter(c => !!c)
				.join(' ');
			return data;
		});

		// Return data for rendering
		return {
			collapsed: this._collapsed,
			scenes: scenes,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Expand the SceneNavigation menu, sliding it down if it is currently collapsed
	 */
	expand() {
		if (!this._collapsed) return true;
		const nav = this.element;
		const icon = nav.find('#nav-toggle i.fas');
		const ul = nav.children('#scene-list');
		return new Promise(resolve => {
			ul.slideDown(200, () => {
				nav.removeClass('collapsed');
				icon.removeClass('fa-caret-down').addClass('fa-caret-up');
				this._collapsed = false;
				resolve(true);
			});
			Hooks.callAll('collapseSceneNavigation', this, this._collapsed);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the SceneNavigation menu, sliding it up if it is currently expanded
	 */
	async collapse() {
		if (this._collapsed) return true;
		const nav = this.element;
		const icon = nav.find('#nav-toggle i.fas');
		const ul = nav.children('#scene-list');
		return new Promise(resolve => {
			ul.slideUp(200, () => {
				nav.addClass('collapsed');
				icon.removeClass('fa-caret-up').addClass('fa-caret-down');
				this._collapsed = true;
				resolve(true);
			});
			Hooks.callAll('collapseSceneNavigation', this, this._collapsed);
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Activate Scene Navigation event listeners
	 * @param html
	 */
	activateListeners(html) {
		// Click event listener
		const scenes = html.find('.scene');
		scenes.click(this._onClickScene.bind(this));
		html.find('#nav-toggle').click(this._onToggleNav.bind(this));

		// Activate Context Menu
		const contextOptions = this._getContextMenuOptions();
		Hooks.call('getSceneNavigationContext', html, contextOptions);
		if (contextOptions) new ContextMenu(html, '.scene', contextOptions);

		// Make each Scene draggable and droppable
		scenes.each((i, li) => {
			li.setAttribute('draggable', true);
			li.addEventListener(
				'dragstart',
				this._onDragStart.bind(this),
				false
			);
		});
		html[0].ondragover = this._onDragOver.bind(this);
		html[0].ondrop = this._onDrop.bind(this);
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be applied for Scenes in the menu
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getContextMenuOptions() {
		return [
			{
				name: 'SCENES.Activate',
				icon: '<i class="fas fa-bullseye"></i>',
				condition: game.user.isGM,
				callback: li => {
					let scene = game.scenes.get(li.attr('data-scene-id'));
					scene.activate();
				},
			},
			{
				name: 'SCENES.Configure',
				icon: '<i class="fas fa-cogs"></i>',
				condition: game.user.isGM,
				callback: li => {
					let scene = game.scenes.get(li.attr('data-scene-id'));
					scene.sheet.render(true);
				},
			},
			{
				name: 'SCENES.Notes',
				icon: '<i class="fas fa-scroll"></i>',
				condition: game.user.isGM,
				callback: li => {
					let scene = game.scenes.get(li.attr('data-scene-id'));
					scene.notes.render(true);
				},
			},
			{
				name: 'SCENES.Preload',
				icon: '<i class="fas fa-download"></i>',
				condition: game.user.isGM,
				callback: li => {
					let sceneId = li.attr('data-scene-id');
					game.scenes.preload(sceneId, true);
				},
			},
			{
				name: 'SCENES.ToggleNav',
				icon: '<i class="fas fa-compass"></i>',
				condition: game.user.isGM,
				callback: li => {
					const scene = game.scenes.get(li.attr('data-scene-id'));
					scene.update({ navigation: !scene.data.navigation });
				},
			},
		];
	}

	/* -------------------------------------------- */

	/**
	 * Handle left-click events on the scenes in the navigation menu
	 * @param {Event} event
	 * @private
	 */
	_onClickScene(event) {
		event.preventDefault();
		let sceneId = event.currentTarget.dataset.sceneId;
		game.scenes.get(sceneId).view();
	}

	/* -------------------------------------------- */

	/**
	 * Begin a drag and drop workflow from the Scene navigation bar
	 * @param {Event} event
	 * @private
	 */
	_onDragStart(event) {
		const sceneId = event.currentTarget.dataset.sceneId;
		event.dataTransfer.setData(
			'text/plain',
			JSON.stringify({
				type: 'SceneNavigation',
				id: sceneId,
			})
		);
	}

	/* -------------------------------------------- */

	/**
	 * Allow drag/dropping on the navigation bar by preventing default and returning false
	 * @param {Event} event
	 * @private
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle SceneNavigation sort drop to re-order the elements of the navigation bar
	 * @param {Event} event
	 * @private
	 */
	async _onDrop(event) {
		event.preventDefault();

		// Process drop data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}
		if (data.type !== 'SceneNavigation') return false;

		// Identify the entity, the drop target, and the set of siblings
		const entity = game.scenes.get(data.id);
		const dropTarget = event.target.closest('.scene') || null;
		const sibling = dropTarget
			? game.scenes.get(dropTarget.dataset.sceneId)
			: null;
		if (sibling && sibling._id === entity._id) return;
		const siblings = this.scenes.filter(s => s._id !== entity._id);

		// Update the navigation sorting for each Scene
		entity.sortRelative({
			target: sibling,
			siblings: siblings,
			sortKey: 'navOrder',
			sortBefore: true,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle navigation menu toggle click events
	 * @param {Event} event
	 * @private
	 */
	_onToggleNav(event) {
		event.preventDefault();
		if (this._collapsed) this.expand();
		else this.collapse();
	}
}

/**
 * Pause notification in the HUD
 * @type {Application}
 */
class Pause extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'pause';
		options.template = 'templates/hud/pause.html';
		options.popOut = false;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the default data which is required to render the Pause UI
	 */
	getData() {
		return {
			paused: game.paused,
		};
	}
}

/* -------------------------------------------- */

/**
 * The active Player List application
 * @type {Application}
 */
class PlayerList extends Application {
	constructor(options) {
		super(options);
		game.users.apps.push(this);

		/**
		 * An internal toggle for whether or not to show offline players or hide them
		 * @type {boolean}
		 * @private
		 */
		this._showOffline = false;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by the PlayerList UI
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'players',
			template: 'templates/user/players.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/**
	 * Extend the render logic to first check whether a render is necessary based on the context
	 * If a specific context was provided, make sure an update to the navigation is necessary before rendering
	 */
	render(force, context = {}) {
		let { renderContext, renderData } = context;
		if (renderContext) {
			const events = ['createUser', 'updateUser', 'deleteUser'];
			if (!events.includes(renderContext)) return;
			const updateKeys = [
				'name',
				'permission',
				'permission.default',
				'active',
				'navigation',
			];
			if (
				renderContext === 'updateUser' &&
				!updateKeys.some(k => renderData.hasOwnProperty(k))
			)
				return;
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the default data which is required to render the PlayerList ui
	 */
	getData(options) {
		// Process user data by adding extra characteristics
		const users = game.users.entities
			.filter(u => this._showOffline || u.active)
			.map(u => {
				u.charname = u.character ? u.character.name.split(' ')[0] : '';
				const color = u.active ? u.data.color : '#333333',
					rgb = PIXI.utils.hex2rgb(color.replace('#', '0x')),
					border = u.active
						? PIXI.utils.hex2string(
								PIXI.utils.rgb2hex(
									rgb.map(c => Math.min(c * 2, 1))
								)
						  )
						: '#000000';
				u.color = color;
				u.border = border;
				return u;
			});

		// Determine whether to hide the players list when using AV conferencing
		let hide = false;
		if (
			game.webrtc &&
			game.webrtc.settings.mode >= WebRTCSettings.WEBRTC_MODE.VIDEO
		) {
			hide = game.webrtc.settings.hidePlayerList;
		}

		// Return the data for rendering
		return {
			users: users,
			showOffline: this._showOffline,
			hide: hide,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/**
	 * Add a context menu to the players UI which allows players to control or release Actors that they own
	 */
	activateListeners(html) {
		// Toggle online/offline
		html.find('h3').click(this._onToggleOfflinePlayers.bind(this));

		// Context menu
		new ContextMenu(html, '.player', [
			{
				name: game.i18n.localize('PLAYERS.ConfigTitle'),
				icon: '<i class="fas fa-male"></i>',
				callback: li => {
					let userId = li.data('user-id'),
						user = game.user.isGM
							? game.users.get(userId)
							: game.user;
					new PlayerConfig(user).render(true);
				},
			},
			{
				name: game.i18n.localize('PLAYERS.ViewAvatar'),
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					let user = game.users.get(li.data('user-id'));
					return user.avatar !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					let user = game.users.get(li.data('user-id'));
					new ImagePopout(user.avatar, {
						title: user.name,
						shareable: false,
						entity: { type: 'User', id: user.id },
					}).render(true);
				},
			},
			{
				name: game.i18n.localize('PLAYERS.PullToScene'),
				icon: '<i class="fas fa-directions"></i>',
				condition: game.user.isGM,
				callback: li =>
					game.socket.emit(
						'pullToScene',
						canvas.scene._id,
						li.data('user-id')
					),
			},
		]);
	}

	/* -------------------------------------------- */

	/**
	 * Toggle display of the Players hud setting for whether or not to display offline players
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onToggleOfflinePlayers(event) {
		event.preventDefault();
		this._showOffline = !this._showOffline;
		this.render();
	}
}

/**
 * The JournalEntry Configuration Sheet
 * @type {BaseEntitySheet}
 *
 * @param entity {JournalEntry}  The JournalEntry instance which is being edited
 * @param options {Object}       Application options
 */
class JournalSheet extends BaseEntitySheet {
	constructor(object, options = {}) {
		super(object, options);
		this._sheetMode = this.options.sheetMode || this._inferDefaultMode();
	}

	/* -------------------------------------------- */

	_inferDefaultMode() {
		const hasImage = !!this.object.data.img;
		const otherwise = this.object.limited ? null : 'text';
		return hasImage ? 'image' : otherwise;
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			classes: ['sheet', 'journal-sheet'],
			width: 720,
			height: 800,
			resizable: true,
			closeOnSubmit: false,
			submitOnClose: true,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	get id() {
		return `journal-${this.object.id}`;
	}

	/* -------------------------------------------- */

	/** @override */
	get template() {
		if (this._sheetMode === 'image')
			return ImagePopout.defaultOptions.template;
		return 'templates/journal/sheet.html';
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		if (this.object.permission <= CONST.ENTITY_PERMISSIONS.LIMITED)
			return '';
		return this.object.name;
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(force, options = {}) {
		// Determine the sheet rendering mode
		const mode = options.sheetMode || this._sheetMode;
		if (mode === null) return false;
		if (mode === this._sheetMode && this._rendered)
			return super._render(force, options);

		// Asynchronously begin closing the current sheet
		let promises = [this.close({ submit: false })];

		// Update image sizing
		if (mode === 'image') {
			const img = this.object.data.img;
			if (img)
				promises.push(
					ImagePopout.getPosition(img).then(position => {
						this.position = position;
					})
				);
			options.classes = this.options.classes.concat(
				ImagePopout.defaultOptions.classes
			);
		}

		// Update text sizing
		else if (mode === 'text') {
			this.position = {
				width: this.options.width,
				height: this.options.height,
			};
		}

		// Render the new sheet once things are processed
		return Promise.all(promises).then(() => {
			this._sheetMode = mode;
			return super._render(force, options);
		});
	}

	/* -------------------------------------------- */

	/** @override */
	_getHeaderButtons() {
		let buttons = super._getHeaderButtons();
		let isOwner = this.object.owner,
			atLeastLimited = this.object.hasPerm(game.user, 'LIMITED'),
			atLeastObserver = this.object.hasPerm(game.user, 'OBSERVER'),
			hasMultipleModes = this.object.data.img && this.object.data.content;

		// Image Mode
		if (isOwner || (atLeastLimited && hasMultipleModes)) {
			buttons.unshift({
				label: 'Image',
				class: 'entry-image',
				icon: 'fas fa-image',
				onclick: ev => this._onSwapMode(ev, 'image'),
			});
		}

		// Text Mode
		if (isOwner || (atLeastObserver && hasMultipleModes)) {
			buttons.unshift({
				label: 'Text',
				class: 'entry-text',
				icon: 'fas fa-file-alt',
				onclick: ev => this._onSwapMode(ev, 'text'),
			});
		}

		// Share Entry
		if (game.user.isGM) {
			buttons.unshift({
				label: 'Show Players',
				class: 'share-image',
				icon: 'fas fa-eye',
				onclick: ev => this._onShowPlayers(ev),
			});
		}

		// Compendium Import
		if (this.entity.compendium) {
			buttons.unshift({
				label: 'Import',
				class: 'import',
				icon: 'fas fa-download',
				onclick: async ev => {
					await this.close();
					this.entity.collection.importFromCollection(
						this.options.compendium,
						this.entity._id
					);
				},
			});
		}
		return buttons;
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		const data = super.getData();
		data.title = this.title; // Needed for image mode
		data.image = this.object.data.img;
		data.folders = game.data.folders.filter(f => f.type === 'JournalEntry');
		return data;
	}

	/* -------------------------------------------- */

	/** @override */
	_updateObject(event, formData) {
		if (this._sheetMode === 'image') {
			formData.name = formData.title;
			delete formData['title'];
			formData.img = formData.image;
			delete formData['image'];
		}
		super._updateObject(event, formData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to switch the rendered mode of the Journal Entry sheet
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 * @param {string} mode   The journal mode to display
	 */
	async _onSwapMode(event, mode) {
		event.preventDefault();
		await this.submit();
		this.render(true, { sheetMode: mode });
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests to show the referenced Journal Entry to other Users
	 * Save the form before triggering the show request, in case content has changed
	 * @param {Event} event   The triggering click event
	 */
	async _onShowPlayers(event) {
		event.preventDefault();
		await this.submit();
		return this.object.show(this._sheetMode, true);
	}
}

CONFIG.JournalEntry.sheetClass = JournalSheet;

/**
 * Placeable Note configuration sheet
 * @type {FormApplication}
 * @param note {Note}          The Note object for which settings are being configured
 * @param options {Object}     Additional Application options
 */
class NoteConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'note-config';
		options.title = 'Journal Note Configuration';
		options.template = 'templates/scene/note-config.html';
		options.width = 400;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		const entry = game.journal.get(this.object.data.entryId) || {};
		return {
			entryId: entry._id,
			entries: game.journal.entities,
			object: duplicate(this.object.data),
			options: this.options,
			entryName: entry.name,
			entryIcons: CONFIG.JournalEntry.noteIcons,
			textAnchors: Object.entries(CONST.TEXT_ANCHOR_POINTS).reduce(
				(obj, e) => {
					obj[e[1]] = e[0].titleCase();
					return obj;
				},
				{}
			),
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(canvas.scene._id, formData);
		} else {
			this.object.constructor.create(canvas.scene._id, formData);
			canvas.notes.preview.removeChildren();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Extend the logic applied when the application is closed to clear any preview notes
	 * @return {Promise}
	 */
	async close() {
		if (!this.object.id) canvas.notes.preview.removeChildren();
		return super.close();
	}
}

/**
 * Configuration sheet for the Drawing object
 * @type {FormApplication}
 *
 * @param drawing {Drawing}          The Drawing object being configured
 * @param options {Object}           Additional application rendering options
 * @param options.preview {Boolean}  Configure a preview version of the Drawing which is not yet saved
 */
class DrawingConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'drawing-config';
		options.classes = ['sheet'];
		options.template = 'templates/scene/drawing-config.html';
		options.width = 480;
		options.height = 360;
		options.configureDefault = false;
		return options;
	}

	/* -------------------------------------------- */

	get title() {
		let title = 'Drawing Configuration';
		return this.options.configureDefault ? 'Default ' + title : title;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		const author = game.users.get(this.object.data.author);

		// Submit text
		let submit;
		if (this.options.configureDefault) submit = 'Configure Default';
		else submit = this.options.preview ? 'Create' : 'Update';

		// Return data
		return {
			author: author ? author.name : '',
			fillTypes: Object.entries(CONST.DRAWING_FILL_TYPES).reduce(
				(obj, v) => {
					obj[v[1]] = v[0].titleCase();
					return obj;
				},
				{}
			),
			fontFamilies: CONFIG.fontFamilies,
			object: duplicate(this.object.data),
			options: this.options,
			submitText: submit,
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (!this.object.owner)
			throw new Error(
				'You do not have the ability to configure this Drawing object.'
			);

		// Configure the default Drawing settings
		if (this.options.configureDefault) {
			return game.settings.set(
				'core',
				DrawingsLayer.DEFAULT_CONFIG_SETTING,
				formData
			);
		}

		// Create or update a Drawing
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(this.object.scene._id, formData);
		} else this.object.constructor.create(this.object.scene._id, formData);
	}

	/* -------------------------------------------- */

	/**
	 * Extend the application close method to clear any preview sound aura if one exists
	 */
	close() {
		super.close();
		if (this.preview) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate listeners to handle events in the rendered HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Tabbed navigation
		new Tabs(html.find('.tabs'), {
			initial: this._tab,
			callback: clicked => (this._tab = clicked.data('tab')),
		});

		// Range inputs
		html.find('input[type="range"]').change(this._onRangeChange.bind(this));

		// Reset default
		html.find('button[name="resetDefault"]').click(
			this._onResetDefaults.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to a range type input by propagating those changes to the sibling span element
	 * @param event
	 * @private
	 */
	_onRangeChange(event) {
		event.preventDefault();
		let span = $(event.target).siblings('.range-value');
		span.text(event.target.value);
	}

	/* -------------------------------------------- */

	/**
	 * Reset the user Drawing configuration settings to their default values
	 * @param event
	 * @private
	 */
	_onResetDefaults(event) {
		event.preventDefault();
		game.settings.set('core', DrawingsLayer.DEFAULT_CONFIG_SETTING, {});
		this.object.data = canvas.drawings._getNewDrawingData({});
		this.render();
	}
}

/* -------------------------------------------- */

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Drawing objects.
 * @type {BasePlaceableHUD}
 */
class DrawingHUD extends BasePlaceableHUD {
	/**
	 * Assign the default options which are supported by the entity edit sheet
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'drawing-hud',
			template: 'templates/hud/drawing-hud.html',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Extend the data object provided to render HTML for the Drawing HUD
	 * @return {Object}
	 */
	getData() {
		const data = super.getData();
		return mergeObject(data, {
			lockedClass: data.locked ? 'active' : '',
			visibilityClass: data.hidden ? 'active' : '',
		});
	}

	/* -------------------------------------------- */

	setPosition() {
		let { x, y, width, height } = this.object.frame.getLocalBounds();
		const position = {
			width: width + 150,
			height: height + 20,
			left: x + this.object.data.x - 70,
			top: y + this.object.data.y + 20,
		};
		this.element.css(position);
	}
}

/**
 * Light Source Configuration Sheet
 * @type {FormApplication}
 *
 * @param light {AmbientLight} The AmbientLight object for which settings are being configured
 * @param options {Object}     LightConfig ui options (see Application)
 */
class LightConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'light-config';
		options.classes = ['sheet', 'light-config'];
		options.title = 'Light Source Configuration';
		options.template = 'templates/scene/light-config.html';
		options.width = 480;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: this.options.preview ? 'Create' : 'Update',
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate listeners to handle events in the rendered HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Range inputs
		html.find('input[type="range"]').change(this._onRangeChange.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to a range type input by propagating those changes to the sibling span element
	 * @param event
	 * @private
	 */
	_onRangeChange(event) {
		event.preventDefault();
		const span = event.target.parentElement.querySelector('.range-value');
		span.innerHTML = event.target.value;
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (!game.user.isGM)
			throw 'You do not have the ability to configure an AmbientLight object.';
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(canvas.scene._id, formData);
		} else this.object.constructor.create(canvas.scene._id, formData);
	}
}

/**
 * Ambient Sound Config Sheet
 * @type {FormApplication}
 *
 * @param sound {AmbientSound}       The sound object being configured
 * @param options {Object}           Additional application rendering options
 * @param options.preview {Boolean}  Configure a preview version of a sound which is not yet saved
 */
class AmbientSoundConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'sound-config';
		options.classes = ['sheet', 'sound-sheet'];
		options.title = 'Ambient Sound Configuration';
		options.template = 'templates/scene/sound-config.html';
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: this.options.preview ? 'Create' : 'Update',
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (!game.user.isGM)
			throw 'You do not have the ability to configure an AmbientSound object.';
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(canvas.scene._id, formData);
		} else this.object.constructor.create(canvas.scene._id, formData);
	}

	/* -------------------------------------------- */

	/**
	 * Extend the application close method to clear any preview sound aura if one exists
	 */
	close() {
		super.close();
		if (this.preview) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}
}

/* -------------------------------------------- */

/**
 * Tile Config Sheet
 * @type {FormApplication}
 *
 * @param tile {Tile}                The Tile object being configured
 * @param options {Object}           Additional application rendering options
 * @param options.preview {Boolean}  Configure a preview version of a tile which is not yet saved
 */
class TileConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'tile-config';
		options.classes = ['sheet', 'tile-sheet'];
		options.title = 'Tile Configuration';
		options.template = 'templates/scene/tile-config.html';
		options.width = 400;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			submitText: this.options.preview ? 'Create' : 'Update',
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		if (!game.user.isGM)
			throw 'You do not have the ability to configure a Tile object.';
		if (this.object.id) {
			formData['id'] = this.object.id;
			this.object.update(canvas.scene._id, formData);
		} else this.object.constructor.create(canvas.scene._id, formData);
	}

	/* -------------------------------------------- */

	/**
	 * Extend the application close method to clear any preview sound aura if one exists
	 */
	close() {
		super.close();
		if (this.preview) {
			this.preview.removeChildren();
			this.preview = null;
		}
	}
}

/* -------------------------------------------- */

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Tile objects.
 * @type {BasePlaceableHUD}
 */
class TileHUD extends BasePlaceableHUD {
	/**
	 * Assign the default options which are supported by the entity edit sheet
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'tile-hud',
			template: 'templates/hud/drawing-hud.html',
		});
	}

	/* -------------------------------------------- */

	/**
	 * Extend the data object provided to render HTML for the Tile HUD
	 * @return {Object}
	 */
	getData() {
		const data = super.getData();
		return mergeObject(data, {
			lockedClass: data.locked ? 'active' : '',
			visibilityClass: data.hidden ? 'active' : '',
		});
	}

	/* -------------------------------------------- */

	setPosition() {
		const position = {
			width: this.object.data.width + 140,
			height: this.object.data.height + 10,
			left: this.object.x - 70,
			top: this.object.y - 5,
		};
		this.element.css(position);
	}
}

/**
 * A Token Configuration Application
 * @type {FormApplication}
 *
 * @param token {Token}      The Token object for which settings are being configured
 * @param options {Object}   TokenConfig ui options (see Application)
 *
 * @param options.configureDefault {Boolean}   Configure the default actor token on submit
 */
class TokenConfig extends FormApplication {
	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'token-config',
			classes: ['sheet', 'token-sheet'],
			template: 'templates/scene/token-config.html',
			width: 480,
			height: 360,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access for the Token object
	 * @type {Token}
	 */
	get token() {
		return this.object;
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access for the Token's linked Actor, if any
	 * @type {Actor|null}
	 */
	get actor() {
		return this.token.actor;
	}

	/* -------------------------------------------- */

	/** @override */
	get title() {
		if (this.options.configureDefault)
			return `[${game.i18n.localize('TOKEN.TitlePrototype')}] ${
				this.actor.name
			}`;
		return `${this.token.name}: ${game.i18n.localize('TOKEN.Title')}`;
	}

	/* -------------------------------------------- */

	/**
	 * Convert Token display modes to an object of values and labels
	 * @return {Object}
	 */
	get displayModes() {
		const modes = {};
		for (let [k, v] of Object.entries(CONST.TOKEN_DISPLAY_MODES)) {
			modes[v] = k.replace('_', ' ').titleCase();
		}
		return modes;
	}

	/* -------------------------------------------- */

	/** @override */
	async getData() {
		const actor = this.token.actor;
		let hasAlternates = actor ? actor.data.token.randomImg : false;
		return {
			cssClasses: [this.options.configureDefault ? 'prototype' : null]
				.filter(c => !!c)
				.join(' '),
			isPrototype: this.options.configureDefault,
			hasAlternates: hasAlternates,
			alternateImages: hasAlternates
				? await this._getAlternateTokenImages()
				: [],
			object: duplicate(this.token.data),
			options: this.options,
			gridUnits: canvas.ready
				? canvas.scene.data.gridUnits
				: game.system.gridUnits,
			barAttributes: this.getBarAttributes(),
			displayModes: this.displayModes,
			actors: game.actors.entities
				.map(a => {
					return { _id: a._id, name: a.name };
				})
				.sort(),
			dispositions: Object.keys(CONST.TOKEN_DISPOSITIONS).reduce(
				(obj, key) => {
					obj[game.i18n.localize(`TOKEN.${key}`)] =
						CONST.TOKEN_DISPOSITIONS[key];
					return obj;
				},
				{}
			),
		};
	}

	/* -------------------------------------------- */

	/**
	 * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar
	 * @return {Array}
	 */
	getBarAttributes() {
		let actor = this.token.actor;
		if (actor) {
			let valid = this._getBarAttributes(actor.data.data);
			return valid.map(v => v.join('.'));
		}
		return [];
	}

	/* -------------------------------------------- */

	/**
	 * Test whether an individual data object is a valid attribute - containing both a numeric value and max
	 * @private
	 */
	_getBarAttributes(data, parent) {
		parent = parent || [];
		let valid = [];
		for (let [k, v] of Object.entries(data)) {
			if (v instanceof Object) {
				let p = parent.concat([k]);
				if (
					Number.isFinite(parseFloat(v.value)) &&
					Number.isFinite(parseFloat(v.max))
				)
					valid.push(p);
				else valid = valid.concat(this._getBarAttributes(data[k], p));
			}
		}
		return valid;
	}

	/* -------------------------------------------- */

	/**
	 * Get an Object of image paths and filenames to display in the Token sheet
	 * @return {Promise}
	 * @private
	 */
	async _getAlternateTokenImages() {
		const images = await this.actor.getTokenImages();
		return images.reduce((obj, i) => {
			obj[i] = i.split('/').pop();
			return obj;
		}, {});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Activate tab navigation
		new Tabs(
			html.find('.tabs'),
			this.token.data.flags['_configTab'],
			clicked => {
				this.actor.data.flags['_configTab'] = clicked.attr('data-tab');
			}
		);

		// Update bar data when the target attribute is changed
		html.find('.bar-attribute').change(this._onBarChange.bind(this));

		// Scale tooltip
		html.find('[name="scale"]').change(ev => {
			ev.currentTarget.nextElementSibling.textContent =
				ev.currentTarget.value;
		});

		// Alternate image assignment
		html.find('.alternate-images').change(
			ev => (ev.target.form.img.value = ev.target.value)
		);

		// Handle Token assignment
		html.find('button.assign-token').click(this._onAssignToken.bind(this));
	}

	/* -------------------------------------------- */

	/** @override */
	_updateObject(event, formData) {
		// Verify the user has the ability to update a Token configuration
		if (!game.user.isTrusted || !this.token.owner) {
			throw new Error(
				'You do not have permission to configure this token'
			);
		}

		// Configure prototype Token data
		if (formData.actorId && this.options.configureDefault) {
			this._updateActorData(formData);
		}

		// Update a token on the canvas
		if (this.token.parent !== null) {
			this.token.update(formData);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update certain fields of a linked actor token when token configuration is changed
	 * @param tokenData {Object}    The new token data
	 */
	_updateActorData(tokenData) {
		// Get the actor to update
		let actor = this.token.actor;
		if (!actor) return;
		let actorData = {};

		// Only update certain default token fields
		let update = {};
		for (let [k, v] of Object.entries(tokenData)) {
			if (
				this.options.configureDefault ||
				['name', 'img'].includes(k) ||
				k.startsWith('bar.')
			) {
				update[k] = v;
			}
		}
		actorData['token'] = mergeObject(actor.data.token, update, {
			insertKeys: false,
			inplace: false,
		});

		// Update linked attribute bar values
		for (let bar of ['bar1', 'bar2'].filter(
			b => tokenData[b + '.attribute']
		)) {
			let attr = tokenData[bar + '.attribute'];
			if (hasProperty(actor.data.data, attr)) {
				actorData[`data.${attr}.value`] = tokenData[bar + '.value'];
				actorData[`data.${attr}.max`] = tokenData[bar + '.max'];
			}
		}

		// Update the Actor
		actor.update(actorData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Token assignment requests to update the default prototype Token
	 * @private
	 */
	_onAssignToken(event) {
		event.preventDefault();
		let tokens = canvas.ready ? canvas.tokens.controlled : [];
		if (tokens.length !== 1) {
			html.shake(2, 20, 50);
			return;
		}

		// Update the controlled token
		const actor = this.actor;
		let token = duplicate(tokens.pop().data);
		token.tokenId = token.x = token.y = null;
		actor.update({ token: token }).then(a => {
			ui.notifications.info(
				`Updated prototype Token configuration for ${actor.name}`
			);
		});
		this.close();
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing the attribute bar in the drop-down selector to update the default current and max value
	 * @private
	 */
	_onBarChange(ev) {
		const form = ev.target.form;
		const bar = ev.target.name.split('.')[0];
		let data = ev.target.value
			? getProperty(this.actor.data.data, ev.target.value)
			: { value: '', max: '' };
		form.querySelector(`input.${bar}-value`).value = data.value;
		form.querySelector(`input.${bar}-max`).value = data.max;
	}
}

/**
 * An implementation of the PlaceableHUD base class which renders a heads-up-display interface for Token objects.
 * This interface provides controls for visibility, attribute bars, elevation, status effects, and more.
 * @type {BasePlaceableHUD}
 */
class TokenHUD extends BasePlaceableHUD {
	/**
	 * Assign the default options which are supported by the entity edit sheet
	 * @type {Object}
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'token-hud',
			template: 'templates/hud/token-hud.html',
		});
	}

	/* -------------------------------------------- */

	/**
	 * When the TokenHUD is bound to a new Token, set the status effects flag back to false
	 */
	bind(object) {
		this._statusEffects = false;
		super.bind(object);
	}

	/* -------------------------------------------- */

	setPosition() {
		const position = {
			width: this.object.w + 160,
			height: this.object.h + 100,
			left: this.object.x - 80,
			top: this.object.y - 50,
		};
		this.element.css(position);
	}

	/* -------------------------------------------- */

	/**
	 * Extend the data object provided to render HTML for the Token HUD
	 * @return {Object}
	 */
	getData() {
		const data = super.getData();
		const bar1 = this.object.getBarAttribute('bar1');
		const bar2 = this.object.getBarAttribute('bar2');
		return mergeObject(data, {
			canConfigure: game.user.isTrusted,
			canToggleCombat: canvas.scene.active,
			displayBar1: bar1.attribute && Number.isNumeric(bar1.value),
			bar1Data: bar1,
			displayBar2: bar2.attribute && Number.isNumeric(bar2.value),
			bar2Data: bar2,
			visibilityClass: data.hidden ? 'active' : '',
			effectsClass: this._statusEffects ? 'active' : '',
			combatClass: this.object.inCombat ? 'active' : '',
			targetClass: this.object.targeted.has(game.user) ? 'active' : '',
			statusEffects: CONFIG.statusEffects.map(src => {
				return {
					src: src,
					cssClass: [
						data.effects.includes(src) ? 'active' : null,
						data.overlayEffect === src ? 'overlay' : null,
					].filter(c => !!c),
				};
			}),
		});
	}

	/* -------------------------------------------- */

	/**
	 * Activate event listeners which provide interactivity for the Token HUD application
	 * @param html
	 */
	activateListeners(html) {
		// Attribute Bars
		let attributeUpdate = this._onAttributeUpdate.bind(this);
		html.find('.attribute input')
			.click(this._onAttributeClick)
			.focusout(attributeUpdate)
			.keydown(attributeUpdate);

		// Token Control Icons
		html.find('.config').click(this._onTokenConfig.bind(this));
		html.find('.combat').click(this._onToggleCombat.bind(this));
		html.find('.effects').click(this._onTokenEffects.bind(this));
		html.find('.visibility').click(this._onToggleVisibility.bind(this));
		html.find('.target').click(this._onToggleTarget.bind(this));

		// Status Effects Controls
		let effects = html.find('.status-effects');
		effects
			.on('click', '.effect-control', this._onToggleEffect.bind(this))
			.on(
				'contextmenu',
				'.effect-control',
				this._onToggleOverlay.bind(this)
			);
	}

	/* -------------------------------------------- */

	/**
	 * Handle initial click to focus an attribute update field
	 * @private
	 */
	_onAttributeClick(event) {
		event.currentTarget.select();
	}

	/* -------------------------------------------- */

	/**
	 * Handle attribute bar update
	 * @private
	 */
	_onAttributeUpdate(event) {
		// Filter keydown events for Enter
		if (event.type === 'keydown') {
			if (event.keyCode === KEYS.ENTER) this.clear();
			return;
		}
		event.preventDefault();

		// Acquire string input
		const input = event.currentTarget;
		let strVal = input.value.trim();
		let isRelative = strVal.startsWith('+') || strVal.startsWith('-');
		if (strVal.startsWith('=')) strVal = strVal.slice(1);
		let value = Number(strVal);

		// For attribute bar values, update the associated Actor
		let bar = input.dataset.bar;
		if (bar) {
			const actor = this.object.actor;
			const data = this.object.getBarAttribute(bar);
			const current = getProperty(actor.data.data, data.attribute);
			if (isRelative)
				value = Math.clamped(
					0,
					Number(current.value) + value,
					current.max
				);
			actor.update({ [`data.${data.attribute}.value`]: value });
		}

		// Otherwise update the Token
		else {
			const current = this.object.data[input.name];
			this.object.update(canvas.scene._id, {
				[input.name]: isRelative ? current + value : value,
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Toggle Token combat state
	 * @private
	 */
	async _onToggleCombat(event) {
		event.preventDefault();
		await this.object.toggleCombat();
		event.currentTarget.classList.toggle('active', this.object.inCombat);
	}

	/* -------------------------------------------- */

	/**
	 * Toggle Token visibility state
	 * @private
	 */
	async _onToggleVisibility(event) {
		event.preventDefault();
		await this.object.toggleVisibility();
		event.currentTarget.classList.toggle('active', this.object.data.hidden);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Token configuration button click
	 * @private
	 */
	_onTokenConfig(event) {
		event.preventDefault();
		this.object.sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Assign Token status effects
	 * @private
	 */
	_onTokenEffects(event) {
		event.preventDefault();
		this._statusEffects = !this._statusEffects;
		let btn = $(event.currentTarget);
		let fx = btn.parents('.col').siblings('.status-effects');
		btn.toggleClass('active');
		fx.toggleClass('active');
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling a token status effect icon
	 * @private
	 */
	_onToggleEffect(event) {
		event.preventDefault();
		let f = $(event.currentTarget);
		this.object.toggleEffect(f.attr('src'));
		f.toggleClass('active');
	}

	/* -------------------------------------------- */

	/**
	 * Handle assigning a status effect icon as the overlay effect
	 * @private
	 */
	_onToggleOverlay(event) {
		event.preventDefault();
		let f = $(event.currentTarget);
		this.object.toggleOverlay(f.attr('src'));
		f.siblings().removeClass('overlay');
		f.toggleClass('overlay');
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling the target state for this Token
	 * @private
	 */
	_onToggleTarget(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const token = this.object;
		const targeted = !token.isTargeted;
		token.setTarget(targeted, { releaseOthers: false });
		btn.classList.toggle('active', targeted);
	}
}

/**
 * Wall Configuration Sheet
 * @type {FormApplication}
 * @param object {Wall}        The Wall object for which settings are being configured
 * @param options {Object}     Additional options which configure the rendering of the configuration sheet.
 */
class WallConfig extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'wall-config';
		options.title = 'Wall Configuration';
		options.template = 'templates/scene/wall-config.html';
		options.width = 400;
		options.editMany = false;
		options.editTargets = [];
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a dynamically rendered title for the Wall Configuration sheet
	 * @type {String}
	 */
	get title() {
		let title = this.options.editMany ? 'WALLS.TitleMany' : 'WALLS.Title';
		return game.i18n.localize(title);
	}

	/* -------------------------------------------- */

	/**
	 * Construct and return the data object used to render the HTML template for this form application.
	 * @return {Object}
	 */
	getData() {
		return {
			object: duplicate(this.object.data),
			options: this.options,
			moveTypes: Object.keys(CONST.WALL_MOVEMENT_TYPES).reduce(
				(obj, key) => {
					let k = CONST.WALL_MOVEMENT_TYPES[key];
					obj[k] = key.titleCase();
					return obj;
				},
				{}
			),
			senseTypes: Object.keys(CONST.WALL_SENSE_TYPES).reduce(
				(obj, key) => {
					let k = CONST.WALL_SENSE_TYPES[key];
					obj[k] = key.titleCase();
					return obj;
				},
				{}
			),
			dirTypes: Object.keys(CONST.WALL_DIRECTIONS).reduce((obj, key) => {
				let k = CONST.WALL_DIRECTIONS[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorTypes: Object.keys(CONST.WALL_DOOR_TYPES).reduce((obj, key) => {
				let k = CONST.WALL_DOOR_TYPES[key];
				obj[k] = key.titleCase();
				return obj;
			}, {}),
			doorStates: Object.keys(CONST.WALL_DOOR_STATES).reduce(
				(obj, key) => {
					let k = CONST.WALL_DOOR_STATES[key];
					obj[k] = key.titleCase();
					return obj;
				},
				{}
			),
			isDoor: this.object.data.door > CONST.WALL_DOOR_TYPES.NONE,
		};
	}

	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		// Update many walls
		const wallIds = this.options.editTargets;
		if (this.options.editMany) {
			const updateData = canvas.scene.data.walls.reduce((arr, w) => {
				if (wallIds.includes(w.id))
					arr.push(mergeObject(w, formData, { inplace: false }));
				return arr;
			}, []);
			return canvas.walls.updateMany(updateData);
		}

		// Update single wall
		else this.object.update(canvas.scene._id, formData);
	}
}

/**
 * The End User License Agreement
 * Display the license agreement and prompt the user to agree before moving forwards
 * @type {Application}
 */
class EULA extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'eula';
		options.template = 'templates/setup/eula.html';
		options.title = 'End User License Agreement';
		options.width = 600;
		return options;
	}

	async getData() {
		let html = await fetch('license.html').then(r => r.text());
		return {
			html: html,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	activateListeners(html) {
		super.activateListeners(html);

		// Agree and submit
		html.find('#sign').click(ev => {
			ev.preventDefault();
			if (!ev.target.form.agree.checked) {
				ui.notifications.error(
					`You must agree to the ${this.options.title} before proceeding.`
				);
				return false;
			}
			game.socket.emit('signEULA', signed => {
				ui.notifications.info(
					'Thank you. Please enjoy Foundry Virtual Tabletop!'
				);
				this.close();
			});
		});

		// Disagree and quit
		html.find('#cancel').click(ev => {
			ev.preventDefault();
			window.location.href = ROUTE_PREFIX + '/quit';
		});
	}
}

/**
 * The Package Configuration setup application
 * @type {Application}
 */
class SetupConfiguration extends FormApplication {
	constructor({ systems, modules, worlds, currentWorld = null } = {}) {
		super({});

		/**
		 * Valid Game Systems to choose from
		 * @type {Array}
		 */
		this.systems = systems;

		/**
		 * Install Modules to configure
		 * @type {Array}
		 */
		this.modules = modules;

		/**
		 * The Array of available Worlds to load
		 * @type {Array}
		 */
		this.worlds = worlds;

		/**
		 * The currently inspected World
		 * @type {String}
		 */
		this.currentWorld = currentWorld;

		/**
		 * The currently viewed tab
		 * @type {String}
		 */
		this._tab = 'worlds';
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'package-configuration',
			classes: ['dark'],
			template: 'templates/setup/setup-config.html',
			width: 960,
			height: 720,
			popOut: false,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		return {
			systems: this.systems,
			modules: this.modules,
			worlds: this.worlds.map(w => {
				w.active = w.id === this.current;
				w.shortDesc =
					w.data.description.length > 250
						? w.data.description.slice(0, 250) + ' ...'
						: w.data.description;
				return w;
			}),
			world: this.worlds.find(w => w.id === this.current),
			current: this.current,
			availabilityLabels: {
				[CONST.PACKAGE_AVAILABILITY_CODES
					.REQUIRES_UPDATE]: game.i18n.localize(
					'SETUP.RequireUpdate'
				),
				[CONST.PACKAGE_AVAILABILITY_CODES
					.REQUIRES_SYSTEM]: game.i18n.localize(
					'SETUP.RequireSystem'
				),
				[CONST.PACKAGE_AVAILABILITY_CODES
					.REQUIRES_DEPENDENCY]: game.i18n.localize(
					'SETUP.RequireDep'
				),
				[CONST.PACKAGE_AVAILABILITY_CODES
					.REQUIRES_CORE]: game.i18n.localize('SETUP.RequireCore'),
			},
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		// Activate Tab Navigation
		new Tabs(html.find('.tabs'), {
			initial: this._tab,
			callback: clicked => (this._tab = clicked.data('tab')),
			container: html,
		});

		// Update Core
		html.find('button.update-core').click(this._onCoreUpdate.bind(this));

		// Install Package
		html.find('button.install').click(this._onInstall.bind(this));

		// Update Package
		html.find('button.update').click(this._onUpdate.bind(this));

		// Uninstall Package
		html.find('button.uninstall').click(this._onUninstall.bind(this));

		// Create World
		html.find('button.create').click(this._onWorldCreate.bind(this));

		// Launch World
		html.find('button.launch').click(this._onWorldLaunch.bind(this));

		// Edit World
		html.find('button.edit-world').click(this._onWorldEdit.bind(this));

		// Update All Packages
		html.find('button.update-all').click(this._onUpdateAll.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle button clicks to update the core VTT software
	 * @param {Event} event
	 * @private
	 */
	_onCoreUpdate(event) {
		const button = event.currentTarget;
		const form = button.form || $(button).closest('form')[0];
		button.disabled = true;

		// Retrieve the update key
		let key = form.updateKey.value;
		form.updateKey.disabled = true;

		// Condition on the button action
		switch (button.dataset.action) {
			// Check for update
			case 'check':
				const label = button.children[1];
				label.innerHTML = 'Checking for Update';
				game.socket.emit('updateCheck', key, target => {
					if (target) {
						label.innerHTML = 'Download Update';
						button.setAttribute('data-action', 'download');
						if (target && target.notes)
							new UpdateNotes(target).render(true);
						button.disabled = false;
					} else {
						label.innerHTML = 'No Update Available';
					}
				});
				break;

			// Download update
			case 'download':
				this._activateProgressListener($(button));
				game.socket.emit('updateDownload', key, target => {
					if (target && target.notes)
						new UpdateNotes(target).render(true);
				});
				break;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle install button clicks to add new packages
	 * @param {Event} event
	 * @private
	 */
	_onInstall(event) {
		event.preventDefault(event);

		// Get the package type
		let btn = $(event.currentTarget);
		let type = btn
			.parent()
			.siblings('.package-list')
			.data('packageType');

		// Prompt for the manifest URL
		const form = `<form><div class="form-group">
                  <label>Manifest URL:</label>
                  <input type="text" name="manifestURL" placeholder="http://path/to/manifest.json" required/>
                  </div></form>`;
		new Dialog({
			title: `Install New ${type.titleCase()}`,
			content: form,
			buttons: {
				install: {
					icon: '<i class="fas fa-download"></i>',
					label: game.i18n.localize('Install'),
					callback: html => {
						let manifestURL = html
							.find('input[name="manifestURL"]')
							.val();
						if (!manifestURL) return;
						game.socket.emit(
							`${type}Install`,
							manifestURL.trim(),
							response => {
								// Handle error response
								if (response.error) {
									ui.notifications.error(response.error);
									return this._reload();
								}

								// Activate Socket listener and handle completion
								ui.notifications.info(response.message);
								this._activateProgressListener(btn)
									.then(() => {
										ui.notifications.info(
											`Installation successful for ${response.manifest.name}`
										);
										this._reload();
									})
									.catch(err => {
										ui.notifications.error(
											`Installation unsuccessful for ${response.manifest.name}`
										);
										this._reload();
									});
							}
						);
					},
				},
				cancel: {
					icon: '<i class="fas fa-times"></i>',
					label: game.i18n.localize('Cancel'),
				},
			},
			default: 'install',
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle update button press for a single Package
	 * @param {Event} event
	 * @private
	 */
	_onUpdate(event) {
		event.preventDefault();

		// Disable the button
		const button = event.currentTarget;
		button.disabled = true;

		// Obtain the package metadata
		let li = button.closest('li.package');
		let id = li.dataset.packageId;
		let type = li.closest('ul.package-list').dataset.packageType;

		// Inquire with the server for updates
		if (button.dataset.state === 'check') {
			return this._updateCheckOne(type, id, button);
		}

		// Execute upon an update
		if (button.dataset.state === 'update') {
			return this._updateDownloadOne(type, id, button);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Execute upon an update check for a single Package
	 * @param {string} type         The package type
	 * @param {string} id           The package id
	 * @param {HTMLElement} button  The update button for the package
	 * @return {Promise<Boolean>}
	 * @private
	 */
	async _updateCheckOne(type, id, button) {
		return new Promise(resolve => {
			game.socket.emit(`${type}Check`, id, available => {
				if (available) {
					button.innerHTML = '<i class="fas fa-download"></i> Update';
					button.dataset.state = 'update';
					button.disabled = false;
				} else {
					button.innerHTML = '<i class="fas fa-check"></i> Updated';
					button.dataset.state = 'none';
					button.disabled = true;
				}
				resolve(available);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Execute upon an update download for a single Package
	 * Returns a Promise which resolves once the download has successfully started
	 * @param {String} type         The package type
	 * @param {String} id           The package id
	 * @param {HTMLElement} button  The Download button
	 * @return {Promise}
	 * @private
	 */
	async _updateDownloadOne(type, id, button) {
		return new Promise((resolve, reject) => {
			game.socket.emit(`${type}Update`, id, response => {
				button.dataset.state = 'none';

				// Handle failure
				if (response.error) {
					ui.notifications.error(response.error);
					button.innerHTML = '<i class="fas fa-times"></i> Failed';
					return reject(response.error);
				}

				// Handle success
				const { manifest, message } = response;
				this._activateProgressListener(button).then(() => {
					button
						.closest('li.package')
						.querySelector('.package-version').innerHTML =
						manifest.version;
				});
				ui.notifications.info(message);
				return resolve(manifest);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Execute upon an update-all workflow to update all packages of a certain type
	 * @param {Event} event
	 * @private
	 */
	async _onUpdateAll(event) {
		event.preventDefault();
		let button = event.currentTarget;
		button.disabled = true;
		let ol = $('.tab.active .package-list');
		let type = ol.data('packageType');

		// Get Packages
		let packages = [];
		ol.children('.package').each((i, li) => {
			packages.push({
				id: li.dataset.packageId,
				status: 'none',
				button: li.querySelector('button.update'),
			});
		});

		// Check updates
		let checks = packages.map(p => {
			return this._updateCheckOne(type, p.id, p.button).then(
				available => (p.available = available)
			);
		});
		await Promise.all(checks);

		// Execute updates one at a time
		for (let p of packages.filter(p => p.available)) {
			await this._updateDownloadOne(
				type,
				p.id,
				p.button
			).catch(err => {});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle uninstall button clicks to remove existing packages
	 * @param {Event} event
	 * @private
	 */
	_onUninstall(event) {
		event.preventDefault();

		// Disable the button
		let button = event.currentTarget;
		button.disabled = true;

		// Obtain the package metadata
		let li = $(button).parents('li.package');
		let id = li.data('packageId');
		let type = li.parents('ul.package-list').data('packageType');

		// Get the target package
		let collection = game.data[type + 's'];
		let idx = collection.findIndex(p => p.id === id);
		let pack = collection[idx];

		// Confirm deletion request and dispatch the socket request
		let msg = `<p>Are you sure you want to delete <strong>${pack.data.title}</strong>?</p>
               <p><strong>Warning:</strong> This operation cannot be un-done.</p>`;
		Dialog.confirm({
			title: `Delete ${type.titleCase()}: ${pack.data.title}`,
			content: msg,
			yes: () => {
				game.socket.emit(`${type}Delete`, id, uninstalled => {
					if (uninstalled)
						ui.notifications.info(
							`${type.titleCase()} ${id} uninstalled successfully.`
						);
					else
						ui.notifications.error(
							`${type.titleCase()} ${id} was not successfully uninstalled.`
						);
					button.disabled = false;
					collection.splice(idx, 1);
					this.render();
				});
			},
			no: () => (button.disabled = false),
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle button press events to launch a specific World
	 * @param {Event} event
	 * @private
	 */
	_onWorldLaunch(event) {
		event.preventDefault();
		let button = event.currentTarget;
		button.disabled = true;
		let li = $(button).parents('li.package');
		let id = li.data('packageId');

		// Populate some additional form fields
		const form = button.form;
		form.id.value = id;
		form.submit();
	}

	/* -------------------------------------------- */

	_onWorldCreate(event) {
		event.preventDefault();
		new WorldConfig({}, { create: true }).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle button press events to launch a specific World
	 * @param {Event} event
	 * @private
	 */
	_onWorldEdit(event) {
		event.preventDefault();
		let button = event.currentTarget;
		let li = $(button).parents('li.package');
		let id = li.data('packageId');
		const worldData = game.data.worlds.find(w => w.id === id);
		new WorldConfig(worldData).render(true);
	}

	/* -------------------------------------------- */

	_reload() {
		Game.getSetupData(game.socket).then(setupData => {
			mergeObject(game.data, setupData);
			mergeObject(this, setupData);
			this.render();
		});
	}

	/* -------------------------------------------- */

	/**
	 * Start a socket listener for update status updates which updates the progress bar
	 * Unhook the listener once the update has completed
	 * @param {HTMLElement} button     The button element to update during the process
	 * @private
	 */
	_activateProgressListener(button) {
		const eventName = `updateProgress`;
		const disabledButtons = [];

		// TODO - Use jQuery for now
		button = $(button);
		const icon = button.children('i');
		const label = button.children('label');
		const initialButtonText = label.text();

		// Define an unhook event and unhook any existing listeners
		const unhook = () => {
			game.socket.off(eventName);
			$('.progress-bar').css('visibility', 'hidden');
			disabledButtons.forEach(btn => (btn.disabled = false));
			label.text(initialButtonText);
		};
		unhook();

		// Disable all other buttons until the update is complete
		$('button').each((i, btn) => {
			if (btn.disabled === false) {
				btn.disabled = true;
				disabledButtons.push(btn);
			}
		});

		// Initial button update
		icon.replaceWith('<i class="fas fa-spinner fa-pulse"></i>');
		label.text('Starting Update');

		// Hook a new listener
		return new Promise((resolve, reject) => {
			game.socket.on(eventName, ({ packageName, msg, pct, step }) => {
				let progress = this.element.find('.tab.active .progress-bar');
				if (!progress) return unhook();
				progress.css('visibility', 'visible');

				// Update bar and label position
				let pl = `${pct}%`;
				let bar = progress.children('.bar');
				bar.css('width', pl);
				let barLabel = progress.children('.pct');
				barLabel.text(pl);
				barLabel.css('left', pl);

				// Update the button display
				label.text(step);

				// Maybe reload
				if (step === 'RELOAD') {
					unhook();
					label.text('Update Complete - Reload Application');
					if (
						!Object.values(ui.windows).some(
							ui => ui instanceof UpdateNotes
						)
					) {
						window.location.href = ROUTE_PREFIX + '/setup';
					}
				}

				// Unhook when complete or failed
				else if (step === 'Done') {
					unhook();
					button[0].innerHTML =
						'<i class="fas fa-check"></i> Success';
					resolve();
				} else if (step === 'Failed') {
					unhook();
					button[0].innerHTML = '<i class="fas fa-times"></i> Failed';
					reject();
				}
			});
		});
	}
}

/**
 * The client side Updater application
 * This displays the progress of patching/update progress for the VTT
 * @type {Application}
 */
class UpdateNotes extends Application {
	constructor(target, options) {
		super(options);
		this.target = target;
	}

	/* ----------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'update-notes',
			template: 'templates/setup/update-notes.html',
			width: 600,
		});
	}

	/* ----------------------------------------- */

	/** @override */
	get title() {
		return `Update Notes - Foundry Virtual Tabletop ${this.target.version}`;
	}

	/* ----------------------------------------- */

	/** @override */
	async getData() {
		return {
			notes: this.target.notesHTML,
		};
	}

	/* ----------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('#return').click(ev => this.close());
	}
}

/**
 * The User Management setup application
 * @type {Application}
 */
class UserManagement extends FormApplication {
	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'manage-players',
			classes: ['dark'],
			template: 'templates/setup/users.html',
			popOut: false,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		return {
			user: game.user,
			users: this.object.entities.map(u => u.data),
			roles: CONST.USER_ROLES,
			options: this.options,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Add new user to the form
		html.find('.create-user').click(ev => this._onUserCreate(ev));

		// Remove user from the form
		html.on('click', '.user-delete', ev => this._onUserDelete(ev));
	}

	/* -------------------------------------------- */

	/** @override */
	_onSubmit(event) {}

	/* -------------------------------------------- */

	/**
	 * Handle new user creation event
	 * @private
	 */
	async _onUserCreate(event) {
		event.preventDefault();
		event.currentTarget.disabled = true;

		// Create the new User
		const user = await User.create({
			name: 'Player ' + $('.player').length,
			role: CONST.USER_ROLES.PLAYER,
		});

		// Render the User's HTML
		const html = await renderTemplate(
			'templates/setup/player-create.html',
			{
				user: user.data,
				roles: CONST.USER_ROLES,
			}
		);

		// Append the player to the list and restore the button
		$('#player-list').append(html);
		event.currentTarget.disabled = false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle user deletion event
	 * @private
	 */
	_onUserDelete(event) {
		event.preventDefault();
		let button = $(event.currentTarget),
			li = button.parents('.player'),
			user = game.users.get(li.attr('data-user-id'));

		// Craft a message
		let message =
			'<h3>Are you sure?</h3><p>This user will be deleted from the game world.</p>';
		if (user.isGM)
			message +=
				'<p class="warning"><strong>You are about to delete a Game-Master user!</strong></p>';

		// Render a confirmation dialog
		new Dialog({
			title: `Delete User ${user.name}?`,
			content: message,
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: 'Delete',
					callback: () => {
						user.delete();
						li.slideUp(200, () => li.remove());
					},
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: 'Cancel',
				},
			},
			default: 'yes',
		}).render(true);
	}
}

/**
 * The World Management setup application
 * @type {Application}
 */
class WorldConfig extends FormApplication {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'world-config',
			template: 'templates/setup/world-config.html',
			width: 560,
			height: 600,
			create: false,
		});
	}

	/* -------------------------------------------- */

	get title() {
		return this.options.create
			? 'Create New World'
			: `Edit World: ${this.object.data.title}`;
	}

	/* -------------------------------------------- */

	/**
	 * Provide data to the form
	 * @return {Object}   The data provided to the template when rendering the form
	 */
	getData() {
		return {
			world: this.object,
			systems: game.data.systems.filter(
				s =>
					(this.object.data && this.object.data.system === s) ||
					!s.data.unavailable
			),
			isCreate: this.options.create,
			submitText: this.options.create ? 'Create World' : 'Update World',
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle World updating or creation given a submitted configuration form
	 * @param event {Event}       The initial triggering submission event
	 * @private
	 */
	async _onSubmit(event) {
		event.preventDefault();
		const FD = this._getFormData(event.target || this.form);
		FD.set('id', this.object.id);
		if (this.options.create) FD.set('target', 'create');
		else FD.set('target', 'edit');

		// Dispatch the POST request
		const response = await fetch(window.location.pathname, {
			method: 'POST',
			body: FD,
		}).then(r => r.json());

		// Display error messages
		if (response.error) return ui.notifications.error(response.error);

		// Handle successful creation
		const world = game.data.worlds.find(w => w.id === response.name);
		if (world) mergeObject(world.data, response);
		else game.data.worlds.push(response);
		ui.setup.render();
		this.close();
	}

	/* -------------------------------------------- */

	/**
	 * By default, when the editor is saved treat it as a form submission event
	 * @private
	 */
	_onEditorSave(target, element, content) {
		element.innerHTML = content;
		let event = new Event('mcesave');
		this._onSubmit(event);
		this.editors[target].active = false;
		this.editors[target].mce.destroy();
		this.editors[target].mce = null;
	}
}

/**
 * Render the Sidebar container, and after rendering insert Sidebar tabs
 */
class Sidebar extends Application {
	constructor(...args) {
		super(...args);

		/**
		 * Sidebar application instances
		 * @type {Array}
		 */
		this.apps = [];

		/**
		 * Sidebar navigation tabs
		 * @type {Tabs}
		 */
		this.tabs = null;

		/**
		 * Reference the name of the active tab
		 * @type {String}
		 */
		this.activeTab = 'chat';

		/**
		 * Track whether the sidebar container is currently collapsed
		 * @type {Boolean}
		 */
		this._collapsed = false;
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'sidebar',
			template: 'templates/sidebar/sidebar.html',
			popOut: false,
			width: 300,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of pop-out sidebar tab Application instances
	 * @type {Array}
	 */
	get popouts() {
		return this.apps.map(a => a._popout).filter(p => p);
	}

	/* -------------------------------------------- */
	/*  Rendering
	/* -------------------------------------------- */

	/** @inheritdoc */
	async _render(...args) {
		// Extend the default rendering function to re-render all contained sidebar tabs
		await super._render(...args);

		// Register named sidebar apps
		const apps = {
			chat: ChatLog,
			combat: CombatTracker,
			scenes: SceneDirectory,
			actors: ActorDirectory,
			items: ItemDirectory,
			journal: JournalDirectory,
			tables: RollTableDirectory,
			playlists: PlaylistDirectory,
			compendium: CompendiumDirectory,
			settings: Settings,
		};
		if (!game.user.isGM) delete apps['scenes'];

		// Render sidebar Applications
		for (let [name, cls] of Object.entries(apps)) {
			let app = (ui[name] = new cls({ tabName: name }));
			await app._render(true, {}).catch(err => {
				console.error(`Failed to render Sidebar tab ${cls.name}`);
				console.error(err);
			});
		}
		this.activateTab(this.activeTab);

		// Maintain a reference to the Macro directory
		ui.macros = new MacroDirectory({ tabName: 'macros' });
	}

	/* -------------------------------------------- */

	/** @inheritdoc */
	getData() {
		return { user: game.user };
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Activate a Sidebar tab by it's name
	 * @param {String} tabName      The tab name corresponding to it's "data-tab" attribute
	 */
	activateTab(tabName) {
		if (this.tabs && this.tabs.tab !== tabName)
			this.tabs.activateTab(tabName);
		const tabApp = ui[tabName];
		if (tabName === 'chat' && tabApp) tabApp.scrollBottom();
		if (this._collapsed) {
			if (tabName !== 'chat') tabApp.renderPopout(tabApp);
		}
		this.activeTab = tabName;
	}

	/* -------------------------------------------- */

	/**
	 * Expand the Sidebar container from a collapsed state.
	 * Take no action if the sidebar is already expanded.
	 */
	expand() {
		if (!this._collapsed) return;
		const sidebar = this.element;
		const tab = sidebar.find('.sidebar-tab.active');
		const icon = sidebar.find('#sidebar-tabs a.collapse i');

		// Animate the sidebar expansion
		tab.hide();
		sidebar.animate(
			{ width: this.options.width, height: this.position.height },
			150,
			() => {
				sidebar.css({ width: '', height: '' });
				icon.removeClass('fa-caret-left').addClass('fa-caret-right');
				tab.fadeIn(250, () => tab.css('display', ''));
				this._collapsed = false;
				sidebar.removeClass('collapsed');
				Hooks.callAll('sidebarCollapse', this, this._collapsed);
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Collapse the sidebar to a minimized state.
	 * Take no action if the sidebar is already collapsed.
	 */
	collapse() {
		if (this._collapsed) return;
		const sidebar = this.element;
		const tab = sidebar.find('.sidebar-tab.active');
		const icon = sidebar.find('#sidebar-tabs a.collapse i');

		// Animate the sidebar collapse
		tab.fadeOut(250, () => {
			sidebar.animate({ width: 30, height: 370 }, 150, () => {
				icon.removeClass('fa-caret-right').addClass('fa-caret-left');
				this._collapsed = true;
				sidebar.addClass('collapsed');
				tab.css('display', '');
				Hooks.callAll('sidebarCollapse', this, this._collapsed);
			});
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
	/* -------------------------------------------- */

	/** @inheritdoc */
	activateListeners(html) {
		// Activate tab controls
		const tabs = html.children('.tabs');
		this.tabs = new Tabs(tabs, {
			initial: this.activeTab,
			callback: tab => this.activateTab(tab.data('tab')),
		});

		// Right click pop-out
		tabs.on('contextmenu', '.item', this._onRightClickTab.bind(this));

		// Toggle Collapse
		tabs.find('.collapse').click(this._onToggleCollapse.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-click events on tab controls to trigger pop-out containers for each tab
	 * @param {Event} event     The originating contextmenu event
	 * @private
	 */
	_onRightClickTab(event) {
		event.preventDefault();
		const li = event.currentTarget;
		const tabName = li.dataset.tab;
		const tabApp = ui[tabName];
		if (tabName !== 'chat') tabApp.renderPopout(tabApp);
	}

	/* -------------------------------------------- */

	/**
	 * Handle toggling of the Sidebar container's collapsed or expanded state
	 * @param {Event} event
	 * @private
	 */
	_onToggleCollapse(event) {
		event.preventDefault();
		if (this._collapsed) this.expand();
		else this.collapse();
	}
}

/**
 * An abstract pattern followed by the different tabs of the sidebar
 * @type {Application}
 * @abstract
 */
class SidebarTab extends Application {
	constructor(options) {
		super(options);

		/**
		 * The name of this sidebar tab
		 * @type {string}
		 */
		this.tabName = options.tabName;

		/**
		 * A reference to the pop-out variant of this SidebarTab, if one exists
		 * @type {SidebarTab}
		 * @private
		 */
		this._popout = null;

		/**
		 * Denote whether or not this is the original version of the sidebar tab, or a pop-out variant
		 * @type {Boolean}
		 */
		this._original = options.original;

		/**
		 * Remember the scroll position of the sidebar tab to restore it upon render
		 * @type {Number}
		 */
		this._scrollTop = null;

		// Back-link to the original tab
		if (this._original) this._original._popout = this;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by this Application
	 * @return {Object}     The default application options for SidebarTab subclasses
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			popOut: false,
			width: 300,
			scrollContainer: 'ol.directory-list',
			baseApplication: 'SidebarTab',
		});
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Extend the logic used to render the inner application content
	 * @param {Object} data         The data used to render the inner template
	 * @return {Promise.<jQuery>}   A promise resolving to the constructed jQuery object
	 * @private
	 */
	async _renderInner(data) {
		let html = await super._renderInner(data);
		if (ui.sidebar && ui.sidebar.activeTab === this.options.id)
			html.addClass('active');
		if (this.popOut) html.removeClass('tab');
		return html;
	}

	/* -------------------------------------------- */

	/**
	 * When re-rendering the sidebar tab, also render its pop-out version if it exists
	 */
	async _render(...args) {
		if (this.options.popOut) this.position.height = 'auto';
		await super._render(...args);
		if (this._popout) this._popout.render();
		return this;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Activate this SidebarTab, switching focus to it
	 */
	activate() {
		ui.sidebar.activateTab(this.tabName);
	}

	/* -------------------------------------------- */

	/**
	 * Only close the pop-out version of the sidebar tab
	 * @return {boolean}
	 */
	async close() {
		if (this.popOut) {
			this._original._popout = null;
			return super.close();
		}
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Render the SidebarTab as a pop-out container
	 */
	renderPopout() {
		const pop = new this.constructor({
			id: this.options.id + '-popout',
			classes: ['sidebar-popout'],
			popOut: true,
			tabName: this.tabName,
			original: this,
		});
		pop.render(true);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Actor Directory HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Remember the current scrolling position
		if (this.options.scrollContainer) {
			const scroll = html[0].querySelector(this.options.scrollContainer);
			scroll.addEventListener(
				'scroll',
				ev => (this._scrollTop = ev.target.scrollTop),
				{ passive: true }
			);
			if (this._scrollTop !== null) scroll.scrollTop = this._scrollTop;
		}
	}
}

/**
 * A shared pattern for the sidebar directory which Actors, Items, and Scenes all use
 * @extends {SidebarTab}
 */
class SidebarDirectory extends SidebarTab {
	constructor(options) {
		super(options);
		this.constructor.collection.apps.push(this);

		/**
		 * References to the set of Entities which are displayed in the Sidebar
		 * @type {Array}
		 */
		this.entities = null;

		/**
		 * Reference the set of Folders which exist in this Sidebar
		 * @type {Array}
		 */
		this.folders = null;

		/**
		 * The search string currently being filtered for
		 * @type {String}
		 */
		this.searchString = null;

		/**
		 * The timestamp of the previous search character entry
		 * @type {Number}
		 * @private
		 */
		this._searchTime = 0;

		// Initialize sidebar content
		this.initialize();
	}

	/* -------------------------------------------- */
	/*  Initialization Helpers
	/* -------------------------------------------- */

	initialize() {
		// Assign Folders
		this.folders = game.folders.entities.filter(
			f => f.type === this.constructor.entity
		);

		// Assign Entities
		this.entities = this.constructor.collection.entities.filter(
			e => e.visible
		);

		// Build Tree
		const sortMode = 'n';
		this.tree = this.constructor.setupFolders(
			this.folders,
			this.entities,
			sortMode
		);
	}

	/* -------------------------------------------- */

	/**
	 * Given an entity type and a list of entities, set up the folder tree for that entity
	 * @param {Array} folders     The Array of Folder objects to organize
	 * @param {Array} entities    The Array of Entity objects to organize
	 * @param {String} sortMode   How should entities or Folders be sorted? (a)lphabetic or (n)umeric
	 * @return {Object}           A tree structure containing the folders and entities
	 */
	static setupFolders(folders, entities, sortMode = 'n') {
		entities = entities.filter(a => a.visible);
		let children = [{ _id: null }];
		const depths = [];
		const assigned = new Set();

		// First sort both Entities and Folders
		const sortCompare =
			sortMode === 'n'
				? (a, b) => a.data.sort - b.data.sort
				: (a, b) => a.name.localeCompare(b.name);
		folders.sort(sortCompare);
		entities.sort(sortCompare);

		// Iterate parent levels
		for (let i = 0; i < CONST.FOLDER_MAX_DEPTH; i++) {
			let depth = [];
			for (let folder of children) {
				let [f, c, e] = this._populate(folder, folders, entities);
				depth = depth.concat(c);
				folders = f;
				entities = e;
				assigned.add(folder._id);
			}
			depths[i] = depth;
			children = depth;
		}

		// If there are remaining folders beyond the maximum allowable depth assign them to the root level
		const unassigned = folders.filter(f => !assigned.has(f._id));
		unassigned.forEach(f => this._populate(f, folders, entities));
		depths[0] = depths[0].concat(unassigned);

		// Filter all folders for visibility
		for (let i = CONST.FOLDER_MAX_DEPTH - 1; i >= 0; i--) {
			for (let f of depths[i]) {
				f.children =
					f.children instanceof Array
						? f.children.filter(c => c.displayed)
						: [];
				f.displayed = f.displayed || f.children.length > 0;
			}
			depths[i] = depths[i].filter(f => f.displayed);
		}

		// Flag folder depth
		for (let [i, folders] of depths.entries()) {
			folders.forEach(f => (f.depth = i + 1));
		}

		// Return the root level contents of folders and entities
		return {
			root: true,
			content: entities,
			children: depths[0],
		};
	}

	/* -------------------------------------------- */

	/**
	 * Populate a single parent folder with child folders and content
	 * This method is called recursively when building the folder tree
	 * @private
	 */
	static _populate(parent, folders, entities) {
		// Partition folders into children and pending
		let [pending, children] = folders.partition(
			f => f.data.parent === parent._id
		);
		parent.children = children;

		// For each child, assign a reference to its parent folder and populate content
		for (let c of children) {
			c._parent = parent;

			// Allocate content
			let content;
			[entities, content] = entities.partition(
				e => e.data.folder === c._id
			);
			c.content = content;

			// Propagate visibility
			c.expanded = game.folders._expanded[c._id];
			c.displayed = game.user.isGM || content.length > 0;
		}
		return [pending, children, entities];
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by this Application
	 */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: `${this.entityLower}s`,
			template: `templates/sidebar/${this.entityLower}-directory.html`,
			title: `${this.entity}s Directory`,
			dragItemSelector: '.directory-item',
			renderUpdateKeys: ['name', 'img', 'permission', 'sort', 'folder'],
			canDrag: game.user.isGM,
		});
	}

	/* -------------------------------------------- */

	static get entity() {
		throw 'Subclass must define entity.';
	}

	static get entityLower() {
		return this.entity.toLowerCase();
	}

	static get collection() {
		throw 'Subclass must define collection.';
	}

	/* -------------------------------------------- */
	/*  Application Rendering
	/* -------------------------------------------- */

	/**
	 * When rendering a SidebarDirectory, check the render context to rebuild the tree structure if needed
	 */
	render(force, context = {}) {
		const { renderContext, renderData } = context;
		const e = this.constructor.entity;
		const events = [
			'create' + e,
			'createMany' + e,
			'update' + e,
			'updateMany' + e,
			'delete' + e,
			'deleteMany' + e,
			'createFolder',
			'updateFolder',
			'deleteFolder',
		];
		if (events.includes(renderContext)) {
			if (renderContext === 'update' + e) {
				const updateKeys = this.options.renderUpdateKeys;
				if (!updateKeys.some(k => renderData.hasOwnProperty(k))) return;
			}
			this.initialize();
		}
		return super.render(force, context);
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data used to render the ActorList application
	 * @return {Object}
	 */
	getData() {
		return {
			user: game.user,
			tree: this.tree,
			search: this.searchString,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Perform a search of the SidebarDirectory using a filtering string
	 * Only display matching entities and their parent folders within the sidebar
	 * @private
	 */
	search(searchString) {
		const isSearch = !!searchString;
		let entityIds = null;
		let folderIds = null;

		// Match entities and folders
		if (isSearch) {
			let rgx = new RegExp(searchString, 'i');

			// Match entity names
			const matched = this.entities.filter(e => rgx.test(e.name));
			entityIds = new Set(matched.map(e => e._id));

			// Match folder tree
			folderIds = new Set(
				matched.filter(e => e.data.folder).map(e => e.data.folder)
			);
			const includeFolders = fids => {
				const folders = this.folders.filter(f => fids.has(f._id));
				const pids = new Set(
					folders.filter(f => f.data.parent).map(f => f.data.parent)
				);
				if (pids.size) {
					pids.forEach(p => folderIds.add(p));
					includeFolders(pids);
				}
			};
			includeFolders(folderIds);
		}

		// Show or hide entities
		this.element.find('li.entity').each((i, el) => {
			el.style.display =
				!isSearch || entityIds.has(el.dataset.entityId)
					? 'flex'
					: 'none';
		});

		// Show or hide folders
		this.element.find('li.folder').each((i, el) => {
			let li = $(el);
			let match = isSearch && folderIds.has(el.dataset.folderId);
			el.style.display = !isSearch || match ? 'flex' : 'none';

			// Always show a matched folder
			if (isSearch && match) li.removeClass('collapsed');
			// Otherwise, show the tracked expanded state
			else {
				let expanded = game.folders._expanded[el.dataset.folderId];
				if (expanded) li.removeClass('collapsed');
				else li.addClass('collapsed');
			}
		});

		// Assign the search string
		this.searchString = searchString;
		this.element.find('input[name="search"]').val(searchString);
	}

	/* -------------------------------------------- */

	/**
	 * Collapse all subfolders in this directory
	 */
	collapseAll() {
		this.element.find('li.folder').addClass('collapsed');
		for (let f of this.folders) {
			game.folders._expanded[f._id] = false;
		}
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Actor Directory HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Maybe attach drag start listeners
		if (this.options.canDrag) {
			html.find(this.options.dragItemSelector).each((i, li) => {
				li.setAttribute('draggable', true);
				li.addEventListener(
					'dragstart',
					ev => this._onDragStart(ev),
					false
				);
			});
		}

		// GM only can perform other admin actions
		if (game.user.isGM) {
			html[0].ondragover = this._onDragOver.bind(this);
			html[0].ondrop = this._onDrop.bind(this);

			// Create new entity
			html.find('.create-entity').click(ev => this._onCreate(ev));

			// Create new folder - eliminate buttons below a certain depth
			html.find('.folder .folder .folder .create-folder').remove();
			html.find('.create-folder').click(ev => this._onCreateFolder(ev));
		}

		// Directory click events
		html.find('.entity-name').click(this._onClickEntityName.bind(this));
		html.find('.folder-header').click(this._toggleFolder.bind(this));
		html.find('.collapse-all').click(this.collapseAll.bind(this));

		// Entity context menu
		this._contextMenu(html);

		// Search filtering
		html.find('input[name="search"]').keyup(this._onSearchKeyup.bind(this));
	}

	/* -------------------------------------------- */

	/**
	 * Handle clicking on an Entity name in the Sidebar directory
	 * @param {Event} event   The originating click event
	 * @private
	 */
	_onClickEntityName(event) {
		event.preventDefault();
		const element = event.currentTarget;
		const entityId = element.parentElement.dataset.entityId;
		const entity = this.constructor.collection.get(entityId);
		const sheet = entity.sheet;
		if (sheet._minimized) return sheet.maximize();
		else return sheet.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle new creation request
	 * @param event
	 * @private
	 */
	async _onCreate(event) {
		// Do not allow the creation event to bubble to other listeners
		event.preventDefault();
		event.stopPropagation();

		// Collect data
		const ent = this.constructor.entity,
			cls = CONFIG[ent].entityClass,
			types = game.system.entityTypes[ent];

		// Setup entity data
		const createData = {
			name: `New ${ent}`,
			type: types[0],
			folder: event.currentTarget.getAttribute('data-folder'),
		};

		// Only a single type
		if (types.length <= 1) {
			createData.types = types[0];
			return cls.create(createData);
		}

		// Render the entity creation form
		let templateData = {
				upper: ent,
				lower: ent.toLowerCase(),
				types: types,
			},
			dlg = await renderTemplate(
				`templates/sidebar/entity-create.html`,
				templateData
			);

		// Render the confirmation dialog window
		new Dialog({
			title: `Create New ${ent}`,
			content: dlg,
			buttons: {
				create: {
					icon: '<i class="fas fa-check"></i>',
					label: `Create ${ent}`,
					callback: dlg => {
						mergeObject(
							createData,
							validateForm(dlg[0].children[0])
						);
						cls.create(createData);
					},
				},
			},
			default: 'create',
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle events to create a new Actors folder through a creation dialog
	 * @private
	 */
	_onCreateFolder(event) {
		event.preventDefault();
		event.stopPropagation();
		let button = $(event.currentTarget),
			parent = button.attr('data-parent-folder');
		Folder.createDialog({
			parent: parent ? parent : null,
			type: this.constructor.entity,
		});
	}

	/* -------------------------------------------- */

	_toggleFolder(event) {
		let folder = $(event.currentTarget.parentElement);
		let collapsed = folder.hasClass('collapsed');
		game.folders._expanded[folder.attr('data-folder-id')] = collapsed;

		// Expand
		if (collapsed) folder.removeClass('collapsed');
		// Collapse
		else {
			folder.addClass('collapsed');
			const subs = folder.find('.folder').addClass('collapsed');
			subs.each(
				(i, f) => (game.folders._expanded[f.dataset.folderId] = false)
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Begin a a data transfer drag event with default handling
	 * @private
	 */
	_onDragStart(event) {
		event.stopPropagation();
		let li = event.currentTarget.closest('li.directory-item');
		const dragData = li.classList.contains('folder')
			? {
					type: 'Folder',
					id: li.dataset.folderId,
					entity: this.constructor.entity,
			  }
			: { type: this.constructor.entity, id: li.dataset.entityId };
		event.dataTransfer.setData('text/plain', JSON.stringify(dragData));
		this._dragType = dragData.type;
	}

	/* -------------------------------------------- */

	/**
	 * Allow data transfer events to be dragged over this as a drop zone
	 */
	_onDragOver(event) {
		event.preventDefault();
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Handle data being dropped onto the sidebar
	 * @private
	 */
	_onDrop(event) {
		event.preventDefault();
		const cls = this.constructor.entity;

		// Try to extract the data
		let data;
		try {
			data = JSON.parse(event.dataTransfer.getData('text/plain'));
		} catch (err) {
			return false;
		}
		let correctType =
			data.type === cls ||
			(data.type === 'Folder' && data.entity === cls);
		if (!correctType) return false;

		// Call the drop handler
		this._handleDropData(event, data);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a keyup press in the Search filter bar of the directory sidebar
	 * @param {Event} event
	 * @private
	 */
	_onSearchKeyup(event) {
		event.preventDefault();
		const input = event.target;
		this._searchTime = Date.now();
		setTimeout(() => {
			let dt = Date.now() - this._searchTime;
			if (dt > 250) this.search(input.value);
		}, 251);
	}

	/* -------------------------------------------- */

	/**
	 * Define the behavior of the sidebar tab when it received a dropped data object
	 * @param {Event} event   The original drop event
	 * @param {Object} data   The data being dropped
	 * @private
	 */
	_handleDropData(event, data) {
		// Determine the drop target
		const collection = this.constructor.collection;
		const dt = event.target.closest(this.options.dragItemSelector) || null;
		const isFolder = dt && dt.classList.contains('folder');
		const targetId = dt
			? isFolder
				? dt.dataset.folderId
				: dt.dataset.entityId
			: null;

		// Determine the closest folder ID
		const closestFolder = dt ? dt.closest('.folder') : null;
		const closestFolderId = closestFolder
			? closestFolder.dataset.folderId
			: null;

		// Case 1 - New data is explicitly provided
		if (data.data) {
			const createData = mergeObject(data.data, {
				folder: closestFolderId,
			});
			if (collection.get(createData._id))
				throw new Error('An Entity with this _id already exists!');
			return collection.object.create(createData);
		}

		// Case 2 - Data to import from a Compendium pack
		else if (data.pack) {
			return this.constructor.collection.importFromCollection(
				data.pack,
				data.id,
				{ folder: closestFolderId }
			);
		}

		// Case 3 - Sort a Folder
		if (data.type === 'Folder') {
			const folder = game.folders.get(data.id);
			const sortData = { sortKey: 'sort', sortBefore: true };
			if (isFolder && dt.classList.contains('collapsed')) {
				// Dropped on a collapsed Folder
				sortData.target = game.folders.get(targetId);
				sortData.parentId = sortData.target.data.parent;
			} else if (isFolder) {
				// Dropped on an expanded Folder
				if (Number(dt.dataset.folderDepth) === CONST.FOLDER_MAX_DEPTH)
					return; // Prevent going beyond max depth
				sortData.target = null;
				sortData.parentId = targetId;
				if (data.id === targetId) return; // Don't drop folders on yourself
			} else {
				// Dropped on an Entity
				sortData.parentId = closestFolderId;
				sortData.target =
					closestFolder &&
					closestFolder.classList.contains('collapsed')
						? closestFolder
						: null;
			}

			// Determine Folder siblings
			sortData.siblings = game.folders.entities.filter(f => {
				return (
					f.data.parent === sortData.parentId &&
					f.data.type === folder.data.type &&
					f !== folder
				);
			});
			sortData.updateData = { parent: sortData.parentId };
			folder.sortRelative(sortData);
		}

		// Case 4 - Sort an Entity
		else {
			const entity = collection.get(data.id);
			const isEntity = dt && dt.classList.contains('entity');
			const sortData = { sortKey: 'sort', sortBefore: true };

			// Handle different targets
			if (isEntity) {
				// Drop on an Entity
				sortData.target = collection.get(targetId);
				sortData.folderId = sortData.target.data.folder;
			} else {
				// Drop on a Folder or null
				sortData.target = null;
				sortData.folderId = closestFolderId;
			}

			// Determine Entity siblings and updateData
			sortData.siblings = collection.entities.filter(e => {
				return e.data.folder === sortData.folderId && e._id !== data.id;
			});
			sortData.updateData = { folder: sortData.folderId };
			entity.sortRelative(sortData);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Default folder context actions
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		// Folder Context
		const folderOptions = this._getFolderContextOptions();
		Hooks.call(
			`get${this.constructor.name}FolderContext`,
			html,
			folderOptions
		);
		if (folderOptions)
			new ContextMenu(html, '.folder .folder-header', folderOptions);

		// Entity Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(
			`get${this.constructor.name}EntryContext`,
			html,
			entryOptions
		);
		if (entryOptions) new ContextMenu(html, '.entity', entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getFolderContextOptions() {
		return [
			{
				name: 'FOLDER.Edit',
				icon: '<i class="fas fa-edit"></i>',
				condition: game.user.isGM,
				callback: header => {
					const folder = game.folders.get(
						header.parent().data('folderId')
					);
					new FolderConfig(folder).render(true);
				},
			},
			{
				name: 'FOLDER.Remove',
				icon: '<i class="fas fa-trash"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data('folderId'));
					Dialog.confirm(
						{
							title: `${game.i18n.localize('FOLDER.Remove')} ${
								folder.name
							}`,
							content: game.i18n.localize('FOLDER.RemoveConfirm'),
							yes: () =>
								folder.delete({
									deleteSubfolders: false,
									deleteContents: false,
								}),
						},
						{
							top: Math.min(
								li[0].offsetTop,
								window.innerHeight - 350
							),
							left: window.innerWidth - 720,
							width: 400,
						}
					);
				},
			},
			{
				name: 'FOLDER.Delete',
				icon: '<i class="fas fa-dumpster"></i>',
				condition: game.user.isGM,
				callback: header => {
					const li = header.parent();
					const folder = game.folders.get(li.data('folderId'));
					Dialog.confirm(
						{
							title: `${game.i18n.localize('FOLDER.Delete')} ${
								folder.name
							}`,
							content: game.i18n.localize('FOLDER.DeleteConfirm'),
							yes: () =>
								folder.delete({
									deleteSubfolders: true,
									deleteContents: true,
								}),
						},
						{
							top: Math.min(
								li[0].offsetTop,
								window.innerHeight - 350
							),
							left: window.innerWidth - 720,
							width: 400,
						}
					);
				},
			},
		];
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Entities in a SidebarDirectory
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: 'FOLDER.Clear',
				icon: '<i class="fas fa-folder"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					return game.user.isGM && !!entity.data.folder;
				},
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					entity.update({ folder: null });
				},
			},
			{
				name: 'SIDEBAR.Delete',
				icon: '<i class="fas fa-trash"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					Dialog.confirm(
						{
							title: `${game.i18n.localize('SIDEBAR.Delete')} ${
								entity.name
							}`,
							content: game.i18n.localize(
								'SIDEBAR.DeleteConfirm'
							),
							yes: entity.delete.bind(entity),
						},
						{
							top: Math.min(
								li[0].offsetTop,
								window.innerHeight - 350
							),
							left: window.innerWidth - 720,
						}
					);
				},
			},
			{
				name: 'SIDEBAR.Duplicate',
				icon: '<i class="far fa-copy"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					return entity.clone(
						{ name: `${entity.name} (Copy)` },
						{ displaySheet: false }
					);
				},
			},
			{
				name: 'SIDEBAR.Permissions',
				icon: '<i class="fas fa-lock"></i>',
				condition: () => game.user.isGM,
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					new PermissionControl(entity, {
						top: Math.min(
							li[0].offsetTop,
							window.innerHeight - 350
						),
						left: window.innerWidth - 720,
						width: 400,
					}).render(true);
				},
			},
			{
				name: 'SIDEBAR.Export',
				icon: '<i class="fas fa-file-export"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					return entity.owner;
				},
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					entity.exportToJSON();
				},
			},
			{
				name: 'SIDEBAR.Import',
				icon: '<i class="fas fa-file-import"></i>',
				condition: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					return entity.owner;
				},
				callback: li => {
					const entity = this.constructor.collection.get(
						li.data('entityId')
					);
					entity.importFromJSONDialog();
				},
			},
		];
	}
}

/**
 * The Collection of Actor entities.
 * @extends {Collection}
 *
 * @see {@link Actor} The Actor entity.
 * @see {@link ActorDirectory} All Actors which exist in the world are rendered within the ActorDirectory sidebar tab.
 *
 * @example <caption>Retrieve an existing Actor by its id</caption>
 * let actor = game.actors.get(actorId);
 */
class Actors extends Collection {
	constructor(...args) {
		super(...args);

		/**
		 * A mapping of synthetic Token Actors which are currently active within the viewed Scene.
		 * Each Actor is referenced by the Token.id.
		 * @type {Object}
		 */
		this.tokens = {};
	}

	/* -------------------------------------------- */

	/** @override */
	get object() {
		return CONFIG.Actor.entityClass;
	}

	/* -------------------------------------------- */
	/*  Sheet Registration Methods                  */
	/* -------------------------------------------- */

	/**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 * @static
	 *
	 * @example <caption>Register a new ActorSheet subclass for use with certain Actor types.</caption>
	 * Actors.registerSheet("dnd5e", ActorSheet5eCharacter, { types: ["character"], makeDefault: true });
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Actor, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 * @static
	 *
	 * @example <caption>Deregister the default ActorSheet subclass to replace it with others.</caption>
	 * Actors.unregisterSheet("core", ActorSheet);
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Actor, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {Array}
	 */
	static get registeredSheets() {
		return Object.values(CONFIG.Item.sheetClasses).reduce(
			(arr, classes) => {
				return arr.concat(Object.values(classes).map(c => c.cls));
			},
			[]
		);
	}
}

/* -------------------------------------------- */

/**
 * The Actor Entity which represents the protagonists, characters, enemies, and more that inhabit and take actions
 * within the World.
 * @extends {Entity}
 *
 * @see {@link Actors} Each Actor belongs to the Actors collection.
 * @see {@link ActorSheet} Each Actor is edited using the ActorSheet application or a subclass thereof.
 * @see {@link ActorDirectory} All Actors which exist in the world are rendered within the ActorDirectory sidebar tab.
 *
 *
 * @example <caption>Create a new Actor</caption>
 * let actor = await Actor.create({
 *   name: "New Test Actor",
 *   type: "character",
 *   img: "artwork/character-profile.jpg",
 *   folder: folder.data._id,
 *   sort: 12000,
 *   data: {},
 *   token: {},
 *   items: [],
 *   flags: {}
 * });
 *
 * @example <caption>Retrieve an existing Actor</caption>
 * let actor = game.actors.get(actorId);
 */
class Actor extends Entity {
	constructor(...args) {
		super(...args);

		/**
		 * A reference to a placed Token which creates a synthetic Actor
		 * @type {Token}
		 */
		this.token = this.options.token || null;

		/**
		 * Construct the Array of Item instances for the Actor
		 * Items are prepared by the Actor.prepareEmbeddedEntities() method
		 * @type {Array.<Item>}
		 */
		this.items = this.items || [];

		/**
		 * Cache an Array of allowed Token images if using a wildcard path
		 * @type {Array}
		 * @private
		 */
		this._tokenImages = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get config() {
		return {
			baseEntity: Actor,
			collection: game.actors,
			embeddedEntities: { OwnedItem: 'items' },
		};
	}

	/* -------------------------------------------- */

	/** @override */
	prepareData() {
		super.prepareData();
		if (!this.data.img) this.data.img = CONST.DEFAULT_TOKEN;
	}

	/* -------------------------------------------- */

	/** @override */
	prepareEmbeddedEntities() {
		this.items = this.data.items.map(i => Item.createOwned(i, this));
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenient reference to the file path of the Actor's profile image
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}

	/* -------------------------------------------- */

	/**
	 * A boolean flag for whether this Actor is a player-owned character.
	 * True if any User who is not a GM has ownership rights over the Actor entity.
	 * @type {boolean}
	 */
	get isPC() {
		const nonGM = game.users.entities.filter(u => !u.isGM);
		return nonGM.some(u => {
			if (
				this.data.permission['default'] >=
				CONST.ENTITY_PERMISSIONS['OWNER']
			)
				return true;
			return (
				this.data.permission[u._id] >= CONST.ENTITY_PERMISSIONS['OWNER']
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Test whether an Actor entity is a synthetic representation of a Token (if true) or a full Entity (if false)
	 * @type {boolean}
	 */
	get isToken() {
		if (!this.token) return false;
		return !this.token.data.actorLink;
	}

	/* -------------------------------------------- */

	/**
	 * Create a synthetic Actor using a provided Token instance
	 * If the Token data is linked, return the true Actor entity
	 * If the Token data is not linked, create a synthetic Actor using the Token's actorData override
	 * @param {Token} token
	 * @return {Actor}
	 */
	static fromToken(token) {
		let actor = game.actors.get(token.data.actorId);
		if (!actor) return null;
		if (!token.data._id) return actor;
		if (!token.data.actorLink)
			actor = actor.constructor.createTokenActor(actor, token);
		return actor;
	}

	/* -------------------------------------------- */

	/**
	 * Create a synthetic Token Actor instance which is used in place of an actual Actor.
	 * Cache the result in Actors.tokens.
	 * @param {Actor} baseActor
	 * @param {Token} token
	 * @return {Actor}
	 */
	static createTokenActor(baseActor, token) {
		let actor = this.collection.tokens[token.id];
		if (actor) return actor;
		const actorData = mergeObject(baseActor.data, token.data.actorData, {
			inplace: false,
		});
		actor = new this(actorData, { token: token });
		return (this.collection.tokens[token.id] = actor);
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve an Array of active tokens which represent this Actor in the current canvas Scene.
	 * If the canvas is not currently active, or there are no linked actors, the returned Array will be empty.
	 *
	 * @param [linked] {Boolean}  Only return tokens which are linked to the Actor. Default (false) is to return all
	 *                            tokens even those which are not linked.
	 *
	 * @return {Array}            An array of tokens in the current Scene which reference this Actor.
	 */
	getActiveTokens(linked = false) {
		if (!canvas.tokens) return [];
		return canvas.tokens.placeables.filter(t => {
			if (!(t instanceof Token)) return false;
			if (linked) return t.data.actorLink && t.data.actorId === this._id;
			return t.data.actorId === this._id;
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Token images which could represent this Actor
	 * @return {Promise}
	 */
	async getTokenImages() {
		if (!this.data.token.randomImg) return [this.data.token.img];
		if (this._tokenImages) return this._tokenImages;
		return new Promise((resolve, reject) => {
			game.socket.emit(
				'getFiles',
				'user',
				this.data.token.img,
				{ wildcard: true },
				images => {
					if (images.error) reject(images.error);
					resolve(images.files);
				}
			);
		}).then(images => (this._tokenImages = images));
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers
  /* -------------------------------------------- */

	/** @override */
	async update(data, options = {}) {
		if (this.isToken)
			return ActorTokenHelpers.prototype.update.bind(this)(data, options);
		if (
			data.img &&
			!hasProperty(data, 'token.img') &&
			this.data.token.img === CONST.DEFAULT_TOKEN
		) {
			setProperty(data, 'token.img', data.img);
		}
		return super.update(data, options);
	}

	/* -------------------------------------------- */

	/** @override */
	async delete(options) {
		if (this.isToken) return this.token.delete(options);
		return super.delete(options);
	}

	/* -------------------------------------------- */

	/** @override */
	async createEmbeddedEntity(...args) {
		if (this.isToken)
			return ActorTokenHelpers.prototype.createEmbeddedEntity.call(
				this,
				...args
			);
		return super.createEmbeddedEntity(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	async updateEmbeddedEntity(...args) {
		if (this.isToken)
			return ActorTokenHelpers.prototype.updateEmbeddedEntity.call(
				this,
				...args
			);
		return super.updateEmbeddedEntity(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	async deleteEmbeddedEntity(...args) {
		if (this.isToken)
			return ActorTokenHelpers.prototype.deleteEmbeddedEntity.call(
				this,
				...args
			);
		return super.deleteEmbeddedEntity(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// Get the changed attributes
		const keys = Object.keys(data).filter(k => k !== '_id');
		const changed = new Set(keys);

		// If the items array was updated, we need to re-build the owned item entities
		if (changed.has('items')) this.prepareEmbeddedEntities();

		// Additional options only apply to Actors which are not synthetic Tokens
		if (this.isToken) return;

		// Update default token data
		const token = this.data.token;
		if (
			data.img &&
			data.img !== token.img &&
			(!token.img || token.img === CONST.DEFAULT_TOKEN)
		) {
			data['token.img'] = data.img;
		}
		if (
			data.name &&
			data.name !== token.name &&
			(!token.name || token.name === 'New Actor')
		) {
			data['token.name'] = data.name;
		}

		// If the prototype token was changed, expire any cached token images
		if (changed.has('token')) this._tokenImages = null;

		// Update Token representations of this Actor
		this.getActiveTokens().forEach(token =>
			token._onUpdateBaseActor(this.data, data)
		);

		// If ownership changed for an actor with an active token, re-initialize sight
		if (changed.has('permission')) {
			if (this.getActiveTokens().length) {
				canvas.tokens.releaseAll();
				canvas.tokens.cycleTokens(1, true);
				canvas.sight.initialize();
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onCreateEmbeddedEntity({ embeddedName, created, options, userId }) {
		const item = Item.createOwned(created, this);
		this.items.push(item);
		if (options.displaySheet && userId === game.user._id) {
			item.sheet.render(true, {
				renderContext: 'create' + embeddedName,
				renderData: created,
			});
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdateEmbeddedEntity({ embeddedName, data, options, userId }) {
		const item = this.getOwnedItem(data._id);
		item.prepareData();
		item.sheet.render(false, {
			renderContext: 'update' + embeddedName,
			renderData: data,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	_onDeleteEmbeddedEntity({ embeddedName, deleted, options, userId }) {
		const item = this.items.findSplice(i => i.data._id === deleted._id);
		item.sheet.close({ submit: false });
	}

	/* -------------------------------------------- */
	/*  Owned Item Management                       */
	/* -------------------------------------------- */

	/**
	 * Import a new owned Item from a compendium collection
	 * The imported Item is then added to the Actor as an owned item.
	 *
	 * @param collection {String}     The name of the pack from which to import
	 * @param entryId {String}        The ID of the compendium entry to import
	 */
	importItemFromCollection(collection, entryId) {
		const pack = game.packs.find(p => p.collection === collection);
		if (pack.metadata.entity !== 'Item') return;
		return pack.getEntity(entryId).then(ent => {
			console.log(
				`${vtt} | Importing Item ${ent.name} from ${collection}`
			);
			delete ent.data._id;
			return this.createOwnedItem(ent.data);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get an Item instance corresponding to the Owned Item with a given id
	 * @param {string} itemId   The OwnedItem id to retrieve
	 * @return {Item}           An Item instance representing the Owned Item within the Actor entity
	 */
	getOwnedItem(itemId) {
		return this.items.find(i => i.id === itemId);
	}

	/* -------------------------------------------- */

	/**
	 * Create a new item owned by this Actor. This redirects its arguments to the createEmbeddedEntity method.
	 * @see {Entity#createEmbeddedEntity}
	 *
	 * @param {Object} itemData     Data for the newly owned item
	 * @param {Object} options      Item creation options
	 * @param {boolean} options.displaySheet Render the Item sheet for the newly created item data
	 * @return {Promise.<Object>}   A Promise resolving to the created Owned Item data
	 */
	async createOwnedItem(itemData, options = {}) {
		return this.createEmbeddedEntity('OwnedItem', itemData, options);
	}

	/* -------------------------------------------- */

	/**
	 * Update an owned item using provided new data. This redirects its arguments to the updateEmbeddedEntity method.
	 * @see {Entity#updateEmbeddedEntity}
	 *
	 * @param {Object} itemData     Data for the item to update
	 * @param {Object} options      Item update options
	 * @return {Promise.<Object>}   A Promise resolving to the updated Owned Item data
	 */
	async updateOwnedItem(itemData, options = {}) {
		return this.updateEmbeddedEntity('OwnedItem', itemData, options);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity#createEmbeddedEntity}
	 * @deprecated since 0.4.4 in favor of Entity.updateManyEmbeddedEntities()
	 */
	async updateManyOwnedItems(data, options = {}) {
		console.warn(
			'You are using Actor.updateManyOwnedItems() which is deprecated in favor of Actor.updateManyEmbeddedEntities()'
		);
		return this.updateManyEmbeddedEntities('OwnedItem', data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Delete an owned item by its id. This redirects its arguments to the deleteEmbeddedEntity method.
	 * @see {Entity#deleteEmbeddedEntity}
	 *
	 * @param {string} itemId       The ID of the item to delete
	 * @param {Object} options      Item deletion options
	 * @return {Promise.<Object>}   A Promise resolving to the deleted Owned Item data
	 */
	async deleteOwnedItem(itemId, options = {}) {
		return this.deleteEmbeddedEntity('OwnedItem', itemId, options);
	}
}

CONFIG.Actor.entityClass = Actor;
CONFIG.Actor.collection = Actors;
Actors.registerSheet('core', ActorSheet);

/* -------------------------------------------- */

/**
 * A collection of replacement functions which are used in Actor socket workflows to replace default behaviors.
 * @ignore
 */
class ActorTokenHelpers {
	/** @override */
	async update(data, options = {}) {
		const token = this.token;
		const changed = diffObject(this.data, expandObject(data));
		if (isObjectEmpty(changed)) return this;
		return token.update({ actorData: changed }, options);
	}

	/* -------------------------------------------- */

	/** @override */
	async createEmbeddedEntity(embeddedName, data, options = {}) {
		if (options.temporary) return null;
		const item = await Entity.prototype.createEmbeddedEntity.call(
			this,
			'OwnedItem',
			data,
			{ temporary: true }
		);
		const items = duplicate(this.data.items).concat([item]);
		return this.token.update({ 'actorData.items': items }, options);
	}

	/* -------------------------------------------- */

	/** @override */
	updateEmbeddedEntity(embeddedName, data, options = {}) {
		if (embeddedName !== 'OwnedItem') return;
		const items = duplicate(this.data.items);
		const item = items.find(i => i._id === data._id);
		if (item) mergeObject(item, data);
		return this.token.update({ 'actorData.items': items }, options);
	}

	/* -------------------------------------------- */

	/** @override */
	async deleteEmbeddedEntity(embeddedName, id, options = {}) {
		const items = duplicate(this.data.items);
		items.findSplice(i => i._id === id);
		return this.token.update({ 'actorData.items': items }, options);
	}
}
/**
 * The Collection of Combat entities
 * @type {Collection}
 */
class CombatEncounters extends Collection {
	constructor(...args) {
		super(...args);

		/**
		 * A reference to the world combat configuration settings
		 * @type {Object}
		 */
		this.settings = game.settings.get('core', Combat.CONFIG_SETTING);
	}

	/* -------------------------------------------- */

	/** @override */
	get object() {
		return Combat;
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Combat instances which apply to the current canvas scene
	 * @type {Array}
	 */
	get combats() {
		let scene = game.scenes.active;
		if (!scene) return [];
		return this.entities.filter(c => c.data.scene === scene._id);
	}

	/* -------------------------------------------- */

	/**
	 * The currently active Combat instance
	 * @return {Combat}
	 */
	get active() {
		return this.combats.find(c => c.data.active);
	}

	/* -------------------------------------------- */

	/** @override */
	static get instance() {
		return game.combats;
	}

	/* -------------------------------------------- */

	/**
	 * When a Token is deleted, remove it as a combatant from any combat encounters which included the Token
	 * @param {string} sceneId
	 * @param {string} tokenId
	 * @private
	 */
	async _onDeleteToken(sceneId, tokenId) {
		const combats = game.combats.entities.filter(
			c => (c.sceneId = sceneId)
		);
		for (let c of combats) {
			let combatant = c.getCombatantByToken(tokenId);
			if (combatant) await c.deleteCombatant(combatant.id);
		}
	}
}

/* -------------------------------------------- */
/*  Combat Entity
/* -------------------------------------------- */

/**
 * The Combat Entity defines a particular combat encounter which can occur within the game session
 * Combat instances belong to the CombatEncounters collection
 * @type {Entity}
 */
class Combat extends Entity {
	constructor(...args) {
		super(...args);

		/**
		 * Track the sorted turn order of this combat encounter
		 * @type {Array}
		 */
		this.turns;

		/**
		 * Record the current round, turn, and tokenId to understand changes in the encounter state
		 * @type {Object}
		 * @private
		 */
		this.current = {
			round: null,
			turn: null,
			tokenId: null,
		};

		/**
		 * Track the previous round, turn, and tokenId to understand changes in the encounter state
		 * @type {Object}
		 * @private
		 */
		this.previous = {
			round: null,
			turn: null,
			tokenId: null,
		};

		/**
		 * Track whether a sound notification is currently being played to avoid double-dipping
		 * @type {Boolean}
		 * @private
		 */
		this._soundPlaying = false;
	}

	/* -------------------------------------------- */

	/**
	 * Configure the attributes of the Folder Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {Collection} collection   The Collection class to which Entities of this type belong.
	 * @returns {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: Combat,
			collection: game.combats,
			embeddedEntities: { Combatant: 'combatants' },
		};
	}

	/* -------------------------------------------- */

	/**
	 * Prepare Embedded Entities which exist within the parent Combat.
	 * For example, in the case of an Actor, this method is responsible for preparing the Owned Items the Actor contains.
	 */
	prepareEmbeddedEntities() {
		this.turns = this.setupTurns();
	}

	/* -------------------------------------------- */

	/**
	 * Acquire the default dice formula which should be used to roll initiative for a particular combatant.
	 * Modules or systems could choose to override or extend this to accommodate special situations.
	 * @private
	 *
	 * @param {Object} combatant      Data for the specific combatant for whom to acquire an initiative formula. This
	 *                                is not used by default, but provided to give flexibility for modules and systems.
	 * @return {string}               The initiative formula to use for this combatant.
	 */
	_getInitiativeFormula(combatant) {
		return CONFIG.initiative.formula || game.system.data.initiative;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Array of combatant data within the Combat entity
	 * @type {Array.<Object>}
	 */
	get combatants() {
		return this.data.combatants;
	}

	/* -------------------------------------------- */

	/**
	 * Get the data object for the Combatant who has the current turn
	 * @type {Object}
	 */
	get combatant() {
		return this.turns[this.data.turn];
	}

	/* -------------------------------------------- */

	/**
	 * The numeric round of the Combat encounter
	 * @type {number}
	 */
	get round() {
		return this.data.round;
	}

	/* -------------------------------------------- */

	/**
	 * The numeric turn of the combat round in the Combat encounter
	 * @type {number}
	 */
	get turn() {
		return this.data.turn;
	}

	/* -------------------------------------------- */

	/**
	 * Get the Scene entity for this Combat encounter
	 * @return {Scene}
	 */
	get scene() {
		return game.scenes.get(this.data.scene);
	}

	/* -------------------------------------------- */

	/**
	 * Return the object of settings which modify the Combat Tracker behavior
	 * @return {Object}
	 */
	get settings() {
		return this.collection.settings;
	}

	/* -------------------------------------------- */

	/**
	 * Has this combat encounter been started?
	 * @type {Boolean}
	 */
	get started() {
		return this.turns.length > 0 && this.round > 0;
	}

	/* -------------------------------------------- */
	/*  Combat Control Methods                      */
	/* -------------------------------------------- */

	/**
	 * Set the current Combat encounter as active within the Scene
	 * @return {Promise.<Combat>}
	 */
	async activate() {
		let active = this.constructor.collection.active;
		if (active && active._id !== this._id) {
			await active.update({ active: false });
		}
		return this.update({ active: true });
	}

	/* -------------------------------------------- */

	/**
	 * Return the Array of combatants sorted into initiative order, breaking ties alphabetically by name
	 * @return {Array}
	 */
	setupTurns() {
		const scene = game.scenes.get(this.data.scene);
		const players = game.users.players;

		// Populate additional data for each combatant
		let turns = this.data.combatants
			.map(c => {
				c.token = scene.getEmbeddedEntity('Token', c.tokenId);
				if (!c.token) return c;
				c.actor = Actor.fromToken(new Token(c.token, scene));
				c.players = c.actor
					? players.filter(u => c.actor.hasPerm(u, 'OWNER'))
					: [];
				c.owner = c.actor ? c.actor.owner : false;
				c.visible = c.owner || !c.hidden;
				return c;
			})
			.filter(c => c.token);

		// Sort turns into initiative order: (1) initiative, (2) name, (3) tokenId
		turns = turns.sort((a, b) => {
			let ci = (b.initiative || -9999) - (a.initiative || -9999);
			if (ci !== 0) return ci;
			let [an, bn] = [a.token.name || '', b.token.name || ''];
			let cn = an.localeCompare(bn);
			if (cn !== 0) return cn;
			return a.tokenId - b.tokenId;
		});

		// Ensure the current turn is bounded
		this.data.turn = Math.clamped(this.data.turn, 0, turns.length - 1);
		this.turns = turns;

		// When turns change, tracked resources also change
		if (ui.combat) ui.combat.updateTrackedResources();
		return this.turns;
	}

	/* -------------------------------------------- */

	/**
	 * Begin the combat encounter, advancing to round 1 and turn 1
	 * @return {Promise}
	 */
	async startCombat() {
		return this.update({ round: 1, turn: 0 });
	}

	/* -------------------------------------------- */

	/**
	 * Advance the combat to the next turn
	 * @return {Promise}
	 */
	async nextTurn() {
		let turn = this.turn;
		let skip = this.settings.skipDefeated;
		let next = null;

		// Determine the next turn number
		if (skip) {
			for (let [i, t] of this.turns.entries()) {
				if (i <= turn) continue;
				if (!t.defeated) {
					next = i;
					break;
				}
			}
		} else next = turn + 1;

		// Maybe advance the round instead
		if (this.round === 0 || next === null || next >= this.turns.length)
			return this.nextRound();
		return this.update({ turn: next });
	}

	/* -------------------------------------------- */

	/**
	 * Rewind the combat to the previous turn
	 * @return {Promise}
	 */
	async previousTurn() {
		if (this.turn === 0 && this.round === 0) return Promise.resolve();
		else if (this.turn === 0) return this.previousRound();
		return this.update({ turn: this.turn - 1 });
	}

	/* -------------------------------------------- */

	/**
	 * Advance the combat to the next round
	 * @return {Promise}
	 */
	async nextRound() {
		return this.update({ round: this.round + 1, turn: 0 });
	}

	/* -------------------------------------------- */

	/**
	 * Rewind the combat to the previous round
	 * @return {Promise}
	 */
	async previousRound() {
		let turn = this.round === 0 ? 0 : this.turns.length - 1;
		return this.update({ round: Math.max(this.round - 1, 0), turn: turn });
	}

	/* -------------------------------------------- */

	/**
	 * Reset all combatant initiative scores, setting the turn back to zero
	 * @return {Promise}
	 */
	async resetAll() {
		const updates = this.data.combatants.map(c => {
			return {
				_id: c._id,
				initiative: null,
			};
		});
		await this.updateManyEmbeddedEntities('Combatant', updates);
		return this.update({ turn: 0 });
	}

	/* -------------------------------------------- */

	/**
	 * Display a dialog querying the GM whether they wish to end the combat encounter and empty the tracker
	 * @return {Promise}
	 */
	async endCombat() {
		return Dialog.confirm({
			title: 'End Combat Encounter?',
			content:
				'<p>End this combat encounter and empty the turn tracker?</p>',
			yes: () => this.delete(),
		});
	}

	/* -------------------------------------------- */
	/*  Combatant Management Methods                */
	/* -------------------------------------------- */

	/** @extends {Entity.getEmbeddedEntity} */
	getCombatant(id) {
		return this.getEmbeddedEntity('Combatant', id);
	}

	/* -------------------------------------------- */

	/**
	 * Get a Combatant using its Token id
	 * {string} tokenId   The id of the Token for which to acquire the combatant
	 */
	getCombatantByToken(tokenId) {
		return this.turns.find(c => c.tokenId === tokenId);
	}

	/* -------------------------------------------- */

	/**
	 * Set initiative for a single Combatant within the Combat encounter.
	 * Turns will be updated to keep the same combatant as current in the turn order
	 * @param {string} id         The combatant ID for which to set initiative
	 * @param {Number} value      A specific initiative value to set
	 */
	async setInitiative(id, value) {
		const currentId = this.combatant._id;
		await this.updateCombatant({ _id: id, initiative: value }, {});
		await this.update({
			turn: this.turns.findIndex(c => c._id === currentId),
		});
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for one or multiple Combatants within the Combat entity
	 * @param {Array|string} ids        A Combatant id or Array of ids for which to roll
	 * @param {string|null} formula     A non-default initiative formula to roll. Otherwise the system default is used.
	 * @param {Object} messageOptions   Additional options with which to customize created Chat Messages
	 * @return {Promise.<Combat>}       A promise which resolves to the updated Combat entity once updates are complete.
	 */
	async rollInitiative(ids, formula = null, messageOptions = {}) {
		// Structure input data
		ids = typeof ids === 'string' ? [ids] : ids;
		const currentId = this.combatant._id;

		// Iterate over Combatants, performing an initiative roll for each
		const [updates, messages] = ids.reduce(
			(results, id, i) => {
				let [updates, messages] = results;

				// Get Combatant data
				const c = this.getCombatant(id);
				if (!c) return results;
				const actorData = c.actor ? c.actor.data.data : {};
				formula = formula || this._getInitiativeFormula(c);

				// Roll initiative
				const roll = new Roll(formula, actorData).roll();
				updates.push({ _id: id, initiative: roll.total });

				// Construct chat message data
				const rollMode =
					messageOptions.rollMode || c.token.hidden || c.hidden
						? 'gmroll'
						: 'roll';
				let messageData = mergeObject(
					{
						speaker: {
							scene: canvas.scene._id,
							actor: c.actor ? c.actor._id : null,
							token: c.token._id,
							alias: c.token.name,
						},
						flavor: `${c.token.name} rolls for Initiative!`,
					},
					messageOptions
				);
				const chatData = roll.toMessage(messageData, {
					rollMode,
					create: false,
				});
				if (i > 0) chatData.sound = null; // Only play 1 sound for the whole set
				messages.push(chatData);

				// Return the Roll and the chat data
				return results;
			},
			[[], []]
		);
		if (!updates.length) return this;

		// Update multiple combatants
		await this.updateManyEmbeddedEntities('Combatant', updates);

		// Ensure the turn order remains with the same combatant
		await this.update({
			turn: this.turns.findIndex(t => t._id === currentId),
		});

		// Create multiple chat messages
		await ChatMessage.createMany(messages);

		// Return the updated Combat
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for all non-player actors who have not already rolled
	 * @param {...*}  Additional arguments forwarded to the Combat.rollInitiative method
	 */
	async rollNPC(...args) {
		const npcs = this.turns.filter(
			t => (!t.actor || !t.players.length) && !t.initiative
		);
		return this.rollInitiative(
			npcs.map(t => t.id),
			...args
		);
	}

	/* -------------------------------------------- */

	/**
	 * Roll initiative for all combatants which have not already rolled
	 * @param {...*}  Additional arguments forwarded to the Combat.rollInitiative method
	 */
	async rollAll(...args) {
		const unrolled = this.turns.filter(t => !t.initiative);
		return this.rollInitiative(
			unrolled.map(t => t._id),
			...args
		);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.createEmbeddedEntity} */
	async createCombatant(data, options) {
		return this.createEmbeddedEntity('Combatant', data, options);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.updateEmbeddedEntity} */
	async updateCombatant(data, options) {
		return this.updateEmbeddedEntity('Combatant', data, options);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.deleteEmbeddedEntity} */
	async deleteCombatant(id, options) {
		return this.deleteEmbeddedEntity('Combatant', id, options);
	}

	/* -------------------------------------------- */
	/*  Socket Events and Handlers
  /* -------------------------------------------- */

	/** @override */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// Update state tracking
		this.previous = this.current;
		let c = this.combatant;
		this.current = {
			round: this.data.round,
			turn: this.data.turn,
			tokenId: c ? c.tokenId : null,
		};

		// Render the sidebar
		if (['combatants', 'round', 'turn'].some(k => data.hasOwnProperty(k))) {
			if (data.combatants) this.setupTurns();
			this.collection.render(false, { resetScroll: true });
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(...args) {
		super._onDelete(...args);
		if (this.data.active && this.collection.entities.length) {
			this.collection.entities[0]
				.update({ active: true })
				.then(() => this.collection.render());
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onModifyEmbeddedEntity(response) {
		this.setupTurns();
		if (this.data.active) this.collection.render();
	}
}

Combat.CONFIG_SETTING = 'combatTrackerConfig';
CONFIG.initiative = {
	formula: null,
	decimals: 0,
};

/**
 * The Folders Collection
 * @extends {Collection}
 */
class Folders extends Collection {
	constructor(...args) {
		super(...args);

		/**
		 * This tracks which folders are currently expanded in the UI
		 * @private
		 */
		this._expanded = {};
	}

	/* -------------------------------------------- */

	/** @override */
	get object() {
		return Folder;
	}

	/* -------------------------------------------- */

	/** @override */
	render(force, context) {
		if (context.renderContext) {
			const folder = context.entity;
			folder.entityCollection.render(force, context);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_deleteEntity({
		deleted,
		newParent,
		deleteFolderIds,
		moveFolderIds,
		deleteEntityIds,
		moveEntityIds,
		options,
		userId,
	}) {
		const folder = this.get(deleted);
		const collection = folder.entityCollection;

		// Move Entities
		for (let id of moveEntityIds) {
			let ent = collection.get(id);
			ent.data.folder = newParent;
		}

		// Delete Entities
		for (let id of deleteEntityIds) {
			collection.remove(id);
		}

		// Move Folders
		for (let id of moveFolderIds) {
			let f = this.get(id);
			f.data.parent = newParent;
		}

		// Delete Folders
		for (let id of deleteFolderIds) {
			this.remove(id);
		}

		// Render the Entity collection
		collection.render(false, {
			renderContext: 'deleteFolder',
			renderData: deleted,
			entity: folder,
		});
		return folder;
	}
}

/* -------------------------------------------- */

/**
 * The Folder Entity
 * @extends {Entity}
 */
class Folder extends Entity {
	/**
	 * Configure the attributes of the Folder Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {Collection} collection   The Collection class to which Entities of this type belong.
	 * @returns {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: Folder,
			collection: game.folders,
			embeddedEntities: {},
		};
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the parent Folder if one is set, otherwise null
	 * @type {Folder|null}
	 */
	get parent() {
		return this.constructor.collection.get(this.data.parent);
	}

	/* -------------------------------------------- */

	/**
	 * Return the named Entity type for elements in this folder.
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Collection of Entities for this folder type.
	 * @return {Collection}
	 */
	get entityCollection() {
		return Object.values(game).find(
			c => c.object && c.object.entity === this.type
		);
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of the Entities which are contained within this Folder
	 * @type {Array}
	 */
	get entities() {
		const cls = CONFIG[this.data.type].entityClass;
		return cls.collection.filter(e => e.data.folder === this._id);
	}

	/* -------------------------------------------- */

	/**
	 * Create a new Folder by rendering a dialog window to provide basic creation details
	 * @param data {Object}   Initial data with which to populate the creation form
	 */
	static createDialog(data) {
		new FolderConfig(new Folder(data)).render(true);
	}
}

/**
 * The Collection of Item entities
 * The items collection is accessible within the game as game.items
 *
 * @type {Collection}
 */
class Items extends Collection {
	/**
	 * Elements of the Items collection are instances of the Item class, or a subclass thereof
	 * @return {Item}
	 */
	get object() {
		return CONFIG.Item.entityClass;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Register an Actor sheet class as a candidate which can be used to display Actors of a given type
	 * See EntitySheetConfig.registerSheet for details
	 */
	static registerSheet(...args) {
		EntitySheetConfig.registerSheet(Item, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Unregister an Actor sheet class, removing it from the list of avaliable sheet Applications to use
	 * See EntitySheetConfig.unregisterSheet for details
	 */
	static unregisterSheet(...args) {
		EntitySheetConfig.unregisterSheet(Item, ...args);
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of currently registered sheet classes for this Entity type
	 * @type {Array}
	 */
	static get registeredSheets() {
		return Object.values(CONFIG.Item.sheetClasses).reduce(
			(arr, classes) => {
				return arr.concat(Object.values(classes).map(c => c.cls));
			},
			[]
		);
	}
}

/* -------------------------------------------- */

/**
 * The Item entity.
 * This base Item refers primarily to items which are not currently owned.
 * @type {Entity}
 */
class Item extends Entity {
	/**
	 * Configure the attributes of the ChatMessage Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {Collection} collection   The Collection class to which Entities of this type belong.
	 * @returns {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: Item,
			collection: game.items,
			embeddedEntities: {},
		};
	}

	/* -------------------------------------------- */

	prepareData() {
		super.prepareData();
		if (!this.data.img) this.data.img = CONST.DEFAULT_TOKEN;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience reference to the Actor entity which owns this item, if any
	 * @type {Actor|null}
	 */
	get actor() {
		return this.options.actor || null;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the image path (data.img) used to represent this Item
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the item type (data.type) of this Item
	 * @type {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether the current game user has ONLY limited visibility for this Entity.
	 * @return {boolean}
	 */
	get limited() {
		if (this.isOwned) return this.actor.limited;
		else return super.limited;
	}

	/* -------------------------------------------- */

	/**
	 * A flag for whether the item is owned by an Actor entity
	 * @return {boolean}
	 */
	get isOwned() {
		return this.actor !== null;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Override the standard permission test for Item entities as we need to apply a special check for owned items
	 * OwnedItems have permission that the player has for the parent Actor.
	 * @return {Boolean}            Whether or not the user has the permission for this item
	 */
	hasPerm(...args) {
		if (this.actor) return this.actor.hasPerm(...args);
		else return super.hasPerm(...args);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Extend the base Entity update logic to update owned items as well.
	 * See Entity.update for more complete API documentation
	 *
	 * @param {Object} data   The data with which to update the entity
	 * @param {Object} options  Additional options which customize the update workflow
	 * @return {Promise}        A Promise which resolves to the updated Entity
	 */
	async update(data, options) {
		// Case 1 - Update an OwnedItem within an Actor
		if (this.isOwned) {
			data._id = this.data._id;
			return this.actor.updateEmbeddedEntity('OwnedItem', data, options);
		}

		// Case 2 - Standard Entity update procedure
		else return super.update(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * A convenience constructor method to create an Item instance which is owned by an Actor
	 * @param {Object} itemData
	 * @param {Actor} actor
	 */
	static createOwned(itemData, actor) {
		let Item = CONFIG.Item.entityClass;
		return new Item(itemData, { actor: actor });
	}
}

CONFIG.Item.entityClass = Item;
CONFIG.Item.collection = Items;
Items.registerSheet('core', ItemSheet);

/**
 * The Journal collection
 * @type {Collection}
 */
class Journal extends Collection {
	/**
	 * Return the Entity class which is featured as a member of this collection
	 * @private
	 */
	get object() {
		return JournalEntry;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Open Socket listeners which transact JournalEntry data
	 * @private
	 */
	static socketListeners(socket) {
		super.socketListeners(socket);
		socket.on('showEntry', this._showEntry.bind(this));
		socket.on('shareImage', this._shareImage);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a received request to show a JournalEntry to the current client
	 * @param {String} entryId      The ID of the journal entry to display for other players
	 * @param {String} mode         The JournalEntry mode to display
	 * @param {Boolean} force       Display the entry to all players regardless of normal permissions
	 * @private
	 */
	static _showEntry(entryId, mode = 'text', force = true) {
		let entry = this.instance.get(entryId);
		if (!force && !entry.visible) return;

		// Don't show an entry that has no content
		if (mode === 'image' && !entry.data.img) return;
		else if (mode === 'text' && !entry.data.content) return;

		// Show the sheet with the appropriate mode
		entry.sheet.render(true, { sheetMode: mode });
	}

	/* -------------------------------------------- */

	/**
	 * Handle a received request to show an Image file to the current client
	 * @param {string} image    The web source path to the image to display
	 * @param {string} title    The title to display for the image frame
	 * @param {Object} entity   An optional Entity instance which the image belongs to
	 * @private
	 */
	static _shareImage({ image, title, entity } = {}) {
		new ImagePopout(image, {
			title: title,
			shareable: false,
			editable: false,
			entity: entity.type ? { type: entity.type, id: entity.id } : null,
		}).render(true);
	}
}

/* -------------------------------------------- */

/**
 * The JournalEntry class
 */
class JournalEntry extends Entity {
	/**
	 * Configure the attributes of the JournalEntry Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {Collection} collection   The Collection class to which Entities of this type belong.
	 * @returns {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: JournalEntry,
			collection: game.journal,
			embeddedEntities: {},
		};
	}

	/* -------------------------------------------- */

	/**
	 * A boolean indicator for whether or not the JournalEntry is visible to the current user in the directory sidebar
	 * @return {boolean}
	 */
	get visible() {
		return this.hasPerm(game.user, 'OBSERVER', false);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Note instance for this JournalEntry in the current Scene, if any
	 * @type {Note}
	 */
	get sceneNote() {
		return canvas.notes.placeables.find(n => n.data.entryId === this._id);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// If permissions changed for an entry with corresponding map Notes, redraw them
		if (['name', 'permission'].some(k => k in data)) {
			canvas.notes.placeables
				.filter(n => n.data.entryId === this._id)
				.forEach(n => n.draw());
		}
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Show the JournalEntry to connected players.
	 * By default the entry will only be shown to players who have permission to observe it.
	 * If the parameter force is passed, the entry will be shown to all players regardless of normal permission.
	 *
	 * @param {String} mode     Which JournalEntry mode to display? Default is text.
	 * @param {Boolean} force   Display the entry to all players regardless of normal permissions
	 * @return {Promise}        A Promise that resolves back to the shown entry once the request is processed
	 */
	async show(mode = 'text', force = false) {
		if (!this.owner)
			throw new Error(
				'You may only request to show Journal Entries which you own.'
			);
		return new Promise(resolve => {
			game.socket.emit('showEntry', this._id, mode, force, entry => {
				Journal._showEntry(this._id, mode, true);
			});
		});
	}

	/* -------------------------------------------- */

	/**
	 * If the JournalEntry has a pinned note on the canvas, this method will animate to that note
	 * The note will also be highlighted as if hovered upon by the mouse
	 */
	panToNote({ scale = 1.5, duration = 250 } = {}) {
		const note = this.sceneNote;
		if (!note) return;
		if (note.visible && !canvas.notes._active) canvas.notes.activate();
		canvas
			.animatePan({ x: note.x, y: note.y, scale, duration })
			.then(() => {
				if (canvas.notes._hover)
					canvas.notes._hover._onMouseOut(new Event('mouseout'));
				note._onMouseOver(new Event('mouseover'));
			});
	}
}

CONFIG.JournalEntry.entityClass = JournalEntry;
CONFIG.JournalEntry.collection = Journal;

/**
 * The Collection of Macro entities
 * @extends {Collection}
 */
class Macros extends Collection {
	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	get object() {
		return CONFIG.Macro.entityClass;
	}

	/* -------------------------------------------- */

	/** @override */
	static get instance() {
		return game.macros;
	}

	/* -------------------------------------------- */

	/** @override */
	get directory() {
		return ui.macros;
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether a given User is allowed to use JavaScript macros
	 * @param {User} user   The User entity to test
	 * @return {boolean}    Can the User use scripts?
	 */
	static canUseScripts(user) {
		if (user.isGM) return true;
		return game.settings.get('core', 'allowMacroScripts');
	}

	/* -------------------------------------------- */

	static registerSettings() {
		game.settings.register('core', 'allowMacroScripts', {
			name: 'MACRO.AllowScripts',
			hint: 'MACRO.AllowScriptsHint',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
		});
	}
}

/* -------------------------------------------- */

/**
 * The Macro entity which implements a triggered chat or script expression which can be quickly activated by the user.
 * All users have permission to create and use chat-based Macros, but users must be given special permission to use
 * script-based macros.
 *
 * @extends {Entity}
 *
 * @see {@link Macros}        The Collection of Macro entities
 * @see {@link MacroConfig}   The Macro Configuration sheet
 * @see {@link Hotbar}        The Hotbar interface application
 */
class Macro extends Entity {
	/** @override */
	static get config() {
		return {
			baseEntity: Macro,
			collection: game.macros,
			embeddedEntities: [],
		};
	}

	/* -------------------------------------------- */

	/**
	 * Execute the Macro command
	 * @return {Promise}
	 */
	execute() {
		// Chat macros
		if (this.data.type === 'chat') {
			ui.chat.processMessage(this.data.command).catch(err => {
				ui.notifications.error(
					'There was an error in your chat message syntax.'
				);
				console.error(err);
			});
		}

		// Script macros
		else if (this.data.type === 'script') {
			if (!Macros.canUseScripts(game.user)) {
				return ui.notifications.error(
					`You are not allowed to use JavaScript macros.`
				);
			}
			const speaker = ChatMessage.getSpeaker();
			const actor = game.actors.get(speaker.actor);
			const token = canvas.tokens.get(speaker.token);
			const character = game.user.character;
			try {
				eval(this.data.command);
			} catch (err) {
				ui.notifications.error(
					`There was an error in your macro syntax. See the console (F12) for details`
				);
				console.error(err);
			}
		}
	}
}

CONFIG.Macro.collection = Macros;
CONFIG.Macro.entityClass = Macro;

/**
 * A :class:`Collection` of class:`ChatMessage` entities
 * The Messages collection is accessible within the game as `game.messages`.
 *
 * @type {Collection}
 */
class Messages extends Collection {
	/**
	 * Elements of the Messages collection are instances of the ChatMessage class
	 * @return {ChatMessage}
	 */
	get object() {
		return ChatMessage;
	}

	/* -------------------------------------------- */

	/**
	 * Don't render any applications for this collection, as rendering is handled at a per-message level
	 * @param force
	 */
	render(force = false) {
		return;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers
  /* -------------------------------------------- */

	/**
	 * Create a new ChatMessage using provided data. See Collection._createEntity for more details.
	 * @private
	 */
	_createEntity(response) {
		const entity = super._createEntity(response);
		this._sayBubble(response);
		return entity;
	}

	/* -------------------------------------------- */

	/**
	 * If requested, dispatch a Chat Bubble UI for the newly created message
	 * @param {Object} response     The created ChatMessage response
	 * @private
	 */
	_sayBubble(response) {
		if (response.options.chatBubble && canvas.ready) {
			const message = response.created,
				speaker = message.speaker;
			if (speaker.scene === canvas.scene._id) {
				const token = canvas.tokens.get(speaker.token);
				if (token)
					canvas.hud.bubbles.say(token, message.content, {
						emote: message.type === CONST.CHAT_MESSAGE_TYPES.EMOTE,
					});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle export of the chat log to a text file
	 * @private
	 */
	export() {
		const log = this.entities
			.map(m => m.export())
			.join('\n---------------------------\n');
		let date = new Date().toDateString().replace(/\s/g, '-');
		const filename = `fvtt-log-${date}.txt`;
		saveDataToFile(log, 'text/plain', filename);
	}

	/* -------------------------------------------- */

	/**
	 * Allow for bulk deletion of all chat messages, confirm first with a yes/no dialog.
	 * @see {@link Dialog.confirm}
	 */
	async flush() {
		return Dialog.confirm(
			{
				title: game.i18n.localize('CHAT.FlushTitle'),
				content: game.i18n.localize('CHAT.FlushWarning'),
				yes: () => this.object.deleteMany([], { deleteAll: true }),
			},
			{
				top: window.innerHeight - 150,
				left: window.innerWidth - 720,
			}
		);
	}
}

/* -------------------------------------------- */

/**
 * The Chat Message class is a type of :class:`Entity` which represents individual messages in the chat log.
 *
 * @type {Entity}
 */
class ChatMessage extends Entity {
	constructor(...args) {
		super(...args);

		/**
		 * Get a reference to the user who sent the chat message
		 */
		this.user = game.users.get(this.data.user);

		/**
		 * If the Message contains a dice roll, store it here
		 */
		this._roll = null;
	}

	/* -------------------------------------------- */

	/**
	 * Configure the attributes of the ChatMessage Entity
	 *
	 * @returns {Entity} baseEntity       The parent class which directly inherits from the Entity interface.
	 * @returns {Collection} collection   The Collection class to which Entities of this type belong.
	 * @returns {Array} embeddedEntities  The names of any Embedded Entities within the Entity data structure.
	 */
	static get config() {
		return {
			baseEntity: ChatMessage,
			collection: game.messages,
			embeddedEntities: {},
		};
	}

	/* -------------------------------------------- */
	/*  Properties and Attributes
  /* -------------------------------------------- */

	/**
	 * Return the recommended String alias for this message.
	 * The alias could be a Token name in the case of in-character messages or dice rolls.
	 * Alternatively it could be a User name in the case of OOC chat or whispers.
	 * @type {String}
	 */
	get alias() {
		const speaker = this.data.speaker;
		if (speaker.alias) return speaker.alias;
		else if (speaker.actor) return game.actors.get(speaker.actor).name;
		else return this.user ? this.user.name : '';
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the ChatMessage is visible to the current user
	 * Messages may not be visible if they are private whispers
	 * @type {boolean}
	 */
	get visible() {
		if (this.data.whisper.length) {
			if (this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL) return true;
			if (
				this.data.user === game.user._id ||
				this.data.whisper.indexOf(game.user._id) !== -1
			)
				return true;
			let allowSecret = game.settings.get('core', 'secretMessages');
			return !allowSecret && game.user.isGM;
		}
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Is the current User the author of this message?
	 * @type {boolean}
	 */
	get isAuthor() {
		return game.user._id === this.user._id;
	}

	/* -------------------------------------------- */

	/**
	 * Return whether the message contains a visible dice roll
	 * @type {boolean}
	 */
	get isRollVisible() {
		if (this.data.type !== CONST.CHAT_MESSAGE_TYPES.ROLL) return false;
		const whisper = this.data.whisper;
		const uid = game.user._id;
		if (this.data.blind) return whisper.includes(uid);
		else if (whisper.length > 0)
			return this.data.user === uid || whisper.includes(uid);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the chat message contains a dice roll
	 * @type {boolean}
	 */
	get isRoll() {
		return this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL;
	}

	/* -------------------------------------------- */

	/**
	 * Return the Roll instance contained in this chat message, if one is present
	 * @type {Roll}
	 */
	get roll() {
		if (this._roll === null) {
			try {
				this._roll = Roll.fromJSON(this.data.roll);
			} catch (err) {
				this._roll = false;
			}
		}
		return this._roll;
	}

	/* -------------------------------------------- */
	/*  HTML Rendering
  /* -------------------------------------------- */

	/**
	 * Render the HTML for the ChatMessage which should be added to the log
	 * @return {Promise.<HTMLElement>}
	 */
	async render() {
		const messageData = {
			user: game.user,
			author: this.user,
			alias: this.alias,
			message: duplicate(this.data),
			cssClass: [
				this.data.type === CONST.CHAT_MESSAGE_TYPES.IC ? 'ic' : null,
				this.data.type === CONST.CHAT_MESSAGE_TYPES.EMOTE
					? 'emote'
					: null,
				this.data.whisper.length ? 'whisper' : null,
				this.data.blind ? 'blind' : null,
			]
				.filter(c => c !== null)
				.join(' '),
			isWhisper: this.data.whisper.length,
			whisperTo: this.data.whisper
				.map(u => {
					let user = game.users.get(u);
					return user ? user.name : null;
				})
				.filter(n => n !== null)
				.join(', '),
		};

		// Enrich message content
		if (this.isRoll && this.roll) {
			let isPrivate = !this.isRollVisible;
			messageData.message.content = await this.roll.render({
				isPrivate: isPrivate,
			});
			if (isPrivate) {
				const subject =
					this.data.user === game.user._id ? 'You' : this.user.name;
				messageData.message.flavor = `${subject} privately rolled some dice`;
			}
		} else
			messageData.message.content = TextEditor.enrichHTML(
				this.data.content,
				{ entities: true }
			);

		// Define a border color
		if (this.data.type === CONST.CHAT_MESSAGE_TYPES.OOC) {
			messageData.borderColor = this.user.color;
		}

		// Render the chat message
		let html = await renderTemplate(
			CONFIG.ChatMessage.template,
			messageData
		);
		html = $(html);

		// Call a hook for the rendered ChatMessage data
		Hooks.call('renderChatMessage', this, html, messageData);
		return html;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers
  /* -------------------------------------------- */

	/** @override */
	static async create(data, options) {
		return super.create(this._preprocessCreateData(data), options);
	}

	/* -------------------------------------------- */

	/** @override */
	static async createMany(data, options = {}) {
		return super.createMany(data.map(this._preprocessCreateData), options);
	}

	/* -------------------------------------------- */

	/**
	 * Preprocess the data object used to create a new Chat Message to automatically convert some Objects to the
	 * data format expected by the database handler.
	 * @param {Object} data
	 * @return {Object}
	 * @private
	 */
	static _preprocessCreateData(data) {
		// Message creator
		if (data.user instanceof User) data.user = data.user._id;
		if (!data.user) data.user = game.user._id;

		// Ensure to pass IDs rather than objects
		if (data.speaker && data.speaker.actor instanceof Actor)
			data.speaker.actor = data.speaker.actor._id;
		if (data.speaker && data.speaker.scene instanceof Scene)
			data.speaker.scene = data.speaker.scene._id;
		if (data.speaker && data.speaker.token instanceof Token)
			data.speaker.token = data.speaker.token.id;

		// Serialize Roll data
		if (data.roll && data.roll instanceof Roll)
			data.roll = JSON.stringify(data.roll);
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Specific actions that should occur be when the ChatMessage is first created
	 * @private
	 */
	_onCreate(...args) {
		super._onCreate(...args);
		let notify = this.data.user._id !== game.user._id;
		ui.chat.postOne(this, notify);
	}

	/* -------------------------------------------- */

	/**
	 * Specific actions that should occur be when an existing ChatMessage is updated
	 * @private
	 */
	_onUpdate(...args) {
		super._onUpdate(...args);
		ui.chat.updateMessage(this);
	}

	/* -------------------------------------------- */

	/**
	 * Specific actions that should occur be when an existing ChatMessage is deleted
	 * @private
	 */
	_onDelete(...args) {
		super._onDelete(...args);
		ui.chat.deleteMessage(this._id);
	}

	/* -------------------------------------------- */
	/*  Saving and Loading
  /* -------------------------------------------- */

	/**
	 * Export the content of the chat message into a standardized log format
	 * @return {String}
	 */
	export() {
		let content = [];

		// Handle Roll content
		if (this.isRoll) {
			let r = this.roll;

			// Start with any text content
			if (this.data.content && this.data.content !== 'undefined') {
				content.push(
					$(`<div>${this.data.content}</div>`)
						.text()
						.trim()
				);
			}

			// Add flavor text
			let flavor = this.data.flavor;
			if (flavor && flavor !== r.formula) content.push(flavor);

			// Add formula content
			let result = r.parts
				.map(p => {
					if (p instanceof Die)
						return (
							'[' +
							Object.values(p.rolls)
								.map(r => r.roll)
								.join(',') +
							']'
						);
					else return p;
				})
				.join(' ');
			content.push(`${r.formula} = ${result} = ${r.total}`);
		}

		// Handle HTML content
		else {
			const html = $('<article>').html(
				this.data['content'].replace(/<\/div>/g, '</div>|n')
			);
			const text = html.length ? html.text() : this.data['content'];
			const lines = text
				.replace(/\n/g, '')
				.split('  ')
				.filter(p => p !== '')
				.join(' ');
			content = lines.split('|n').map(l => l.trim());
		}

		// Author and timestamp
		const time = new Date(this.data.timestamp).toLocaleDateString('en-US', {
			hour: 'numeric',
			minute: 'numeric',
			second: 'numeric',
		});

		// Format logged result
		return `[${time}] ${this.alias}\n${content.filterJoin('\n')}`;
	}

	/* -------------------------------------------- */

	/**
	 * Given a string whisper target, return an Array of the user IDs which should be targeted for the whisper
	 *
	 * @param {String} name   The target name of the whisper target
	 * @return {Array}        An array of user IDs (or possibly none)
	 */
	static getWhisperIDs(name) {
		// Whisper to groups
		if (['GM', 'DM'].includes(name.toUpperCase())) {
			return game.users.entities.filter(u => u.isGM).map(u => u._id);
		} else if (name.toLowerCase() === 'players') {
			return game.users.players.map(u => u._id);
		}

		// Match against lowercase name
		const lname = name.toLowerCase();

		// Whisper to a single person
		let user = game.users.entities.find(
			u => u.name.toLowerCase() === lname
		);
		if (user) return [user._id];
		let actor = game.users.entities.find(
			a => a.character && a.character.name.toLowerCase() === lname
		);
		if (actor) return [actor._id];

		// Otherwise return an empty array
		return [];
	}

	/* -------------------------------------------- */

	/**
	 * Attempt to determine who is the speaking character (and token) for a certain Chat Message
	 * First assume that the currently controlled Token is the speaker
	 * @returns {Object}  The identified speaker data
	 */
	static getSpeaker({ scene, actor, token, alias } = {}) {
		let speaker = null;

		// CASE 1 - A Token is explicitly provided
		if (token instanceof Token)
			speaker = this._getSpeakerFromToken({ token, alias });
		// CASE 2 - An Actor is explicitly provided
		else if (actor instanceof Actor) {
			alias = alias || actor.name;
			const tokens = actor.getActiveTokens();
			if (!tokens.length)
				speaker = this._getSpeakerFromActor({ scene, actor, alias });
			else {
				const controlled = tokens.filter(t => t._controlled);
				token = controlled.length ? controlled.shift() : tokens.shift();
				speaker = this._getSpeakerFromToken({ token, alias });
			}
		}

		// CASE 3 - Not the viewed Scene
		else if (scene instanceof Scene && !scene.isView) {
			const char = game.user.character;
			if (char)
				speaker = this._getSpeakerFromActor({
					scene,
					actor: char,
					alias,
				});
			else
				speaker = this._getSpeakerFromUser({
					scene,
					user: game.user,
					alias,
				});
		}

		// Remaining cases - infer from the viewed Scene
		else {
			const char = game.user.character;

			// CASE 4 - Infer from controlled tokens
			let controlled = canvas.tokens.controlled;
			if (controlled.length)
				speaker = this._getSpeakerFromToken({
					token: controlled.shift(),
					alias,
				});
			// CASE 5 - Infer from impersonated Actor
			else if (char) {
				const tokens = char.getActiveTokens();
				if (tokens.length)
					speaker = this._getSpeakerFromToken({
						token: tokens.shift(),
						alias,
					});
				else
					speaker = this._getSpeakerFromActor({ actor: char, alias });
			}

			// CASE 6 - From the alias and User
			else
				speaker = this._getSpeakerFromUser({
					scene,
					user: game.user,
					alias,
				});
		}

		// Clean data and return
		return {
			scene:
				speaker.scene instanceof Scene
					? speaker.scene.id
					: speaker.scene,
			actor:
				speaker.actor instanceof Actor
					? speaker.actor.id
					: speaker.actor,
			token:
				speaker.token instanceof Token
					? speaker.token.id
					: speaker.token,
			alias: speaker.alias,
		};
	}

	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target Token
	 * @private
	 */
	static _getSpeakerFromToken({ token, alias }) {
		return {
			scene: token.scene,
			token: token,
			actor: token.actor,
			alias: alias || token.name,
		};
	}

	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target Actor
	 * @private
	 */
	static _getSpeakerFromActor({ scene, actor, alias }) {
		return {
			scene: scene || canvas.scene,
			actor: actor,
			token: null,
			alias: alias || actor.name,
		};
	}

	/* -------------------------------------------- */

	/**
	 * A helper to prepare the speaker object based on a target User
	 * @private
	 */
	static _getSpeakerFromUser({ scene, user, alias }) {
		return {
			scene: scene || canvas.scene,
			actor: null,
			token: null,
			alias: alias || user.name,
		};
	}
}

/* -------------------------------------------- */

/**
 * Configure the ChatMessage entity
 * @type {string}
 */
CONFIG.ChatMessage = {
	template: 'templates/sidebar/chat-message.html',
};

/**
 * The Collection of Playlist entities.
 * @extends {Collection}
 */
class Playlists extends Collection {
	constructor(...args) {
		super(...args);
		Hooks.on('preUpdateScene', this._onUpdateScene.bind(this));
	}

	/* -------------------------------------------- */

	/** @override */
	get object() {
		return Playlist;
	}

	/* -------------------------------------------- */

	/**
	 * Return the subset of Playlist entities which are currently playing
	 * @type {Array}
	 */
	get playing() {
		return this.entities.filter(s => s.data.playing);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to a Scene to determine whether to trigger changes to Playlist entities.
	 * @param {Scene} scene       The Scene entity being updated
	 * @param {Object} data       Incremental update data
	 * @param {Object} options    Update options
	 * @private
	 */
	_onUpdateScene(scene, data, options) {
		const currentScene = game.scenes.active;
		scene = scene instanceof Scene ? scene : game.scenes.get(data._id); // this is a kind of temporary workaround
		const activeChange = data.active === true;
		const playlistChange = data.hasOwnProperty('playlist');
		if (activeChange || (scene.data.active && playlistChange)) {
			const currentPlaylist =
				currentScene && currentScene.playlist
					? currentScene.playlist
					: null;
			const newPlaylist = playlistChange
				? this.get(data.playlist)
				: scene.playlist;
			if (
				currentPlaylist === newPlaylist &&
				currentPlaylist &&
				currentPlaylist.playing
			)
				return;
			if (currentPlaylist) currentPlaylist.stopAll();
			if (newPlaylist) newPlaylist.playAll();
		}
	}
}

/* -------------------------------------------- */

/**
 * The Playlist Entity.
 * Each Playlist is a collection of Sounds which are used to provide background music and sound effects.
 * @extends {Entity}
 */
class Playlist extends Entity {
	constructor(...args) {
		super(...args);

		/**
		 * Each sound which is played within the Playlist has a created Howl instance.
		 * The keys of this object are the sound IDs and the values are the Howl instances.
		 * @type {Object}
		 */
		this.audio = this.audio || {};

		/**
		 * Playlists may have a playback order which defines the sequence of Playlist Sounds
		 * @type {Array}
		 */
		this.playbackOrder = [];
	}

	/* -------------------------------------------- */

	/** @override */
	static get config() {
		return {
			baseEntity: Playlist,
			collection: game.playlists,
			embeddedEntities: { PlaylistSound: 'sounds' },
		};
	}

	/* -------------------------------------------- */

	/** @override */
	prepareEmbeddedEntities() {
		this.audio = {};
		this.data.sounds.forEach(s => this._createAudio(s));
	}

	/* -------------------------------------------- */

	/**
	 * Set up the Howl object by calling the core AudioHelper utility
	 * @param {Object} sound    The PlaylistSound for which to create an audio object
	 * @return {Object}         The created audio object
	 * @private
	 */
	_createAudio(sound) {
		let howl = game.audio.create({ src: sound.path });
		this.audio[sound._id] = {
			howl: howl,
			id: undefined,
			sound: sound._id,
		};
		howl.on('end', () => this._onEnd(sound._id));

		// Handle sounds which are currently playing
		if (sound.playing) {
			if (Howler.state === 'suspended')
				game.audio.pending.push(() => this.playSound(sound));
			else this.playSound(sound);
		}
	}

	/* -------------------------------------------- */

	/**
	 * This callback triggers whenever a sound concludes playback
	 * Mark the concluded sound as no longer playing and possibly trigger playback for a subsequent sound depending on
	 * the playlist mode.
	 *
	 * @param {string} soundId  The sound ID of the track which is ending playback
	 * @private
	 */
	async _onEnd(soundId) {
		if (!game.user.isGM) return;

		// Retrieve the sound object whose reference may have changed
		const sound = this.getEmbeddedEntity('PlaylistSound', soundId);
		if (sound.repeat) return;

		// Conclude playback for the current sound
		const isPlaying = this.data.playing;
		await this.updateEmbeddedEntity('PlaylistSound', {
			_id: sound._id,
			playing: false,
		});

		// Sequential or shuffled playback -- begin playing the next sound
		if (
			isPlaying &&
			[
				CONST.PLAYLIST_MODES.SEQUENTIAL,
				CONST.PLAYLIST_MODES.SHUFFLE,
			].includes(this.mode)
		) {
			let next = this._getNextSound(sound._id);
			if (next)
				await this.updateEmbeddedEntity('PlaylistSound', {
					_id: next._id,
					playing: true,
				});
			else await this.update({ playing: false });
		}

		// Simultaneous playback - check if all have finished
		else if (isPlaying && this.mode === CONST.PLAYLIST_MODES.SIMULTANEOUS) {
			let isComplete = !this.sounds.some(s => s.playing);
			if (isComplete) {
				await this.update({ playing: false });
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Generate a new playback order for the playlist.
	 * Use a seed for randomization to (hopefully) guarantee that all clients generate the same random order.
	 * The seed is based on the first 9 characters of the UTC datetime multiplied by the index order of the playlist.
	 * @private
	 */
	_getPlaybackOrder() {
		const idx = this.collection.entities.findIndex(
			e => e._id === this.data._id
		);
		const seed =
			Number(
				new Date()
					.getTime()
					.toString()
					.substr(0, 9)
			) * idx;
		const mt = new MersenneTwister(seed);

		// Draw a random order
		let shuffle = this.sounds.reduce((shuffle, s) => {
			shuffle[s._id] = mt.random();
			return shuffle;
		}, {});

		// Return the playback order
		return this.sounds
			.map(s => s._id)
			.sort((a, b) => shuffle[a] - shuffle[b]);
	}

	/* -------------------------------------------- */

	/**
	 * Get the next sound which should be played in the Playlist after the current sound completes
	 * @param {string} soundId    The ID of the currently playing sound
	 * @return {Object}           The sound data for the next sound to play
	 * @private
	 */
	_getNextSound(soundId) {
		// Get the playback order
		let order;
		if (this.mode === CONST.PLAYLIST_MODES.SHUFFLE) {
			if (!this.playbackOrder.length)
				this.playbackOrder = this._getPlaybackOrder();
			order = this.playbackOrder;
		} else order = this.sounds.map(s => s._id);

		// Cycle the playback index
		let idx = order.indexOf(soundId);
		if (idx === order.length - 1) idx = -1;

		// Return the next sound
		return this.getEmbeddedEntity('PlaylistSound', order[idx + 1]);
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * An Array of the sound data contained within this Playlist entity
	 * @type {Array}
	 */
	get sounds() {
		return this.data.sounds;
	}

	/* -------------------------------------------- */

	/**
	 * The playback mode for the Playlist instance
	 * @type {Number}
	 */
	get mode() {
		return this.data.mode;
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether any Sound within the Playlist is currently playing
	 * @type {boolean}
	 */
	get playing() {
		return this.sounds.some(s => s.playing);
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Play (or stop) a single sound from the Playlist
	 * @param sound {Object}       The sound object to begin playback
	 */
	playSound(sound) {
		// Get the audio data
		const audio = this.audio[sound._id];
		if (!sound.playing && !audio.id) return;

		// Start playing
		if (sound.playing) {
			if (audio.howl.state() !== 'loaded') audio.howl.load();
			audio.id = audio.howl.play(audio.id);
			let vol =
				sound.volume *
				game.settings.get('core', 'globalPlaylistVolume');
			audio.howl.volume(vol, audio.id);
			audio.howl.loop(sound.repeat, audio.id);
		}

		// End playback
		else audio.howl.stop(audio.id);
	}

	/* -------------------------------------------- */

	/**
	 * Begin simultaneous playback for all sounds in the Playlist
	 * @return {Promise}    A Promise which resolves once the Playlist update is complete
	 */
	async playAll() {
		const updateData = {};

		// Handle different playback modes
		switch (this.mode) {
			// Soundboard Only
			case CONST.PLAYLIST_MODES.DISABLED:
				updateData.playing = false;
				break;

			// Sequential Playback
			case CONST.PLAYLIST_MODES.SEQUENTIAL:
				updateData.sounds = duplicate(this.data.sounds).map((s, i) => {
					s.playing = i === 0;
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;

			// Simultaneous - play all tracks
			case CONST.PLAYLIST_MODES.SIMULTANEOUS:
				updateData.sounds = duplicate(this.data.sounds).map(s => {
					s.playing = true;
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;

			// Shuffle - play random track
			case CONST.PLAYLIST_MODES.SHUFFLE:
				this.playbackOrder = this._getPlaybackOrder();
				updateData.sounds = duplicate(this.data.sounds).map(s => {
					s.playing = s._id === this.playbackOrder[0];
					return s;
				});
				updateData.playing = updateData.sounds.length > 0;
				break;
		}

		// Update the Playlist
		return this.update(updateData);
	}

	/* -------------------------------------------- */

	/**
	 * End playback for any/all currently playing sounds within the Playlist
	 * @return {Promise}    A Promise which resolves once the Playlist update is complete
	 */
	async stopAll() {
		const sounds = duplicate(this.data.sounds).map(s => {
			s.playing = false;
			return s;
		});
		return this.update({ playing: false, sounds: sounds });
	}

	/* -------------------------------------------- */

	/**
	 * Cycle the playlist mode
	 * @return {Promise.<Playlist>}   A promise which resolves to the updated Playlist instance
	 */
	async cycleMode() {
		// Cycle the playback mode
		const modes = Object.values(CONST.PLAYLIST_MODES);
		let mode = this.mode + 1;
		mode = mode > Math.max(...modes) ? modes[0] : mode;

		// Stop current playback
		let sounds = this.data.sounds.map(s => {
			s.playing = false;
			return s;
		});

		// Update the playlist
		return this.update({ sounds: sounds, mode: mode });
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * @extends {Entity.createEmbeddedEntity}
	 * @deprecated
	 */
	async createSound(data, options = {}) {
		console.warn(
			'You are using Playlist.createSound() which is deprecated in favor of the generalized Entity.createEmbeddedEntity() method'
		);
		return this.createEmbeddedEntity('PlaylistSound', data, options);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity.updateEmbeddedEntity}
	 * @deprecated
	 */
	async updateSound(data, options = {}) {
		console.warn(
			'You are using Playlist.updateSound() which is deprecated in favor of the generalized Entity.updateEmbeddedEntity() method'
		);
		return this.updateEmbeddedEntity('PlaylistSound', data, options);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity.deleteEmbeddedEntity}
	 * @deprecated
	 */
	async deleteSound(id, options = {}) {
		console.warn(
			'You are using Playlist.deleteSound() which is deprecated in favor of the generalized Entity.deleteEmbeddedEntity() method'
		);
		return this.deleteEmbeddedEntity('PlaylistSound', id, options);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(response) {
		// Modify playback for individual sounds
		this.sounds.forEach(s => this.playSound(s));
		return super._onUpdate(response);
	}

	/* -------------------------------------------- */

	/** @override */
	_onCreateEmbeddedEntity(response) {
		// Create the audio object
		const sound = response.created;
		this._createAudio(sound);
		return super._onCreateEmbeddedEntity(response);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdateEmbeddedEntity(response) {
		const changed = Object.keys(response.data);
		const sound = this.getEmbeddedEntity(
			'PlaylistSound',
			response.data._id
		);

		// If the path was changed, we need to re-create the audio object
		if (changed.includes('path')) {
			const audio = this.audio[sound._id];
			audio.howl.stop(audio.id);
			this._createAudio(sound);
		}

		// Otherwise update the playing state
		else this.playSound(sound);
		return super._onUpdateEmbeddedEntity(response);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDeleteEmbeddedEntity(response) {
		const sound = response.deleted;
		sound.playing = false;
		this.playSound(sound);
		delete this.audio[sound._id];
		return super._onDeleteEmbeddedEntity(response);
	}

	/* -------------------------------------------- */

	/** @override */
	_onModifyEmbeddedEntity(response) {
		this.collection.render();
	}
}

CONFIG.Playlist.collection = Playlists;
CONFIG.Playlist.entityClass = Playlist;

/**
 * The collection of Scene entities
 */
class Scenes extends Collection {
	/** @override */
	get object() {
		return Scene;
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Scene which is currently active
	 * @return {Scene}
	 */
	get active() {
		return this.entities.find(s => s.active);
	}

	/* -------------------------------------------- */

	/**
	 * Return a reference to the Scene which is currently viewed
	 * @return {Scene}
	 */
	get viewed() {
		return this.entities.find(s => s.isView);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @extends {Collection.socketListeners} */
	static socketListeners(socket) {
		super.socketListeners(socket);
		socket.on('preloadScene', sceneId => this.instance.preload(sceneId));
		socket.on('resetFogExploration', this._onFogReset);
		socket.on('pullToScene', this._pullToScene);
	}

	/* -------------------------------------------- */

	/**
	 * Handle pre-loading the art assets for a Scene
	 * @param {string} sceneId    The Scene id to begin loading
	 * @param {boolean} push      Trigger other connected clients to also pre-load Scene resources
	 */
	preload(sceneId, push = false) {
		if (push)
			return game.socket.emit('preloadScene', sceneId, () =>
				this.preload(sceneId)
			);
		let scene = this.get(sceneId);
		if (!canvas.app.loader.resources.hasOwnProperty(scene.data.img)) {
			canvas.app.loader.add(scene.data.img).load();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Fog of War exploration reset request
	 * @param {Object} resetData
	 * @private
	 */
	static _onFogReset(resetData) {
		if (resetData.reset && resetData.scene === canvas.scene._id) {
			canvas.sight.fogData = {};
			canvas.sight.fogPositions = {};
			canvas.sight.draw();
			canvas.sight.initialize();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle requests pulling the current User to a specific Scene
	 * @param {string} sceneId
	 * @private
	 */
	static _pullToScene(sceneId) {
		const scene = game.scenes.get(sceneId);
		if (scene) scene.view();
	}

	/* -------------------------------------------- */
	/*  Embedded Entity History Storage             */
	/* -------------------------------------------- */

	/** @extends {Collection._createEmbeddedEntity} */
	_createEmbeddedEntity({ parentId, created, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			layer.storeHistory('create', created);
		}
		return super._createEmbeddedEntity({
			parentId,
			created,
			options,
			userId,
		});
	}

	/* -------------------------------------------- */

	/** @extends {Collection._createManyEmbeddedEntities} */
	_createManyEmbeddedEntities({ parentId, data, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			layer.storeHistory('createMany', data);
		}
		return super._createManyEmbeddedEntities({
			parentId,
			data,
			options,
			userId,
		});
	}

	/* -------------------------------------------- */

	/** @extends {Collection._updateEmbeddedEntity} */
	_updateEmbeddedEntity({ parentId, data, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			const scene = this.get(parentId);
			const original = duplicate(
				scene.getEmbeddedEntity(options.embeddedName, data._id)
			);
			layer.storeHistory('update', original);
		}
		return super._updateEmbeddedEntity({ parentId, data, options, userId });
	}

	/* -------------------------------------------- */

	/** @extends {Collection._updateManyEmbeddedEntities} */
	_updateManyEmbeddedEntities({ parentId, data, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			const scene = this.get(parentId);
			const originals = duplicate(
				scene.getEmbeddedCollection(options.embeddedName)
			);
			layer.storeHistory('updateMany', originals);
		}
		return super._updateManyEmbeddedEntities({
			parentId,
			data,
			options,
			userId,
		});
	}

	/* -------------------------------------------- */

	/** @extends {Collection._deleteEmbeddedEntity} */
	_deleteEmbeddedEntity({ parentId, deleted, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			const scene = this.get(parentId);
			const original = duplicate(
				scene.getEmbeddedEntity(options.embeddedName, deleted)
			);
			layer.storeHistory('delete', original);
		}
		return super._deleteEmbeddedEntity({
			parentId,
			deleted,
			options,
			userId,
		});
	}

	/* -------------------------------------------- */

	/** @extends {Collection._deleteManyEmbeddedEntities} */
	_deleteManyEmbeddedEntities({ parentId, data, options, userId }) {
		if (!options.isUndo && canvas.scene._id === parentId) {
			const layer = canvas.getLayerByEmbeddedName(options.embeddedName);
			const scene = this.get(parentId);
			const originals = scene
				.getEmbeddedCollection(options.embeddedName)
				.filter(o => data.includes(o._id));
			layer.storeHistory('deleteMany', originals);
		}
		return super._deleteManyEmbeddedEntities({
			parentId,
			data,
			options,
			userId,
		});
	}
}

/* -------------------------------------------- */
/*  The Scene Entity                            */
/* -------------------------------------------- */

/**
 * The Scene Entity.
 * Scenes represent the locations and settings which Actors will explore within the World.
 * @extends {Entity}
 */
class Scene extends Entity {
	constructor(...args) {
		super(...args);

		/**
		 * Track whether the scene is the active view
		 * @type {Boolean}
		 */
		this._view = this.data.active;

		/**
		 * Track the viewed position of each scene (while in memory only, not persisted)
		 * When switching back to a previously viewed scene, we can automatically pan to the previous position.
		 * Object with keys: x, y, scale
		 * @type {Object}
		 */
		this._viewPosition = {};

		/**
		 * A reference to the active Scene Notes instance for this Scene
		 * @type {SceneNotes}
		 */
		this._notes = null;
	}

	/* -------------------------------------------- */

	/** @extends {Collection.config} */
	static get config() {
		return {
			baseEntity: Scene,
			collection: game.scenes,
			embeddedEntities: {
				AmbientLight: 'lights',
				AmbientSound: 'sounds',
				Drawing: 'drawings',
				Note: 'notes',
				MeasuredTemplate: 'templates',
				Tile: 'tiles',
				Token: 'tokens',
				Wall: 'walls',
			},
		};
	}

	/* -------------------------------------------- */

	/** @override */
	prepareEmbeddedEntities() {}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the background image of the Scene
	 * @type {string}
	 */
	get img() {
		return this.data.img;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for whether the Scene is currently active
	 * @type {boolean}
	 */
	get active() {
		return this.data.active;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for whether the Scene is currently viewed
	 * @type {boolean}
	 */
	get isView() {
		return this._view;
	}

	/* -------------------------------------------- */

	/**
	 * A singleton instance of the SheetNotes class
	 * @type {SheetNotes}
	 */
	get notes() {
		if (this._notes) return this._notes;
		let cls = CONFIG.Scene.notesClass;
		if (!cls) return null;
		this._notes = new cls(this, { editable: this.owner });
		return this._notes;
	}

	/* -------------------------------------------- */

	/**
	 * A reference to the Playlist entity for this Scene, or null
	 * @type {Playlist|null}
	 */
	get playlist() {
		return this.data.playlist
			? game.playlists.get(this.data.playlist)
			: null;
	}

	/* -------------------------------------------- */

	/**
	 * Set this scene as the current view
	 */
	view() {
		// Switch the viewed scene
		this.collection.entities.forEach(scene => {
			scene._view = scene._id === this._id;
		});

		// Re-draw the canvas if the view is different
		if (canvas.id !== this._id) {
			console.log(`Foundry VTT | Viewing Scene ${this.name}`);
			canvas.draw();
		}

		// Render apps for the collection
		this.collection.render();
	}

	/* -------------------------------------------- */

	/**
	 * Set this scene as currently active
	 * @return {Promise}  A Promise which resolves to the current scene once it has been successfully activated
	 */
	async activate() {
		if (this.active) return this;
		return this.update({ active: true });
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	async clone(createData = {}, options = {}) {
		createData['active'] = false;
		createData['navigation'] = false;
		return super.clone(createData, options);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.update} */
	async update(data, options = {}) {
		let imgChange =
				data.hasOwnProperty('img') && data.img !== this.data.img,
			needsThumb = data.hasOwnProperty('img') && !this.data.thumb;

		// Update the Scene thumbnail if necessary
		if (imgChange || needsThumb) {
			try {
				const thumbData = await BackgroundLayer.createThumbnail(
					data.img
				);
				data = mergeObject(data, thumbData);
			} catch (err) {
				ui.notifications.error(
					'Thumbnail generation for Scene failed: ' + err.message
				);
				data['thumb'] = null;
			}
		}

		// Call the Entity update
		return super.update(data, options);
	}

	/* -------------------------------------------- */

	/** @extends {Entity._onUpdate} */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// Get the changed attributes
		let changed = new Set(Object.keys(data).filter(k => k !== '_id'));

		// If the background image was removed, also remove the thumbnail
		if (changed.has('img') && !this.data.img) this.data.thumb = null;

		// If the Scene became active, go through the full activation procedure
		if (changed.has('active')) this._onActivate(data.active);
		// Otherwise if the scene is already active, maybe re-draw the canvas
		else if (canvas.scene === this) {
			const redraw = [
				'backgroundColor',
				'drawings',
				'gridType',
				'grid',
				'gridAlpha',
				'gridColor',
				'gridDistance',
				'gridUnits',
				'shiftX',
				'shiftY',
				'width',
				'height',
				'img',
				'tokenVision',
				'globalLight',
				'fogExploration',
				'lights',
				'sounds',
				'templates',
				'tiles',
				'tokens',
				'walls',
				'weather',
			];
			if (redraw.some(k => changed.has(k))) canvas.draw();
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onCreateEmbeddedEntity({ embeddedName, created, options, userId }) {
		if (!this.isView) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.createObject(created);
		object._onCreate();
		if (options.displaySheet && object.sheet) object.sheet.render(true);
		return object;
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdateEmbeddedEntity({ embeddedName, data, options, userId }) {
		if (!this.isView) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.get(data._id);
		object.data = this.getEmbeddedEntity(embeddedName, data._id);
		object._onUpdate(data);
		return object;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDeleteEmbeddedEntity({ embeddedName, deleted, options, userId }) {
		if (!this.isView) return;
		const layer = canvas.getLayerByEmbeddedName(embeddedName);
		const object = layer.get(deleted._id);
		layer.objects.removeChild(object);
		object._onDelete();
		object.destroy({ children: true });
		return object;
	}

	/* -------------------------------------------- */

	/** @override */
	_onModifyEmbeddedEntity(response) {
		canvas.triggerPendingOperations();
	}

	/* -------------------------------------------- */

	/**
	 * Handle Scene activation workflow if the active state is changed to true
	 * @private
	 */
	_onActivate(active) {
		const collection = this.collection;
		if (active) {
			collection.entities.forEach(
				scene => (scene.data.active = scene._id === this._id)
			);
			this.view();
			game.combats.render();
		} else canvas.draw(null);
	}

	/* -------------------------------------------- */

	/**
	 * Additional updating steps for the Scene entity the entity is deleted
	 */
	_onDelete(...args) {
		super._onDelete(...args);
		if (canvas.scene._id === this._id) canvas.draw();
	}
}

CONFIG.Scene.collection = Scenes;
CONFIG.Scene.entityClass = Scene;

/**
 * The Collection of RollTable entities
 * @extends {Collection}
 */
class RollTables extends Collection {
	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	get object() {
		return CONFIG.RollTable.entityClass;
	}

	/* -------------------------------------------- */

	/** @override */
	static get instance() {
		return game.tables;
	}

	/* -------------------------------------------- */

	/** @override */
	get directory() {
		return ui.tables;
	}

	/* -------------------------------------------- */

	/**
	 * Register world settings related to RollTable entities
	 */
	static registerSettings() {
		// Show Player Cursors
		game.settings.register('core', 'animateRollTable', {
			name: 'TABLE.AnimateSetting',
			hint: 'TABLE.AnimateSettingHint',
			scope: 'world',
			config: true,
			default: true,
			type: Boolean,
		});
	}
}

/* -------------------------------------------- */

/**
 * The RollTable entity which implements randomized rollable tables
 * @type {Entity}
 */
class RollTable extends Entity {
	/** @override */
	static get config() {
		return {
			baseEntity: RollTable,
			collection: game.tables,
			embeddedEntities: { TableResult: 'results' },
		};
	}

	/* -------------------------------------------- */

	/** @override */
	prepareEmbeddedEntities() {}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the array of TableResult embedded documents
	 * @type {Array.<Object>}
	 */
	get results() {
		return this.data.results;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Draw a result from the RollTable based on the table formula or a provided Roll instance
	 * @param {Roll|null} roll          An existing Roll instance to use for drawing from the table
	 * @param {Object|null} result      A roll table result or null, to draw randomly based on the roll
	 * @param {string|null} rollMode    The chat roll mode to use when displaying the result
	 * @returns {Promise.<Object>}      A promise resolving to the selected Table Result object
	 */
	async draw({ roll = null, result = null } = {}, { rollMode = null } = {}) {
		// If a roll and result were not provided, obtain them
		if ((roll === result) === null) {
			[roll, result] = this.roll();
		}
		if (result === null) return;
		const speaker = ChatMessage.getSpeaker({ user: game.user });

		// Display the Roll as a chat message
		rollMode = rollMode || game.settings.get('core', 'rollMode');
		if (this.data.displayRoll) {
			await roll.toMessage(
				{
					speaker: speaker,
					flavor: `Draws a result from ${this.data.name}`,
				},
				{ rollMode }
			);
		}

		// Mark the result as drawn
		if (!this.data.replacement) {
			await this.updateEmbeddedEntity('TableResult', {
				_id: result._id,
				drawn: true,
			});
		}

		// Display the Drawn result
		await this._displayChatResult(result, speaker, rollMode);
		return result;
	}

	/* -------------------------------------------- */

	/**
	 * Display the result drawn from the table as a chat message
	 * @param {Object} result
	 * @param {Object} speaker
	 * @param {string} rollMode
	 * @return {ChatMessage}
	 * @private
	 */
	_displayChatResult(result, speaker, rollMode) {
		// Basic chat message data
		const chatData = {
			user: game.user._id,
			type: CONST.CHAT_MESSAGE_TYPES.OTHER,
			speaker: speaker,
		};

		// Toggle default roll mode
		if (['gmroll', 'blindroll'].includes(rollMode))
			chatData['whisper'] = ChatMessage.getWhisperIDs('GM');
		if (rollMode === 'blindroll') chatData['blind'] = true;
		if (rollMode === 'selfroll') chatData['whisper'] = [game.user.id];

		// Toggle the result format
		let text = result.text;
		if (result.type === CONST.TABLE_RESULT_TYPES.ENTITY) {
			text = `@${result.collection}[${result.text}]`;
		}

		// Render the template
		chatData['content'] = `
    <div class="table-result" data-table-id="${this._id}" data-result-id="${
			result._id
		}">
        <img class="result-image" src="${result.img ||
			CONFIG.RollTable.resultIcon}"/>
        <h4 class="result-text">${text}</h4>
    </div>`;

		// Create the chat message
		return ChatMessage.create(chatData);
	}

	/* -------------------------------------------- */

	/**
	 * Normalize the probabilities of rolling each item in the RollTable based on their assigned weights
	 * @return {Promise}
	 */
	async normalize() {
		const results = duplicate(this.data.results);
		const totalWeight = results.reduce(
			(total, result) => total + result.weight,
			0
		);
		let counter = 1;
		for (let r of results) {
			r.range = [counter, counter + r.weight - 1];
			counter = counter + r.weight;
		}
		return this.update({ results: results, formula: `1d${totalWeight}` });
	}

	/* -------------------------------------------- */

	/**
	 * Reset the state of the RollTable to return any drawn items to the table
	 * @return {Promise}
	 */
	async reset() {
		const results = duplicate(this.data.results);
		for (let r of results) {
			r.drawn = false;
		}
		return this.update({ results });
	}

	/* -------------------------------------------- */

	/**
	 * Evaluate a RollTable, returning a the drawn result
	 * @returns {Array}     An Array, containing the Roll and the result
	 */
	roll() {
		// Identify the set of results which may be drawn
		const available = this.data.results.filter(r => !r.drawn);

		// Ensure that at least one non-drawn result remains
		if (!this.data.formula || !available.length) {
			ui.notifications.warn(
				'There are no available results which can be drawn from this table.'
			);
			return [null, null];
		}

		// Ensure that results are available within the minimum/maximum range
		const minRoll = Roll.minimize(this.data.formula).total;
		const maxRoll = Roll.maximize(this.data.formula).total;
		const availableRange = available.reduce(
			(range, result) => {
				if (!range[0] || result.range[0] < range[0])
					range[0] = result.range[0];
				if (!range[1] || result.range[1] > range[1])
					range[1] = result.range[1];
				return range;
			},
			[null, null]
		);
		if (availableRange[0] > maxRoll || availableRange[1] < minRoll) {
			ui.notifications.warn(
				'No results can possibly be drawn from this table and formula.'
			);
			return [null, null];
		}

		// Roll until a valid result is recovered
		let result = null;
		let roll = null;
		while (result === null) {
			roll = new Roll(this.data.formula).roll();
			let r = this.data.results.find(r =>
				Number.between(roll.total, ...r.range)
			);
			if (r && !r.drawn) result = r;
		}

		// If the result is a RollTable, roll recursively
		if (
			result.type === CONST.TABLE_RESULT_TYPES.ENTITY &&
			result.collection === 'RollTable'
		) {
			const innerTable = game.tables.get(result.resultId);
			if (innerTable) {
				let [iRoll, iResult] = innerTable.roll();
				if (iResult) {
					result = mergeObject(iResult, { _id: result._id });
				}
			}
		}

		// Return the Roll and the result
		return [roll, result];
	}

	/* -------------------------------------------- */
	/*  Table Result Management Methods             */
	/* -------------------------------------------- */

	/** @extends {Entity.getEmbeddedEntity} */
	getTableResult(id) {
		return this.getEmbeddedEntity('TableResult', id);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity.createEmbeddedEntity}
	 * @deprecated
	 */
	async createTableResult(data, options) {
		console.warn(
			'You are using RollTable.createTableResult() which is deprecated in favor of the generalized Entity.createEmbeddedEntity() method'
		);
		return this.createEmbeddedEntity('TableResult', data, options);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity.updateEmbeddedEntity}
	 * @deprecated
	 */
	async updateTableResult(data, options) {
		console.warn(
			'You are using RollTable.updateTableResult() which is deprecated in favor of the generalized Entity.updateEmbeddedEntity() method'
		);
		return this.updateEmbeddedEntity('TableResult', data, options);
	}

	/* -------------------------------------------- */

	/**
	 * @extends {Entity.deleteEmbeddedEntity}
	 * @deprecated
	 */
	async deleteTableResult(id, options) {
		console.warn(
			'You are using RollTable.deleteTableResult() which is deprecated in favor of the generalized Entity.deleteEmbeddedEntity() method'
		);
		return this.deleteEmbeddedEntity('TableResult', id, options);
	}
}

CONFIG.RollTable.collection = RollTables;
CONFIG.RollTable.entityClass = RollTable;

/**
 * The collection of User entities which is accessible through ``game.users``.
 * The array of User entities within this collection is accessible through ``game.users.entities``.
 * @type {Collection}
 */
class Users extends Collection {
	/**
	 * Elements of the Users collection are instances of the User class
	 * @return {User}
	 */
	get object() {
		return User;
	}

	/**
	 * Get the users with player roles
	 * @return {Array.<User>}
	 */
	get players() {
		return this.entities.filter(
			u => u.isRole('PLAYER') || u.isRole('TRUSTED')
		);
	}
}

/* -------------------------------------------- */

/**
 * The User entity
 * Each player who connects to a Foundry Virtual Tabletop session is a User. 
 * Users represent human beigns (or possibly programmatic players) and are the cornerstone of identity in Foundry VTT.
 * @type {Entity}
 * 
 * @param {Object} data           The source data for the User entity, usually retrieved from the database.
 * @param {string} data._id       The Entity ID, automatically generated by the Database when a new User is created.
 * @param {string} data.password  An access key for the Entity.
 * @param {number} data.role      The role level for the User, from CONST.USER_ROLES
 * @param {Object} data.permissions  An object of key-value permissions for the User which extend the default functionality
                                  of the User's role.
 * @param {string} data.avatar    A web-accessible file path to an avatar image used to represent the User.
 * @param {string} data.scenes    The _id of the Scene entity that the User is currently viewing.
 * @param {string} data.character The _id of the Actor entity that the User has chosen as their primary character.
 * @param {string} data.color     A color string which represents the visual color associated with this particular User.
 * @param {Object} data.flags     A free-form object of key-value pairs which allows modules and systems the ability 
                                  to store arbitrary data as part of the User object.    
 * @param {Object} options        Initialization options which modify the construction of a User entity. See the Entity
                                  class for more detail.
 */
class User extends Entity {
	constructor(data, options) {
		super(data, options);

		/**
		 * Track references to the current set of Tokens which are targeted by the User
		 * @type {Set.<Token>}
		 */
		this.targets = new UserTargets(this);
	}

	/* ---------------------------------------- */
	/*  Properties                              */
	/* ---------------------------------------- */

	/** @override */
	static get config() {
		return {
			baseEntity: User,
			collection: game.users,
			embeddedEntities: {},
		};
	}

	/* -------------------------------------------- */

	/**
	 * Return the User avatar icon or the controlled actor's image
	 * @type {String}
	 */
	get avatar() {
		return (
			this.data.avatar ||
			(this.character ? this.character.img : CONST.DEFAULT_TOKEN)
		);
	}

	/**
	 * Return the Actor instance of the user's impersonated character (or undefined)
	 * @type {Actor}
	 */
	get character() {
		return game.actors.get(this.data.character);
	}

	/**
	 * Return a flag for whether this User is currently active
	 * @type {Boolean}
	 */
	get active() {
		return this.data.active;
	}

	/**
	 * @override
	 * @deprecated
	 */
	get permission() {
		console.warn(
			'User.permission is DEPRECATED in 0.4.0. Migrate to User.role from CONST.USER_ROLES instead'
		);
		return this.data.role;
	}

	/**
	 * A convenience shortcut for the permissions object of the current User
	 * @type {Object}
	 */
	get permissions() {
		return this.data.permissions;
	}

	/* ---------------------------------------- */

	/**
	 * A flag for whether the current User is a Trusted Player
	 * @return {Boolean}
	 */
	get isTrusted() {
		return this.hasRole('TRUSTED');
	}

	/* ---------------------------------------- */

	/**
	 * A flag for whether the current User has Assistant GameMaster or full GameMaster role
	 * @return {Boolean}
	 */
	get isGM() {
		return this.hasRole('ASSISTANT');
	}

	/* ---------------------------------------- */

	/**
	 * A flag for whether this User is the connected client
	 * @return {Boolean}
	 */
	get isSelf() {
		return game.userId === this._id;
	}

	/* ---------------------------------------- */
	/*  User Methods                            */
	/* ---------------------------------------- */

	/**
	 * Test whether the User has at least the permission level of a certain role
	 * @param {string|number} role     The role name from USER_ROLES to test
	 * @return {boolean}               Does the user have at least this role level?
	 */
	hasRole(role) {
		const level = typeof role === 'string' ? CONST.USER_ROLES[role] : role;
		return level && this.data.role >= level;
	}

	/* ---------------------------------------- */

	/**
	 * Test whether the User has exactly the permission level of a certain role
	 * @param {string|number} role     The role name from USER_ROLES to test
	 * @return {boolean}               Does the user have exactly this role level?
	 */
	isRole(role) {
		const level = typeof role === 'string' ? CONST.USER_ROLES[role] : role;
		return level && this.data.role === level;
	}

	/**
	 * Test whether the User has at least a specific permission
	 * @param {string} permissionName    The permission name from USER_PERMISSIONS to test
	 * @return {boolean}                 Does the user have at least this permission
	 */
	hasPermission(permissionName) {
		if (this.isGM) return true; // GMs cannot have any of their permissions revoked
		if (this.data.permissions.hasOwnProperty(permissionName))
			return this.data.permissions[permissionName];
		return this.hasRole(CONST.USER_PERMISSIONS[permissionName]);
	}

	/**
	 * Sets a user's permission
	 * Modifies the user permissions to grant or restrict access to a feature.
	 *
	 * @param {String} permission    The permission name from USER_PERMISSIONS
	 * @param {Boolean} allowed      Whether to allow or restrict the permission
	 */
	setPermission(permission, allowed) {
		this.update({ permissions: { [permission]: allowed } });
	}

	/* -------------------------------------------- */

	/**
	 * Assign a Macro to a numbered hotbar slot between 1 and 50
	 * @param {Macro|null} macro  The Macro entity to assign
	 * @param {number} slot       The integer Hotbar slot to fill
	 * @param {number} [fromSlot] An optional origin slot from which the Macro is being shifted
	 * @return {Promise}          A Promise which resolves once the User update is complete
	 */
	async assignHotbarMacro(macro, slot, { fromSlot = null } = {}) {
		if (!(macro instanceof Macro) && macro !== null)
			throw new Error('Invalid Macro provided');
		const hotbar = this.data.hotbar;

		// If a slot was not provided, get the first available slot
		slot = slot
			? parseInt(slot)
			: Array.fromRange(50).find(i => !(i in hotbar));
		if (!slot) throw new Error('No available Hotbar slot exists');
		if (slot < 1 || slot > 50)
			throw new Error('Invalid Hotbar slot requested');

		// Update the hotbar data
		const update = duplicate(hotbar);
		if (macro) update[slot] = macro.id;
		else {
			delete update[slot];
			update[`-=${slot}`] = null;
		}
		if (fromSlot && fromSlot in hotbar) {
			delete update[fromSlot];
			update[`-=${fromSlot}`] = null;
		}
		return this.update({ hotbar: update });
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Macro Entities on this User's Hotbar by page
	 * @param {number} page     The hotbar page number
	 * @return {Array.<Object>}
	 */
	getHotbarMacros(page = 1) {
		const macros = Array.fromRange(50).map(m => null);
		for (let [k, v] of Object.entries(this.data.hotbar)) {
			macros[parseInt(k) - 1] = v;
		}
		const start = (page - 1) * 10;
		return macros.slice(start, start + 10).map((m, i) => {
			return {
				slot: start + i + 1,
				macro: m ? game.macros.get(m) : null,
			};
		});
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Additional updating steps for the User entity when new data is saved which trigger some related updates.
	 *
	 * Re-draw the active cursor and toggle visibility
	 * Re-draw navigation if the active or viewed scenes have changed
	 * Render the players UI if activity status or other player features have changed
	 * Update the canvas if the player's impersonated character has changed
	 *
	 * @private
	 */
	_onUpdate(data, ...args) {
		super._onUpdate(data, ...args);

		// Get the changed attributes
		let changed = Object.keys(data).filter(k => k !== '_id');

		// Redraw Navigation
		if (changed.some(p => ['active', 'scene', 'color', 'role'].includes(p)))
			ui.nav.render();

		// Redraw Players UI
		if (
			changed.some(p =>
				['active', 'character', 'color', 'role'].includes(p)
			)
		)
			ui.players.render();

		// Redraw Hotbar
		if (changed.includes('hotbar')) ui.hotbar.render();

		// Inform WebRTC of user changes
		const webrtcChanges = ['avatar', 'character', 'permissions', 'role'];
		if (game.webrtc && changed.some(p => webrtcChanges.includes(p)))
			game.webrtc.settings.onSettingsChanged();

		// Initialize Scene controls
		if (changed.includes('role')) ui.controls.initialize();

		// Update Canvas
		if (canvas.ready) {
			// Redraw Cursor
			if (changed.includes('color')) {
				canvas.controls.drawCursor(this);
				const ruler = canvas.controls.getRulerForUser(this._id);
				if (ruler) ruler.color = colorStringToHex(data.color);
			}
			if (changed.includes('active'))
				canvas.controls.updateCursor(this, null);

			// Modify impersonated character
			if (changed.includes('character')) {
				canvas.sight.initialize();
				canvas.tokens.cycleTokens(1, true);
			}
		}
	}
}

/* -------------------------------------------- */

/**
 * A subclass of Set which manages the Token ids which the User has targeted
 * @extends {Set}
 * @private
 */
class UserTargets extends Set {
	constructor(user) {
		super();
		if (user.targets)
			throw new Error(
				`User ${user.id} already has a targets set defined`
			);
		this.user = user;
	}

	/** @override */
	add(token) {
		super.add(token);
		this._hook(token, true);
	}

	/** @override */
	clear() {
		const tokens = Array.from(this);
		super.clear();
		tokens.forEach(t => this._hook(t, false));
	}

	/** @override */
	delete(token) {
		super.delete(token);
		this._hook(token, false);
	}

	/**
	 * Dispatch the targetToken hook whenever the user's target set changes
	 */
	_hook(token, targeted) {
		Hooks.callAll('targetToken', this.user, token, targeted);
	}
}

/**
 * A helper class providing utility methods for PIXI Canvas animation
 */
class CanvasAnimation {
	static get ticker() {
		return canvas.app.ticker;
	}

	/* -------------------------------------------- */

	/**
	 * Apply a linear animation from the current value of some attribute to a new value
	 * Resolve a Promise once the animation has concluded and the attributes have reached their new target
	 * @param {Array} attributes  An array of attributes to animate. Structure of the Array is shown in the example
	 * @param {Container} context An animation context to use which defines scope
	 * @param {String} name       Provide a unique animation name which may be referenced later
	 * @param {Number} duration   The duration in milliseconds over which the animation should occur
	 * @param {Function} ontick   A function which defines additional behaviors to apply every animation frame
	 * @return {Promise}          A Promise which resolves once the linear animation has concluded
	 *
	 * @example
	 * let animation = [
	 *   {
	 *     parent: token,
	 *     attribute: x,
	 *     to: 1000
	 *   },
	 *   {
	 *     parent: token,
	 *     attribute: y,
	 *     to: 2000
	 *   }
	 * ];
	 * CanvasAnimation.animateLinear(attributes, {duration:500, ontick: console.log("ticking")});
	 */
	static async animateLinear(
		attributes,
		{ context, name = null, duration = 1000, ontick } = {}
	) {
		// Prepare attributes
		attributes = attributes
			.map(a => {
				a.delta = a.to - a.parent[a.attribute];
				a.remaining = Math.abs(a.delta);
				return a;
			})
			.filter(a => a.delta !== 0);

		// Register the request function and context
		context = context || canvas.stage;

		// Dispatch the animation request and return as a Promise
		return this._animatePromise(
			this._animateFrame,
			context,
			name,
			attributes,
			duration,
			ontick
		);
	}

	/* -------------------------------------------- */

	/**
	 * If an animation using a certain name already exists, terminate it
	 * @param {String} name
	 * @private
	 */
	static terminateAnimation(name) {
		let animation = this.animations[name];
		if (animation) {
			this.ticker.remove(...animation);
			delete this.animations[name];
		}
	}

	/* -------------------------------------------- */

	/**
	 * Asynchronously animate a transition function and resolve a Promise once the animation has completed
	 * @param {Function} fn         A suitable transition function. See PIXI.Ticker for details
	 * @param {Container} context   The Canvas container providing scope for the transition
	 * @param {String} name         Provide a unique animation name which may be referenced later
	 * @param {Array} args          Variable argument passed to the transition function each frame
	 * @return {Promise}            A Promise which resolves once the animation has completed
	 * @private
	 */
	static async _animatePromise(fn, context, name, ...args) {
		let animate;

		// Check for an existing named animation
		if (name) this.terminateAnimation(name);

		// Add the animation function to the Ticker
		return (
			new Promise((resolve, reject) => {
				animate = dt => fn(dt, resolve, reject, ...args);
				this.ticker.add(animate, context);
				if (name) this.animations[name] = [animate, context];
			})

				// Remove the animation function once resolved or rejected
				.then(() => {
					this.ticker.remove(animate, context);
					if (name) delete this.animations[name];
				})
				.catch(err => {
					console.error(err);
					this.ticker.remove(animate, context);
					if (name) delete this.animations[name];
				})
		);
	}

	/* -------------------------------------------- */

	/**
	 * Generic ticker function to implement the animation.
	 * This animation wrapper executes once per frame for the duration of the animation event.
	 * Once the animated attributes have converged to their targets, it resolves the original Promise.
	 * The user-provided ontick function runs each frame update to apply additional behaviors.
	 * @private
	 */
	static _animateFrame(
		deltaTime,
		resolve,
		reject,
		attributes,
		duration,
		ontick
	) {
		let complete = attributes.length === 0;
		let dt = (duration * PIXI.settings.TARGET_FPMS) / deltaTime;

		// Update each attribute
		try {
			for (let a of attributes) {
				let da = a.delta / dt;
				if (a.remaining < Math.abs(da) * 1.25) {
					a.parent[a.attribute] = a.to;
					a.remaining = 0;
					complete = true;
				} else {
					a.parent[a.attribute] += da;
					a.remaining -= Math.abs(da);
				}
			}
			if (ontick) ontick(dt, attributes);
		} catch (err) {
			reject(err);
		}

		// Resolve the original promise once the animation is complete
		if (complete) resolve();
	}
}

/**
 * Track an object of active animations by name, context, and function
 * This allows a currently playing animation to be referenced and terminated
 */
CanvasAnimation.animations = {};

/**
 * A generic helper for drawing a standard Control Icon
 * @type {PIXI.Container}
 */
class ControlIcon extends PIXI.Container {
	constructor(icon, ...args) {
		super(...args);
		this.draw(icon);
	}

	/* -------------------------------------------- */

	async draw({ texture, size = 40, borderColor = 0xff5500, tint = null }) {
		// Define hit area
		this.interactive = true;
		this.interactiveChildren = false;
		this.rect = [-2, -2, size + 4, size + 4];
		this.hitArea = new PIXI.Rectangle(...this.rect);

		// Background
		this.bg = this.addChild(this._drawBackground());

		// Icon
		this.texture = await loadTexture(texture);
		this.icon = this.addChild(this._drawIcon(this.texture, size, tint));

		// Border
		this.border = this.addChild(this._drawBorder(borderColor));
	}

	/* -------------------------------------------- */

	/**
	 * Draw the control background
	 * @private
	 */
	_drawBackground() {
		let bg = new PIXI.Graphics();
		bg.beginFill(0x000000, 0.4)
			.lineStyle(2, 0x000000, 1.0)
			.drawRoundedRect(...this.rect, 5)
			.endFill();
		return bg;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the icon image
	 * @private
	 */
	_drawIcon(texture, size, tint) {
		const icon = new PIXI.Sprite(texture);
		icon.width = icon.height = size;
		if (Number.isNumeric(tint)) icon.tint = tint;
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the control border
	 */
	_drawBorder(borderColor) {
		let border = new PIXI.Graphics();
		border
			.lineStyle(2, borderColor, 1.0)
			.drawRoundedRect(...this.rect, 5)
			.endFill();
		border.visible = false;
		return border;
	}
}
/**
 * A generic event and interaction handling framework for elements drawn on the PIXI canvas
 */
class HandleManager {
	constructor(
		handle,
		layer,
		handlers,
		{
			canhover = true,
			canclick = true,
			canright = true,
			candrag = true,
		} = {}
	) {
		if (
			!(handle instanceof PIXI.Container) &&
			!(handle instanceof PIXI.Graphics)
		) {
			throw new Error(
				'You may only use the Handle class on a Container or Graphics element.'
			);
		}

		/**
		 * The element for which interaction events are handled
		 * @type {PIXI.Container|PIXI.Graphics}
		 */
		this.handle = handle;

		/**
		 * The canvas layer within which handled events are tracked
		 * @type {CanvasLayer}
		 */
		this.layer = layer;

		/**
		 * The set of event handlers which are used for each interaction type
		 * @type {Object<Function>}
		 */
		this.handlers = this._validateHandlers(handlers);

		/**
		 * A set of permission checks
		 * @type {Object<Function>}
		 */
		this.permissions = {
			hover: canhover,
			click: canclick,
			right: canright,
			drag: candrag,
		};

		// Start with the mouseover event
		this.handle.interactive = true;
		this.handle.removeAllListeners();
		this.handle.on('mouseover', this._onMouseOver, this);
	}

	/* -------------------------------------------- */

	static get allowedHandlers() {
		return [
			'mouseover',
			'mouseout',
			'mousedown',
			'rightdown',
			'mousemove',
			'mouseup',
			'doubleleft',
			'doubleright',
			'cancel',
		];
	}

	/* -------------------------------------------- */

	/**
	 * Validate the set of user provided event handlers
	 * @param {Object} handlers
	 * @private
	 */
	_validateHandlers(handlers) {
		return this.constructor.allowedHandlers.reduce((h, ev) => {
			let fn = handlers[ev];
			if (fn && fn instanceof Function) h[ev] = fn;
			return h;
		}, {});
	}

	/* -------------------------------------------- */

	can(perm, event) {
		let can = this.permissions[perm];
		return can instanceof Function ? can(event) : can;
	}

	/* -------------------------------------------- */
	/*  Event Handlers
  /* -------------------------------------------- */

	/**
	 * Handle initial mouse-over event
	 * Activate additional downstream listeners for click events which may follow
	 * Mouse-over events DO NOT stop propagation as it is possible to hover over multiple entities at once
	 * @private
	 */
	_onMouseOver(event) {
		if (event.data.handleState > 0) return;

		// Handle only if hover is permitted
		if (!this.can('hover', event)) return;

		// Deactivate any existing listeners
		this.handle
			.off('mouseout')
			.off('mousedown')
			.off('rightdown');

		// Add listeners for mousedown, rightdown, and mouseout events
		this.handle
			.once('mouseout', this._onMouseOut, this)
			.on('mousedown', this._onMouseDown, this)
			.on('rightdown', this._onRightDown, this);

		// Assign event data and call the provided handler
		event.data.handle = this.handle;
		if (this.handlers.mouseover) this.handlers.mouseover(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out events
	 * Mouse-out events DO NOT stop propagation as it is possible to unhover multiple entities at once
	 * @private
	 */
	_onMouseOut(event) {
		if (event.data.handleState > 0) return;
		event.data.handle = this.handle;
		if (this.handlers.mouseout) this.handlers.mouseout(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-click events
	 * Record the time of each click to activate a double-click within a certain threshold
	 * Activate a layer-level listener for the mousemove event
	 * @private
	 */
	_onMouseDown(event) {
		// Test whether the user can trigger the click event
		const canClick = this.can('click', event);
		if (!canClick) return;

		// Stop further propagation and record handle state
		event.stopPropagation();
		if (event.data.handleState > 0) return;

		// Clear existing move handler
		this.layer.off('mousemove');

		// Populate event data
		event.data.handleState = 0;
		event.data.handle = this.handle;
		event.data.origin = event.data.getLocalPosition(this.layer);

		// Check click time
		let now = Date.now();
		if (now - event.data.lClickTime <= 250 && this.handlers.doubleleft) {
			return this.handlers.doubleleft(event);
		}
		event.data.lClickTime = now;

		// Call the user provided mouse-down handler
		if (this.handlers.mousedown) this.handlers.mousedown(event);

		// Activate downstream listeners for mouse movement and release
		this._layerInteractive = this.layer.interactive;
		this.layer.interactive = true;
		this.handle.off('mouseup').off('mouseupoutside');
		if (this.can('drag', event)) {
			this.layer.on('mousemove', this.handlers.mousemove, this);
			this.handle
				.once('mouseup', this._onMouseUp, this)
				.once('mouseupoutside', this._onMouseUp, this);
			canvas.app.view.addEventListener(
				'contextmenu',
				ev => this._onMouseMoveCancel(event),
				{ once: true }
			);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-click events
	 * Record the time of each click to activate a double-click within a certain threshold
	 * @private
	 */
	_onRightDown(event) {
		if (!this.can('right', event)) return;
		event.stopPropagation();
		if (event.data.handleState > 0) return;

		// Populate event data
		event.data.handleState = 0;
		event.data.handle = this.handle;

		// Check click time
		let now = Date.now();
		if (now - event.data.rClickTime <= 250 && this.handlers.doubleright) {
			return this.handlers.doubleright(event);
		}
		event.data.rClickTime = now;

		// Call user-provided right click handler
		if (this.handlers.rightdown) this.handlers.rightdown(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse movement events while the workflow is active
	 * @private
	 */
	_onMouseMove(event) {
		if (event.data.handleState === 0) return;
		if (this.handlers.mousemove) this.handlers.mousemove(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-up events
	 * Deactivate layer-level listener for the mousemove event
	 * @private
	 */
	_onMouseUp(event) {
		event.stopPropagation();

		// Deactivate listeners
		this.layer.interactive = this._layerInteractive;
		delete this._layerInteractive;
		this.layer.off('mousemove');
		this.handle.off('mouseup').off('mouseupoutside');

		// Get ending position and call the mouse-up handler
		if (event.data.handleState > 0) {
			event.data.destination = event.data.getLocalPosition(this.layer);
		}
		if (this.handlers.mouseup) this.handlers.mouseup(event);
		event.data.handleState = 0;
	}

	/* -------------------------------------------- */

	/**
	 * Handle right-click cancellation of a mouse move event
	 * @private
	 */
	_onMouseMoveCancel(event) {
		event.stopPropagation();
		if (event.data.handleState > 0) {
			event.data.handleState = 0;

			// Deactivate listeners
			this.layer.interactive = this._layerInteractive;
			delete this._layerInteractive;
			this.layer.off('mousemove');
			this.handle.off('mouseup').off('mouseupoutside');

			// Call user-provided handler
			if (this.handlers.cancel) this.handlers.cancel(event);
		}
	}
}

const RESOURCE_LOADER_OPTIONS = {
	autoLoad: true,
	autoPlay: false,
	crossOrigin: 'anonymous',
	crossorigin: 'anonymous',
};

/**
 * Get a single texture from the cache
 * @param {String} src
 * @return {PIXI.Texture}
 */
function getTexture(src) {
	// Pull the resource from the loader cache
	const loader = PIXI.Loader.shared;
	let cached = loader.resources[src];
	if (!cached) return null;

	// Load from cache
	let bt = cached.texture
		? cached.texture
		: PIXI.BaseTexture.from(cached.data, {
				resourceOptions: RESOURCE_LOADER_OPTIONS,
		  });
	return new PIXI.Texture(bt);
}

/* -------------------------------------------- */

/**
 * Load a single texture and return a Promise which resolves once the texture is ready to use
 * @param {String} src
 * @return {PIXI.Texture|PIXI.VideoBaseTexture}
 */
async function loadTexture(src) {
	// First try to load the resource from the cache
	let tex = getTexture(src);
	if (tex) return tex;

	// FIX: Pre-check any video textures since GET 404 errors are not currently handled by the resource loader
	// https://github.com/pixijs/pixi.js/issues/5336
	if (VideoHelper.hasVideoExtension(src)) {
		if (!(await srcExists(src)))
			return Promise.reject(`Failed to load texture ${src}`);
	}

	// Otherwise load it and wait for loading to resolve
	tex = PIXI.Texture.from(src, { resourceOptions: RESOURCE_LOADER_OPTIONS });

	// Return the ready texture as a Promise
	return new Promise((resolve, reject) => {
		let base = tex.baseTexture;
		if (base.valid) resolve(tex);
		base.once('loaded', f => resolve(tex));
		base.once('error', base => {
			let err = new Error(`Failed to load texture ${base.resource.url}`);
			delete PIXI.Loader.shared.resources[base.resource.url];
			reject(err);
		});
	});
}

/* -------------------------------------------- */

/**
 * Load all the primary textures which are required in order to render a Scene
 * @param scene {Scene}
 * @return {Promise}
 */
async function loadSceneTextures(scene) {
	const loader = PIXI.Loader.shared,
		sd = scene.data;

	// Construct an Array of resources to load
	let toLoad = [];

	// Scene background image
	let bg = sd.img;
	if (bg) toLoad.push(bg);

	// Placeable tiles
	toLoad = toLoad.concat(sd.tiles.filter(t => t.img).map(t => t.img));

	// Tokens
	toLoad = toLoad.concat(sd.tokens.filter(t => t.img).map(t => t.img));

	// Create unique array
	toLoad = new Array(
		...new Set(toLoad.filter(t => !loader.resources.hasOwnProperty(t)))
	);

	// BUGFIX: Pre-check any video textures since GET 404 errors are not currently handled by the resource loader
	// https://github.com/pixijs/pixi.js/issues/5336
	const valid = [];
	for (let f of toLoad) {
		if (VideoHelper.hasVideoExtension(f) && !(await srcExists(f))) continue;
		valid.push(f);
	}

	// Add resources to the loader
	loader.add(valid, RESOURCE_LOADER_OPTIONS);

	// Begin load
	return new Promise((resolve, reject) => {
		loader.removeAllListeners();

		// Progress handlers
		loader.on('progress', (loader, resource) => {
			// Create video textures
			if (resource.data && resource.data.tagName === 'VIDEO') {
				// BUGFIX: Wait for the video to begin playing before creating the texture
				// https://github.com/pixijs/pixi.js/issues/5996
				resource.texture = PIXI.Texture.from(resource.data, {
					resourceOptions: RESOURCE_LOADER_OPTIONS,
				});
			}

			// Log progress
			let pct = Math.round(loader.progress * 10) / 10;
			console.log(`${vtt} | Loaded ${resource.name} (${pct}%)`);
		});

		// Error handlers
		loader.on('error', (loader, resources, resource) => {
			console.warn(`${vtt} | Texture load failed for ${resource.name}`);
		});

		// Trigger the load
		loader.load((loader, resources) => {
			resolve(resources);
		});
	});
}

/* -------------------------------------------- */

async function srcExists(src) {
	return fetch(src, { method: 'HEAD' })
		.then(resp => {
			return resp.status < 400;
		})
		.catch(err => false);
}

/**
 * A ray for the purposes of computing sight and collision
 * Given points A[x,y] and B[x,y]
 *
 * Slope-Intercept form:
 * y = a + bx
 * y = A.y + ((B.y - A.Y) / (B.x - A.x))x
 *
 * Parametric form:
 * R(t) = (1-t)A + tB
 */
class Ray {
	constructor(A, B) {
		// Store points
		this.A = A;
		this.B = B;

		// Origins
		this.y0 = A.y;
		this.x0 = A.x;

		// Slopes
		this.dx = B.x - A.x;
		this.dy = B.y - A.y;

		/**
		 * The slope of the ray, dy over dx
		 * @type {number}
		 */
		this.slope = this.dy / this.dx;

		/**
		 * The normalized angle of the ray in radians on the range (-PI, PI)
		 * @type {number}
		 */
		this.angle = Math.atan2(this.dy, this.dx);

		/**
		 * The distance of the ray
		 * @type {number}
		 */
		this.distance = Math.sqrt(Math.pow(this.dx, 2) + Math.pow(this.dy, 2));
	}

	/* -------------------------------------------- */

	/**
	 * Return the value of the angle normalized to the range (0, 2*PI)
	 * This is useful for testing whether an angle falls between two others
	 * @type {number}
	 */
	get normAngle() {
		let a = this.angle % (2 * Math.PI);
		return a < 0 ? a + 2 * Math.PI : a;
	}

	/* -------------------------------------------- */

	static fromAngle(x, y, radians, distance) {
		let dx = Math.cos(radians),
			dy = Math.sin(radians);
		return Ray.fromArrays([x, y], [x + dx * distance, y + dy * distance]);
	}

	/* -------------------------------------------- */

	static fromArrays(A, B) {
		return new this({ x: A[0], y: A[1] }, { x: B[0], y: B[1] });
	}

	/* -------------------------------------------- */

	/**
	 * Project the Array by some proportion of it's initial distance.
	 * Return the coordinates of that point along the path.
	 * @param {number} t    The distance along the Ray
	 * @return {Object}     The coordinates of the projected point
	 */
	project(t) {
		return {
			x: this.A.x + t * this.dx,
			y: this.A.y + t * this.dy,
		};
	}

	/* -------------------------------------------- */

	shiftAngle(angleOffset, distance) {
		return Ray.fromAngle(
			this.x0,
			this.y0,
			this.angle + angleOffset,
			distance || this.distance
		);
	}

	/* -------------------------------------------- */

	/**
	 * Find the point I[x,y] and distance t* on ray R(t) which intersects another ray
	 * http://paulbourke.net/geometry/pointlineplane/
	 */
	intersectSegment(coords) {
		return this.constructor._getIntersection(
			this.A.x,
			this.A.y,
			this.B.x,
			this.B.y,
			...coords
		);
	}

	static _getIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
		let e = 1e-12;

		// Length 0 === false
		if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
			return false;
		}

		// Check denominator - avoid parallel lines where d = 0
		let d = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		if (d === 0) {
			return false;
		}

		// Get vector distances
		let t0 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / d;
		let t1 = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / d;

		// Confirm the solution lies within both segments
		const collides =
			Number.between(t0, 0 - e, 1 + e) &&
			Number.between(t1, 0 - e, 1 + e);
		if (!collides) return false;

		// Return an objects with the point of intersection and the distance from the origin
		return {
			x: x1 + t0 * (x2 - x1),
			y: y1 + t0 * (y2 - y1),
			t0: t0,
			t1: t1,
		};
	}
}

/**
 * A PIXI.Container subclass of CanvasLayer responsible for rendering the scene background image.
 * The singleton instance of this class is accessed through ``canvas.background``.
 *
 * @type {CanvasLayer}
 */
class BackgroundLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * The background image
		 * @type {PIXI.Sprite}
		 */
		this.img = null;
	}

	/**
	 * Customize behaviors of this PlaceablesLayer by modifying some behaviors at a class level
	 * @return {Object}
	 */
	static get layerOptions() {
		return {
			canDragCreate: false,
			snapToGrid: false,
		};
	}

	/* -------------------------------------------- */
	/*  Properties and Attributes
  /* -------------------------------------------- */

	/**
	 * Return the base HTML element which is used to generate the Scene background
	 * @return {HTMLElement}
	 */
	get source() {
		if (!this.img) return null;
		let bt = this.img.texture.baseTexture;
		if (!bt.valid) return null;
		return bt.resource.source;
	}

	/* -------------------------------------------- */

	/**
	 * Return a Boolean flag for whether the Scene background texture is a Video element
	 * @return {Boolean}
	 */
	get isVideo() {
		let source = this.source;
		return source && source.tagName === 'VIDEO';
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the background image.
	 * We first load the image texture and store it in the PIXI loader.
	 * Once the requested image has been fully loaded we draw it as a PIXI.Sprite
	 *
	 * @return {Promise.<BackgroundLayer>}    Returns the instance of the Background Layer for convenient chaining
	 */
	async draw() {
		if (this.img) {
			this.img.destroy({ texture: false, baseTexture: false });
			this.img = null;
		}
		if (!canvas.scene.data.img) return;

		// Load the background texture
		let tex = getTexture(canvas.scene.data.img);

		// If the canvas does not have dimensions set - push them and restart the process
		let scene = canvas.scene;
		if (!scene.data.width || !scene.data.height) {
			canvas.scene.update(
				{ width: tex.orig.width, height: tex.orig.height },
				true
			);
		}

		// Create the background Sprite
		let d = canvas.dimensions,
			bg = new PIXI.Sprite(tex);

		// Otherwise configure the bg position and dimensions
		bg.position.set(d.paddingX - d.shiftX, d.paddingY - d.shiftY);
		bg.width = canvas.scene.data.width;
		bg.height = canvas.scene.data.height;

		// Add the background sprite to the layer
		this.img = this.addChild(bg);

		// Ensure playback state for video backgrounds
		if (this.isVideo) {
			this.source.loop = true;
			this.source.volume = game.settings.get(
				'core',
				'globalAmbientVolume'
			);
			game.video.play(this.source);
		}

		// Return the layer
		return this;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * The BackgroundLayer can never be active
	 */
	activate() {
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Create a 300px by 100px thumbnail image for this scene background
	 * @param {String} texture  The background texture path
	 * @return {String}         base64 image data
	 */
	static async createThumbnail(texture) {
		if (!texture) return null;
		texture = await loadTexture(texture);

		// Create the image
		let img = new PIXI.Sprite(texture);
		let ratio = texture.width / texture.height;
		if (ratio > 3) {
			img.height = 100;
			img.width = 100 * ratio;
		} else {
			img.width = 300;
			img.height = 300 / ratio;
		}

		// Mask the center to crop it to a RenderTexture
		img.position.set((300 - img.width) / 2, (100 - img.height) / 2);
		let tex = PIXI.RenderTexture.create(
			300,
			100,
			PIXI.SCALE_MODES.LINEAR,
			2
		);
		canvas.app.renderer.render(img, tex);

		// Export the rendered texture to base64
		let thumb = new PIXI.Sprite(tex),
			data = canvas.app.renderer.extract.base64(thumb);
		tex.destroy(true);

		// Return the image data
		return {
			width: texture.width,
			height: texture.height,
			thumb: data,
		};
	}
}

/**
 * The DrawingsLayer subclass of :class:`PlaceablesLayer`
 *
 * This layer implements a container for drawings which are rendered immediately above the :class:`TilesLayer`
 * and immediately below the :class:`GridLayer`
 *
 * @type {PlaceablesLayer}
 */
class DrawingsLayer extends PlaceablesLayer {
	/**
	 * Customize behaviors of this PlaceablesLayer by modifying some behaviors at a class level
	 * @return {Object}
	 */
	static get layerOptions() {
		return {
			canDragCreate: true,
			controllableObjects: true,
			rotatableObjects: true,
			snapToGrid: true,
		};
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/**
	 * Define the source data array underlying the placeable objects contained in this layer
	 * @type {Array}
	 */
	static get dataArray() {
		return 'drawings';
	}

	/**
	 * Reference the PlaceableObject used to draw objects within this Layer
	 * @type {PlaceableObject}
	 */
	static get placeableClass() {
		return Drawing;
	}

	/**
	 * Use an adaptive precision depending on the size of the grid
	 * @type {Number}
	 */
	get gridPrecision() {
		let size = canvas.dimensions.size;
		if (size >= 128) return 16;
		else if (size >= 64) return 8;
		else if (size >= 32) return 4;
		else if (size >= 16) return 2;
	}

	/**
	 * Drawing objects on this layer utilize the DrawingHUD
	 */
	get hud() {
		return canvas.hud.drawing;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Render a configuration sheet to configure the default Drawing settings
	 */
	configureDefault() {
		const defaults = this._getNewDrawingData({});
		let d = new Drawing(defaults);
		new DrawingConfig(d, { configureDefault: true }).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Override the deactivation behavior of this layer.
	 * Placeables on this layer remain visible even when the layer is inactive.
	 */
	deactivate() {
		super.deactivate();
		if (this.objects) this.objects.visible = true;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Extend handling of mouse-down events during a drag creation workflow
	 * @private
	 */
	_onMouseDown(event, options) {
		const { object, createState, clickTime, originalEvent } = event.data;
		if (createState >= 1 && object.isPolygon) {
			event.stopPropagation();

			// Determine the destination point
			let destination = event.data.destination;
			if (!originalEvent.shiftKey) {
				destination = canvas.grid.getSnappedPosition(
					destination.x,
					destination.y,
					this.gridPrecision
				);
			}

			// Add a new point to the Polygon
			object._addPoint(destination, false);

			// Conclude Polygon placement on double-click
			let now = Date.now();
			if (now - clickTime < 250) {
				event.data.createState = 2;
				this._onDragCreate(event);
			}
			event.data.clickTime = now;

			// Refresh the drawing
			object.refresh();
		} else super._onMouseDown(event, options);
	}

	/* -------------------------------------------- */

	/**
	 * Handling of mouse-up events which conclude a new object creation after dragging
	 * @private
	 */
	_onMouseUp(event) {
		const { createState, object } = event.data;
		if (createState === 2) {
			event.stopPropagation();
			this._onDragCreate(event);
			event.data.createState = 0;
		}

		// If the mouse if released before a creation completes, cancel it for non-polygons
		else if (createState === 1) {
			event.stopPropagation();
			if (!object.isPolygon) this._onDragCancel(event);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of drag start events by left click + dragging
	 * @private
	 */
	_onDragStart(event) {
		super._onDragStart(event);

		// Create temporary Drawing
		const data = this._getNewDrawingData(event.data.origin);
		const drawing = new Drawing(data);
		drawing.draw();

		// Display the Drawing as a preview object
		event.data.object = this.preview.addChild(drawing);
	}

	/* -------------------------------------------- */

	/**
	 * Get initial data for a new drawing.
	 * Start with some global defaults, apply user default config, then apply mandatory overrides per tool.
	 * @param {Object} origin     The initial coordinate
	 * @return {Object}           The new drawing data
	 * @private
	 */
	_getNewDrawingData(origin) {
		const tool = game.activeTool;

		// Initial Defaults
		const data = {
			fillType: CONST.DRAWING_FILL_TYPES.NONE,
			fillColor: game.user.color,
			fillAlpha: 0.5,
			strokeAlpha: 1.0,
			strokeWidth: 8,
			strokeColor: game.user.color,
			fontFamily: CONFIG.defaultFontFamily,
			fontSize: 48,
		};

		// Update with User Defaults
		const userDefault = game.settings.get(
			'core',
			this.constructor.DEFAULT_CONFIG_SETTING
		);
		for (let [k, v] of Object.entries(userDefault)) {
			if (v === '') delete userDefault[k];
		}
		mergeObject(data, userDefault);

		// Mandatory Overrides
		mergeObject(data, {
			author: game.user._id,
			x: origin.x,
			y: origin.y,
		});

		// Tool-based settings
		switch (tool) {
			case 'rect':
				data.type = CONST.DRAWING_TYPES.RECTANGLE;
				break;
			case 'ellipse':
				data.type = CONST.DRAWING_TYPES.ELLIPSE;
				break;
			case 'polygon':
				data.type = CONST.DRAWING_TYPES.POLYGON;
				data.points = [[0, 0]];
				break;
			case 'freehand':
				data.type = CONST.DRAWING_TYPES.FREEHAND;
				data.points = [[0, 0]];
				break;
		}
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Extend handling of mouse move events during a dragging workflow
	 * @private
	 */
	_onMouseMove(event) {
		super._onMouseMove(event);
		const { object, createState } = event.data;
		if (createState >= 1) {
			object._onMouseDraw(event);

			// Moving the mouse is enough for any drawing type **except** polygon to be eligible for creation
			if (object.data.type !== CONST.DRAWING_TYPES.POLYGON)
				event.data.createState = 2;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Extend the drag creation workflow step to create a new Drawing using the provided data
	 * @param {PIXI.interaction.InteractionEvent}
	 * @private
	 */
	_onDragCreate(event) {
		const { object, origin, destination } = event.data;
		let distance = Math.hypot(
			destination.x - origin.x,
			destination.y - origin.y
		);
		let hasDistance =
			distance >= canvas.dimensions.size / this.gridPrecision;
		if (
			hasDistance ||
			(object.isPolygon && object.data.points.length > 2)
		) {
			object.constructor.create(canvas.scene._id, object.data);
		}
		this._onDragCancel(event);
	}
}

// Configuration Setting
DrawingsLayer.DEFAULT_CONFIG_SETTING = 'defaultDrawingConfig';

/**
 * A CanvasLayer for displaying visual effects like weather, transitions, flashes, or more
 * @type {CanvasLayer}
 */
class EffectsLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * The weather overlay container
		 * @type {PIXI.Container}
		 */
		this.weather = null;

		/**
		 * The currently active weather effect
		 * @type {SpecialEffect}
		 */
		this.weatherEffect = null;

		/**
		 * Track any active emitters within this Scene
		 * @type {Array}
		 */
		this.emitters = [];
	}

	/* -------------------------------------------- */

	async draw() {
		// Draw the weather layer
		this.drawWeather();
	}

	/* -------------------------------------------- */

	drawWeather() {
		if (this.weatherEffect) this.weatherEffect.stop();
		if (!this.weather) this.weather = this.addChild(new PIXI.Container());

		// Get the requested weather effect
		const effect = CONFIG.weatherEffects[canvas.scene.data.weather];
		if (!effect) return;

		// Create the effect and begin playback
		this.weatherEffect = new effect(this.weather);
		this.weatherEffect.play();
	}
}

/**
 * The Ambient Lighting Container
 * @extends {PlaceablesLayer}
 */
class LightingLayer extends PlaceablesLayer {
	constructor() {
		super();
	}

	/* -------------------------------------------- */

	/** @extends {PlaceablesLayer.layerOptions} */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			rotatableObjects: true,
		});
	}

	/** @override */
	static get dataArray() {
		return 'lights';
	}

	/** @override */
	static get placeableClass() {
		return AmbientLight;
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the PlaceablesLayer.
	 * Draw each Sound within the scene as a child of the sounds container.
	 */
	async draw() {
		await super.draw();
	}

	/* -------------------------------------------- */

	/**
	 * Override the activation behavior of the PlaceablesLayer.
	 * While active, ambient sound previews are displayed.
	 */
	activate() {
		super.activate();
		if (this.objects) {
			this.placeables.forEach(p => {
				p.controlIcon.visible = true;
				p.field.light.visible = true;
				p.field.lines.visible = true;
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Override the deactivation behavior of the PlaceablesLayer.
	 * Keep templates visible, even when the layer is inactive.
	 */
	deactivate() {
		super.deactivate();
		if (this.objects) {
			this.objects.visible = true;
			this.placeables.forEach(p => {
				p.controlIcon.visible = false;
				p.field.light.visible = p.hasTint;
				p.field.lines.visible = false;
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the FOV polygon for all Ambient Lighting placeables in the layer
	 */
	initialize() {
		this.placeables.forEach(s => s.refresh());
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Default handling of drag start events by left click + dragging
	 * @private
	 */
	_onDragStart(event) {
		super._onDragStart(event);
		let origin = event.data.origin,
			light = new AmbientLight({
				x: origin.x,
				y: origin.y,
				type: 'l',
			}).draw();
		event.data.object = this.preview.addChild(light);
	}

	/* -------------------------------------------- */

	/**
	 * Default handling of mouse move events during a dragging workflow
	 * @private
	 */
	_onMouseMove(event) {
		super._onMouseMove(event);
		if (event.data.createState >= 1) {
			let light = event.data.object;
			let radius = Math.hypot(
				event.data.destination.x - event.data.origin.x,
				event.data.destination.y - event.data.origin.y
			);
			light.data.dim =
				radius * (canvas.dimensions.distance / canvas.dimensions.size);
			light.data.bright = light.data.dim / 2;
			light.refresh();
			event.data.createState = 2;
		}
	}
}

/**
 * The Notes Layer Container
 * @extends {PlaceablesLayer}
 */
class NotesLayer extends PlaceablesLayer {
	/** @extends {PlaceablesLayer.layerOptions} */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			canDragCreate: false,
		});
	}

	/** @override */
	static get dataArray() {
		return 'notes';
	}

	/** @override */
	static get placeableClass() {
		return Note;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/** @extends {PlaceablesLayer.activate} */
	activate() {
		super.activate();
		if (this.objects) {
			this.placeables.forEach(p => (p.controlIcon.visible = true));
		}
	}

	/* -------------------------------------------- */

	/** @extends {PlaceablesLayer.deactivate} */
	deactivate() {
		super.deactivate();
		const isToggled = game.settings.get(
			'core',
			this.constructor.TOGGLE_SETTING
		);
		if (this.objects) {
			this.objects.visible = isToggled;
			this.placeables.forEach(p => (p.controlIcon.visible = isToggled));
		}
		this.interactiveChildren = isToggled;
	}

	/* -------------------------------------------- */

	/**
	 * Register game settings used by the NotesLayer
	 */
	static registerSettings() {
		game.settings.register('core', this.TOGGLE_SETTING, {
			name: 'Map Note Toggle',
			scope: 'client',
			type: Boolean,
			config: false,
			default: false,
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onMouseDown(event) {}

	/* -------------------------------------------- */

	/**
	 * Handle JournalEntry entity drop data
	 * @param {Event} event
	 * @param {JournalEntry} entry
	 * @private
	 */
	_onDropEntity(event, entry) {
		// Get the world-transformed drop position
		let t = this.worldTransform,
			tx = (event.clientX - t.tx) / canvas.stage.scale.x,
			ty = (event.clientY - t.ty) / canvas.stage.scale.y,
			[x, y] = canvas.grid.getCenter(tx, ty);

		// Create Note data
		const data = {
			entryId: entry.data._id,
			x: x,
			y: y,
			icon: CONST.DEFAULT_NOTE_ICON,
			iconSize: 40,
			textAnchor: CONST.TEXT_ANCHOR_POINTS.BOTTOM,
			fontSize: 48,
		};

		// Validate the final position is in-bounds
		if (!canvas.grid.hitArea.contains(data.x, data.y)) return false;

		// Create a NoteConfig sheet instance to finalize the creation
		this.activate();
		const note = this.preview.addChild(new Note(data).draw());
		note.sheet.render(true);
	}
}

NotesLayer.TOGGLE_SETTING = 'notesDisplayToggle';
/**
 * The Sight Layer which implements dynamic vision, lighting, and fog of war
 * @type {CanvasLayer}
 */
class SightLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * The shadow map container which renders dark, dim, and bright light sources
		 * @type {PIXI.Container}
		 */
		this.map = null;

		/**
		 * The fog container which includes fog of war and exploration layers
		 * @type {PIXI.Container}
		 */
		this.fog = null;

		/**
		 * Fog of War data object
		 * @type {Object}
		 */
		this.fogData = {};

		/**
		 * Classify arrays of tokens which either have vision or emit light
		 * @type {Object}
		 */
		this.tokens = {
			vision: [],
			light: [],
		};

		/**
		 * Track currently active field-of-view polygons
		 * @type {Array}
		 */
		this.fov = {
			tokens: [],
			lights: [],
		};

		/**
		 * Track currently active line-of-sight polygons
		 * @type {Object}
		 */
		this.los = {
			tokens: [],
			lights: [],
		};

		/**
		 * Track whether or not Token vision is enabled for this Scene
		 * @type {Boolean}
		 */
		this.tokenVision;

		/**
		 * Track whether or not fog of war exploration is enabled for this Scene
		 * @type {Boolean}
		 */
		this.fogExploration;

		/**
		 * Track the distinct grid positions which have had fog of war explored at a certain visible radius
		 * @type {Object}
		 */
		this.fogPositions;

		/**
		 * Store the different opacity levels used for elements of the Sight Layer
		 * @type {Object}
		 */
		this.alphas;

		/**
		 * Light source rendering queues divide the contents of the shadow-map into 4 lighting levels, each of which
		 * override the precedence of the previous level
		 *
		 * 1) dim
		 * 2) bright
		 * 3) dark
		 * 4) black
		 *
		 * @type {Object}
		 */
		this.queues;

		/**
		 * A special ColorMatrixFilter which transforms greyscale to alpha
		 * @type {PIXI.filters.ColorMatrixFilter}
		 */
		this.shadowMapFilter;

		// Save fog once per minute if it has been updated
		this._updateFog = false;
		this._fogUpdated = false;
		setInterval(() => this.saveFog(), 1000 * 60);
	}

	/* -------------------------------------------- */

	/**
	 * Create the shadow-map channel queues
	 * @private
	 */
	_createQueues() {
		return {
			dim: {
				hex: PIXI.utils.rgb2hex([1, 1, 1].map(c => this.alphas.dim)),
				lights: [],
				tokens: [],
			},
			bright: {
				hex: PIXI.utils.rgb2hex([1, 1, 1].map(c => this.alphas.bright)),
				lights: [],
				tokens: [],
			},
			dark: {
				hex: PIXI.utils.rgb2hex([1, 1, 1].map(c => this.alphas.dark)),
				lights: [],
				tokens: [],
			},
			black: {
				hex: PIXI.utils.rgb2hex(
					[1, 1, 1].map(c => this.alphas.unexplored)
				),
				lights: [],
				tokens: [],
			},
		};
	}

	/* -------------------------------------------- */

	/**
	 * Create the shadow map filter which converts greyscale colors to alpha layer
	 * @private
	 */
	_createShadowMapFilter() {
		let f = new PIXI.filters.ColorMatrixFilter();
		let a = 1 / 3;
		f.matrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, a, a, a, 0, 0];
		return f;
	}

	/* -------------------------------------------- */
	/*  Initialization and Rendering                */
	/* -------------------------------------------- */

	/**
	 * Draw Sight Layer canvas elements
	 * @return {SightLayer}
	 */
	draw() {
		super.draw();

		// Initialize Layer data
		this.tokenVision = canvas.scene.data.tokenVision;
		this.fogExploration = canvas.scene.data.fogExploration;
		this.fogPositions = {};

		// Reset the alpha channels used for this Scene
		this.alphas = duplicate(this.constructor.DEFAULT_ALPHAS);
		this.alphas.unexplored = game.user.isGM
			? this.alphas.gmUnexplored
			: this.alphas.unexplored;
		this.alphas.dark = this.fogExploration
			? this.alphas.dark
			: this.alphas.unexplored;

		// Create vision queues and filters
		this.queues = this._createQueues();
		this.shadowMapFilter = this._createShadowMapFilter();

		// Draw the ShadowMap container
		this.map = this.addChild(this._drawShadowMapContainer());

		// Draw the fog container
		this.fog = this.addChild(this._drawFogContainer());

		// Enable soft shadow blur filtering
		this.filters = game.settings.get('core', 'softShadows')
			? [new PIXI.filters.BlurFilter(5)]
			: null;

		// Return a reference to the layer
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the shadow map container which spans the entire map and renders light into a container in greyscale.
	 * The greyscale light is then color-mapped to alpha channel.
	 * @private
	 */
	_drawShadowMapContainer() {
		let d = canvas.dimensions;
		let map = new PIXI.Container();

		// Darkness
		map.dark = map.addChild(new PIXI.Graphics());
		map.dark
			.beginFill(this.queues.dark.hex, 1.0)
			.drawRect(0, 0, d.width, d.height)
			.endFill();

		// Parent container for all light sources - lights or tokens
		map.sources = map.addChild(new PIXI.Container());

		// Ambient light sources
		map.sources.lights = map.sources.addChild(new PIXI.Container());

		// Token light sources
		map.sources.tokens = map.sources.addChild(new PIXI.Container());

		// Line-of-sight masking
		map.los = map.addChild(new PIXI.Graphics());
		map.sources.mask = map.los;

		// ColorMatrix Filter for Alpha channel
		map.filters = [this.shadowMapFilter];
		return map;
	}

	/* -------------------------------------------- */

	_enqueueSource(level, type, data) {
		this.queues[level][type].push(data);
	}

	/* -------------------------------------------- */

	/**
	 * For a specific light source and type, draw the source container to the shadow map parent
	 * @param {Number} hex        The hex color which should be drawn to the shadow map
	 * @param {Number} x          The x-coordinate of the source origin
	 * @param {Number} y          The y-coordinate of the source origin
	 * @param {Number} radius     The radius of light emitted
	 * @param {PIXI.Polygon} fov  The field-of-view polygon for the source
	 * @private
	 */
	_drawShadowMap(hex, { x, y, radius, fov } = {}) {
		let source = new PIXI.Container();
		source.light = source.addChild(new PIXI.Graphics());
		source.light
			.beginFill(hex, 1.0)
			.drawCircle(x, y, radius)
			.endFill();
		source.fov = source.addChild(new PIXI.Graphics());
		source.fov
			.beginFill(0xffffff, 1.0)
			.drawPolygon(fov)
			.endFill();
		source.light.mask = source.fov;
		return source;
	}

	/* -------------------------------------------- */

	/**
	 * Imagine the fog of war layer as a black blanket over the map with holes cut out where the player has explored.
	 * To render the fog layer we draw a container using different greyscale tones and then apply a shadow-map transform
	 * to translate into the alpha channel.
	 * @private
	 *
	 * @return {PIXI.Container} The fog container
	 */
	_drawFogContainer() {
		const d = canvas.dimensions,
			fog = new PIXI.Container();

		// Determine a downscaling resolution
		let res = 1.0;
		if (d.width * d.height > 16000 ** 2) res = 0.25;
		else if (d.width * d.height > 8000 ** 2) res = 0.5;

		// Draw the obscured area
		fog.obscured = fog.addChild(new PIXI.Graphics());
		fog.obscured
			.beginFill(this.queues.black.hex, 1.0)
			.drawRect(0, 0, d.width, d.height)
			.endFill();

		// Draw the explored area
		fog.explored = fog.addChild(new PIXI.Container());

		// Draw the initial exploration state
		fog.rendered = fog.explored.addChild(new PIXI.Sprite());
		fog.rendered.width = canvas.dimensions.width;
		fog.rendered.height = canvas.dimensions.height;

		// Draw the explored polygon
		fog.update = fog.explored.addChild(new PIXI.Container());

		// Have a staging texture to use to composite fog graphics
		fog.staging = new PIXI.RenderTexture.create({
			width: d.width,
			height: d.height,
			scaleMode: 1,
			resolution: res,
		});

		// Shadow-map matrix transformation
		fog.filters = [this.shadowMapFilter];
		return fog;
	}

	/* -------------------------------------------- */
	/*  Layer Initialization                        */
	/* -------------------------------------------- */

	/**
	 * Initialize starting sight for non-GM players
	 */
	async initialize() {
		await this.initializeFog();
		await this.initializeSight();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the fog container by resetting tracked fog positions and loading existing fog layer for the scene.
	 * @return {Promise}    A Promise which resolves once fog of war is fully loaded
	 */
	async initializeFog() {
		// If Token vision is not enforced, we don't need the fog layer
		if (!this.tokenVision) {
			this.fog.visible = false;
			return;
		}

		// Set up the fog layer
		this.fogPositions = {};
		this._fogUpdated = false;
		this.fog.visible = !game.user.isGM;

		// Load existing fog data
		return this.loadFog();
	}

	/* -------------------------------------------- */

	/**
	 * Initialize sight and visibility
	 * @param {Object} options
	 * @param {boolean} options.updateFog
	 */
	initializeSight({ updateFog = true } = {}) {
		// If Token vision is not enforced, we can hide the shadow-map completely
		if (!this.tokenVision) {
			this.map.visible = false;
			return;
		}

		// Adjust the cull multiplier and distance based on the number of walls
		let nw = canvas.scene.data.walls.length;
		if (nw <= 50) this._cull = [10, 100, 1000];
		else if (nw <= 150) this._cull = [3, 50, 500];
		else this._cull = [2, 10, 50];

		// Allocate tokens as either FOV or light sources
		let [fovTokens, lightTokens] = this._getTokens();
		this.tokens = {
			vision: fovTokens,
			light: lightTokens,
		};

		// Draw ambient lights when sight is first initialized, as these do not need to be updated frequently
		this.updateLights();

		// Create the shadow layer and draw sight
		this.updateSight({ updateFog });

		// If the player has no vision tokens in a visibility-restricted scene, display a warning on a slight delay
		if (!game.user.isGM && !fovTokens.length) {
			setTimeout(
				() =>
					ui.notifications.warn(
						'You do not own any Token with vision in this Scene'
					),
				250
			);
		}
	}

	/* -------------------------------------------- */
	/*  Ambient Light Sources                       */
	/* -------------------------------------------- */

	/**
	 * Draw light containers for all ambient lights which do not change when a token is moved
	 *
	 * First, iterate through each light and register light-level data. For each light source, store their light radii
	 * in a queue for rendering. Sort the queue in descending order of radius to ensure that we draw bright light after
	 * dim light, and negative light values last of all.
	 */
	updateLights() {
		// Reset the list of light source FOV polygons we are tracking
		this.fov.lights = [];
		this.los.lights = [];

		// Empty the shadow map rendering queues for each lighting level
		Object.values(this.queues).forEach(q => (q.lights = []));

		// If we are not using token vision, no work is required
		if (!this.tokenVision) return;

		// Classify each ambient light source for rendering
		canvas.lighting.placeables.forEach(l => {
			let dim = l.dimRadius,
				bright = l.brightRadius;

			// Compute and track the light source FOV polygon
			l.computeFOV();

			// Store bright or dim emission to the relevant queue
			if (dim) {
				if (dim > 0)
					this._enqueueSource('dim', 'lights', {
						x: l.x,
						y: l.y,
						radius: dim,
						fov: l.fov,
					});
				else
					this._enqueueSource('dark', 'lights', {
						x: l.x,
						y: l.y,
						radius: -1 * dim,
						fov: l.fov,
					});
			}
			if (bright) {
				if (bright > 0)
					this._enqueueSource('bright', 'lights', {
						x: l.x,
						y: l.y,
						radius: bright,
						fov: l.fov,
					});
				else
					this._enqueueSource('black', 'lights', {
						x: l.x,
						y: l.y,
						radius: -1 * bright,
						fov: l.fov,
					});
			}

			// Store and draw masking FOV or LOS polygons for fog and lighting
			if (dim >= 0 || bright >= 0) {
				this.fov.lights.push(l.fov);
				if (l.global) this.los.lights.push(l.fov);
			}
		});
	}

	/* -------------------------------------------- */
	/*  Token Light Sources                         */
	/* -------------------------------------------- */

	/**
	 * Get the subset of Tokens which are controllable and have a field of vision
	 * First determine whether the token is a potential source of vision
	 * Tokens which are controlled are always vision sources
	 * For players which control no tokens, if the represented Actor is Observed, it can be a vision source
	 * @return {Array<Array>}
	 * @private
	 */
	_getTokens() {
		// Get the set of tokens which may be observed
		const tokens = canvas.tokens.placeables.filter(
				t => game.user.isGM || !t.data.hidden
			),
			anyControlled = tokens.some(t => t._controlled),
			globalLight = canvas.scene.data.globalLight;

		// Allocate all tokens into vision sources and light sources
		return tokens.reduce(
			(arr, t) => {
				let [vision, light] = arr;

				// Determine whether the Token is an eligible vision source
				let isVisionSource = false;
				if (t.hasSight) {
					if (t._controlled) isVisionSource = true;
					else if (!game.user.isGM && !anyControlled)
						isVisionSource =
							t.actor && t.actor.hasPerm(game.user, 'OBSERVER');
				}
				let isLightSource = !globalLight && t.emitsLight;

				// Assign Token to source groups
				if (isVisionSource) vision.push(t);
				if (isLightSource) light.push(t);
				return arr;
			},
			[[], []]
		);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the sight polygon for a specified token
	 * Support a number of options to configure how sight is updated
	 *
	 * @param options {Object}
	 * @param options.updateFog {Boolean}
	 */
	updateSight({ updateFog = false } = {}) {
		// Destroy currently rendered light sources
		this.map.sources
			.removeChildren()
			.forEach(c =>
				c.destroy({ children: true, texture: true, baseTexture: true })
			);
		this.map.los.clear();

		// Empty the shadow map rendering queues for each lighting level
		Object.values(this.queues).forEach(q => (q.tokens = []));

		// Reset the array of tracked token FOV and LOS polygons we are tracking
		this.fov.tokens = [];
		this.los.tokens = [];

		// Track whether a fog of war exploration update is required
		this._updateFog = false;

		// Case 1 - no vision required
		if (!this.tokenVision) this.map.visible = this.fog.visible = false;
		// Case 2 - no vision sources
		else if (!this.tokens.vision.length)
			this.map.visible = this.fog.visible = !game.user.isGM;
		// Case 3 - regular vision
		else {
			let pNow = null;

			// Begin debug loop
			if (CONFIG.debug.sight) {
				if (!canvas.controls.debugSight)
					canvas.controls.debugSight = canvas.controls.addChild(
						new PIXI.Graphics()
					);
				canvas.controls.debugSight.clear();
				canvas.controls.debugSight.alpha = 0.25;
				this._rayCount = 0;
				pNow = performance.now();
			}

			// Obtain the walls which affect vision
			const visionWalls = canvas.walls.blockVision;

			// Update each token which is a vision source
			this.tokens.vision.forEach(t =>
				this._updateToken(t, {
					vision: true,
					hasVision: true,
					updateFog: updateFog,
					visionWalls: visionWalls,
				})
			);

			// Update additional tokens which are light emission sources
			this.tokens.light.forEach(t =>
				this._updateToken(t, {
					light: true,
					hasVision: false,
					updateFog: updateFog,
					visionWalls: visionWalls,
				})
			);

			// Draw LOS polygons for global light sources
			this.los.lights.forEach(los => {
				this.map.los
					.beginFill(0xffffff, 1.0)
					.drawPolygon(los)
					.endFill();
			});

			// Once all tokens have been classified, render each lighting level queue to the shadow map
			Object.values(this.queues).forEach(q => {
				q.lights.concat(q.tokens).forEach(s => {
					this.map.sources.addChild(this._drawShadowMap(q.hex, s));
				});
			});

			// If necessary, draw a fog update
			if (this._updateFog) this.drawFogExploration();

			// Update visibility of layers and placeables
			this.map.visible = this.fog.visible = true;

			// Log debug status
			if (CONFIG.debug.sight) {
				let ns = performance.now() - pNow;
				console.log(
					`Rendered sight with ${this._rayCount} rays in ${ns}ms`
				);
			}
		}

		// Update visibility of placeables
		this.restrictVisibility();
	}

	/* -------------------------------------------- */

	/**
	 * Handle each token which is a potential vision or light source
	 * @param {Token} token                 The token instance
	 * @param {Boolean} light               Whether we are updating the Token as a light source (true) or as a vision source (false)
	 * @param {Boolean} updateFog           Whether or not to forcibly update the fog layer
	 * @private
	 */
	_updateToken(
		token,
		{ light = false, updateFog = false, visionWalls } = {}
	) {
		// Determine default vision arguments
		let dim = token._getLightRadius(
			light ? token.data.dimLight : token.data.dimSight
		);
		let bright = token._getLightRadius(
			light ? token.data.brightLight : token.data.brightSight
		);
		let [cullMult, cullMin, cullMax] = this._cull;

		// Adapt for case of global illumination
		if (canvas.scene.data.globalLight) {
			dim = Math.max(canvas.dimensions.width, canvas.dimensions.height);
			bright = dim;
			cullMin = dim;
		}

		// Adapt for case of no vision
		if (dim === 0 && bright === 0) {
			if (light) return;
			else dim = canvas.dimensions.size * 0.6;
		}

		// Evaluate sight polygons for the Token using provided radius and options
		const angle = light ? token.data.lightAngle : token.data.sightAngle;
		const center = token.getSightOrigin();
		const radius = Math.max(Math.abs(dim), Math.abs(bright));
		const [rays, los, fov] = this.checkSight(center, radius, {
			angle: angle,
			cullMinDistance: cullMin,
			cullMultiplier: cullMult,
			cullMaxDistance: cullMax,
			radialDensity: 6,
			rotation: token.data.rotation,
			walls: visionWalls,
		});

		// Store bright or dim emission to the relevant queue
		if (dim) {
			if (dim > 0)
				this._enqueueSource('dim', 'tokens', {
					x: center.x,
					y: center.y,
					radius: dim,
					fov: fov,
				});
			else
				this._enqueueSource('dark', 'tokens', {
					x: center.x,
					y: center.y,
					radius: -1 * dim,
					fov: fov,
				});
		}
		if (bright) {
			if (bright > 0)
				this._enqueueSource('bright', 'tokens', {
					x: center.x,
					y: center.y,
					radius: bright,
					fov: fov,
				});
			else
				this._enqueueSource('black', 'tokens', {
					x: center.x,
					y: center.y,
					radius: -1 * bright,
					fov: fov,
				});
		}

		// Add both sight and light tokens as token-based FOV polygons
		this.fov.tokens.push(fov);

		// Add sight tokens as LOS polygons and draw them to the LOS mask
		if (!light) {
			this.los.tokens.push(los);
			this.map.los
				.beginFill(0xffffff, 1.0)
				.drawPolygon(los)
				.endFill();
		}

		// Update fog exploration for the token position
		this.updateFog(center.x, center.y, radius, angle !== 360, updateFog);

		// Draw debugging
		if (CONFIG.debug.sight && !light) {
			this._debugSight(rays, los, fov);
			this._rayCount += rays.length;
		}
	}

	/* -------------------------------------------- */
	/*  Fog Exploration Controls                    */
	/* -------------------------------------------- */

	/**
	 * Update the fog layer when a player token reaches a board position which was not previously explored
	 * @param {Number} x          The origin x-coordinate from which to update fog exploration
	 * @param {Number} y          The origin y-coordinate from which to update fog exploration
	 * @param {Number} radius     The vision radius of the exploration from this point
	 * @param {Boolean} limit     Was the position explored by a limited viewpoint?
	 * @param {Boolean} force     Force the fog location to be updated even if it is not a larger radius
	 */
	updateFog(x, y, radius, limit, force) {
		// Standardize fog coordinate key
		let coords = Math.round(x) + '_' + Math.round(y),
			pos = this.fogPositions[coords];

		// Check whether the position has already been explored
		let explored = pos && pos.limit !== true && pos.radius >= radius;
		if (explored && !force) return;

		// Update the explored positions
		this.fogPositions[coords] = { radius, limit };
		this._updateFog = true;
	}

	/* -------------------------------------------- */

	async drawFogExploration() {
		if (game.debug)
			console.log(`${vtt} | Drawing for of war exploration update.`);
		let exp = new PIXI.Container();

		// Draw FOV polygons
		exp.fov = exp.addChild(new PIXI.Graphics()).beginFill(0x000000, 1.0);
		for (let fov of this.fov.tokens.concat(this.fov.lights)) {
			exp.fov.drawPolygon(fov);
		}
		exp.fov.endFill();

		// Draw LOS mask
		exp.los = exp.addChild(new PIXI.Graphics()).beginFill(0xffffff, 1.0);
		for (let los of this.los.tokens.concat(this.los.lights)) {
			exp.los.drawPolygon(los);
		}
		exp.los.endFill();
		exp.mask = exp.los;

		// Add the exploration container to the explored layer
		this.fog.update.addChild(exp);

		// Render the swapped fog
		return this._swapStagingToRendered();
	}

	/* -------------------------------------------- */

	/**
	 * Once a new Fog of War location is explored, composite the explored container with the current staging sprite
	 * Save that staging Sprite as the rendered fog exploration and swap it out for a fresh staging texture
	 * Do all this asynchronously, so it doesn't block token movement animation since this takes some extra time
	 * @return {Promise<void>}
	 * @private
	 */
	async _swapStagingToRendered() {
		const fog = this.fog,
			staging = fog.staging;

		// Render the staging texture and swap
		canvas.app.renderer.render(fog.explored, fog.staging);

		// Swap the staging texture to the rendered Sprite
		const old = fog.rendered.texture;
		fog.rendered.texture = fog.staging;
		old.destroy(true);

		// Clear update container
		fog.update
			.removeChildren()
			.forEach(c =>
				c.destroy({ children: true, texture: true, baseTexture: true })
			);

		// Create a new Staging texture
		fog.staging = new PIXI.RenderTexture.create({
			width: staging.width,
			height: staging.height,
			scaleMode: 1,
			resolution: staging.baseTexture.resolution,
		});

		// Record that fog was updated
		this._fogUpdated = true;
	}

	/* -------------------------------------------- */
	/*  Fog of War Controls                         */
	/* -------------------------------------------- */

	/**
	 * Load existing fog of war data from local storage and populate the initial exploration sprite
	 * @return {Promise}
	 */
	async loadFog() {
		if (!this.tokenVision) return;

		// Load fog of war exploration data
		let fogData = await this._loadFogServerStorage();
		if (!fogData) fogData = this._loadFogLocalStorage();
		this.fogData = fogData || {};
		if (!fogData) return;

		// Extract the fog data image
		let render = tex => {
			this.fog.rendered.texture = tex;
			this.fog.rendered.tint = 0x000000;
		};
		return await new Promise(resolve => {
			let tex = PIXI.Texture.from(fogData.explored);
			if (tex.baseTexture.valid) {
				render(tex);
				return resolve();
			} else
				tex.on('update', tex => {
					render(tex);
					resolve();
				});
		});
	}

	/* -------------------------------------------- */

	/**
	 * Load Fog of War exploration data for a user from Server Storage
	 * @return {Promise}
	 * @private
	 */
	async _loadFogServerStorage() {
		const eventData = { user: game.user._id, scene: canvas.scene._id };
		return SocketInterface.trigger(
			'getFogExploration',
			eventData,
			{},
			{
				context: this,
				success: response => {
					if (response.data)
						window.localStorage.removeItem(
							`${game.world.id}.fog.${canvas.scene._id}`
						);
					return response.data || null;
				},
			}
		);
	}

	/* -------------------------------------------- */

	_loadFogLocalStorage() {
		const fogKey = `${game.world.id}.fog.${canvas.scene._id}`;
		let fogData = window.localStorage.getItem(fogKey);
		if (!fogData) return null;
		try {
			fogData = JSON.parse(fogData);
			fogData.explored = fogData.data;
			console.log(`${vtt} | Loaded fog of war from Local Storage data.`);
			return fogData;
		} catch (err) {
			window.localStorage.removeItem(this.fogKey);
			return null;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Save fog of war exploration data to a URL string
	 * The fog exploration has already been rendered as fog.rendered.texture
	 * @private
	 */
	async saveFog() {
		if (!this.tokenVision || !this._fogUpdated) return;
		this._fogUpdated = false;
		let d = canvas.dimensions;

		// Use the existing rendered fog to create a Sprite and downsize to save with smaller footprint
		const fog = new PIXI.Sprite(this.fog.rendered.texture);
		let scl = d.width > 1920 ? 1920 / d.width : 1.0;
		fog.scale.set(scl, scl);

		// Add the fog to a temporary container to bound it's dimensions and export to base data
		const stage = new PIXI.Container();
		stage.addChild(fog);

		// Construct the fog data to store
		this.fogData = {
			_id: this.fogData._id,
			user: game.user._id,
			scene: canvas.scene._id,
			explored: canvas.app.renderer.extract.base64(stage),
			positions: this.fogPositions,
			timestamp: Date.now(),
		};

		// Create or update the fog
		await this._createOrUpdateFogExploration(this.fogData);
		stage.destroy({ children: true });
	}

	/* -------------------------------------------- */

	/**
	 * Trigger a server-side update (or creation) of fog exploration status for a certain Scene
	 * @param fogData
	 * @return {Promise}
	 * @private
	 */
	async _createOrUpdateFogExploration(fogData) {
		let eventName = fogData._id
			? 'updateFogExploration'
			: 'createFogExploration';
		return SocketInterface.trigger(
			eventName,
			{ data: fogData },
			{},
			{
				context: this,
				success: response => {
					let size =
						Math.round(
							(fogData.explored.length * 100) / (1000 * 1000)
						) / 100;
					console.log(
						`${vtt} | Saved user fog of war exploration to server - ${size} MB`
					);
					if (!fogData._id) this.fogData._id = response.created._id;
					return response;
				},
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Reset the fog of war by clearing current exploration progress
	 * This approach currently takes the nuclear option of clearing any saved fog and redrawing the entire canvas
	 * It's not that inefficient, so it could be worth just keeping it this way for simplicity
	 */
	async resetFog() {
		const eventData = { scene: canvas.scene._id };
		return SocketInterface.trigger(
			'resetFogExploration',
			eventData,
			{},
			{
				context: this,
				success: response => {
					console.log(
						`${vtt} | Reset fog of war exploration data for all users`
					);
					Scenes._onFogReset(response);
				},
			}
		);
	}

	/* -------------------------------------------- */

	debugFog() {
		let tex = PIXI.Texture.from(this.fogData.explored);
		let debug = new PIXI.Sprite(tex);
		this.addChild(debug);
		debug.x = -canvas.dimensions.width;
		debug.y = -canvas.dimensions.height;
	}

	/* -------------------------------------------- */

	/**
	 * Restrict the visibility of certain canvas assets (like Tokens or DoorControls) based on the visibility polygon
	 * These assets should only be displayed if they are visible given the current player's field of view
	 */
	async restrictVisibility() {
		// Tokens
		for (let t of canvas.tokens.placeables) {
			t.visible = (!this.tokenVision && !t.data.hidden) || t.isVisible;
		}

		// Door Icons
		for (let d of canvas.controls.doors.children) {
			d.visible = !this.tokenVision || d.isVisible;
		}
	}

	/* -------------------------------------------- */
	/*  Helper and Utility Functions                */
	/* -------------------------------------------- */

	/**
	 * Evaluate the sight polygons for a given origin position and vision radius
	 * This method generates two polygons - one for line of sight, and another for field of vision
	 * The line-of-sight polygon defines the unrestricted area of visibility for the source
	 * The field-of-vision polygon defines the restricted area of visibility for the source
	 *
	 * @param {Object} origin         An object with coordinates x and y representing the origin of the test
	 * @param {Number} radius         A distance in canvas position units which reflects the visible range
	 * @param {Number} minAngle       [Optional] The minimum angle of restricted sight or light emission
	 * @param {Number} maxAngle       [Optional] The maximum angle of restricted sight or light emission
	 * @param {Number} cullDistance   [Optional] The minimum number of grid spaces after which to begin culling walls.
	 * @param {Number} cullMultiplier [Optional] The multiplier on the provided radius against which to cull wall endpoint checks. Default is 2
	 * @param {Number} radialDensity  [Optional] The density in degrees to which to guarantee that rays are broadcast. Default is 6
	 * @param {Array} walls           [Optional] A specific Array of Walls to test collision against
	 *
	 * @returns {Array}               An Array of Ray objects, and the two vision polygons
	 */
	checkSight(
		origin,
		radius,
		{
			minAngle = null,
			maxAngle = null,
			cullMinDistance = 10,
			cullMultiplier = 2,
			cullMaxDistance = 20,
			radialDensity = 6,
			walls,
			rotation = 0,
			angle = 360,
		} = {}
	) {
		// Get the maximum sight distance and the limiting radius
		let d = canvas.dimensions,
			{ x, y } = origin,
			distance = Math.max(d.width, d.height),
			limit = radius / distance,
			cullDistance = Math.clamped(
				radius * cullMultiplier,
				cullMinDistance * d.size,
				cullMaxDistance * d.size
			);

		// Determine limiting angles of visibility
		const limitAngle = angle !== 360 && angle !== 0;
		const aMin = limitAngle
			? normalizeRadians(toRadians(90 + rotation - angle / 2))
			: -Math.PI;
		const aMax = limitAngle
			? normalizeRadians(toRadians(90 + rotation + angle / 2))
			: Math.PI;

		// Cast sight rays needed to determine the polygons
		let rays = this._castSightRays(
			x,
			y,
			distance,
			cullDistance,
			radialDensity,
			limitAngle,
			aMin,
			aMax
		);

		// Iterate over rays and record their points of collision with blocking walls
		walls = walls || canvas.walls.blockVision;
		for (let r of rays) {
			let collisions = this._getWallCollisionsForRay(r, walls);
			let closest = this._getClosestCollisionPoint(r, collisions);
			r.collision = closest;
			r.limit =
				closest.t0 <= limit
					? closest
					: { x: r.A.x + limit * r.dx, y: r.A.y + limit * r.dy };
		}

		// For angle-limited polygons - add an additional ray which collides just behind the source's "head"
		if (limitAngle) {
			const aCenter = normalizeRadians(
				aMin + toRadians(angle / 2) + Math.PI
			);
			const cRay = Ray.fromAngle(x, y, aCenter, d.size);
			const head = cRay.project(0.5);
			cRay.collision = cRay.limit = head;
			rays.push(cRay);
		}

		// Sort rays clockwise by angle
		rays.sort((r1, r2) => r1.angle - r2.angle);

		// Reduce collisions and limits to line-of-sight and field-of-view polygons
		let [losPoints, fovPoints] = rays.reduce(
			(acc, r, i) => {
				acc[0].push(r.collision.x, r.collision.y);
				acc[1].push(r.limit.x, r.limit.y);
				return acc;
			},
			[[], []]
		);

		// Construct visibiliy polygons and return them with the rays
		const los = new PIXI.Polygon(...losPoints),
			fov = new PIXI.Polygon(...fovPoints);
		return [rays, los, fov];
	}

	/* -------------------------------------------- */

	/**
	 * A helper method responsible for casting rays at wall endpoints
	 * Rays are restricted by allowed angles and culling distance
	 * @returns {Array}   An array of Ray objects
	 */
	_castSightRays(
		x,
		y,
		distance,
		cullDistance,
		radialDensity,
		limitAngle,
		aMin,
		aMax
	) {
		// Create angle-limiting rays
		const endpointOffsetAngle = 0.01;
		const isSplit180 = (Math.sign(aMin) || 1) !== (Math.sign(aMax) || 1);
		const rMin = limitAngle ? Ray.fromAngle(x, y, aMin, distance) : null;
		const rMax = limitAngle ? Ray.fromAngle(x, y, aMax, distance) : null;

		// Check each unique wall endpoint as a candidate target
		let rays = canvas.walls.endpoints.reduce((rays, e) => {
			let r = new Ray({ x, y }, { x: e[0], y: e[1] });
			let ra = r.angle;

			// Exclude rays which exceed the allowed culling distance
			if (r.distance > cullDistance) return rays;

			// Exclude rays which do not lie within the allowed threshold angles
			if (limitAngle) {
				if (isSplit180 && ra < 0 && ra > aMax) return rays;
				else if (isSplit180 && ra > 0 && ra < aMin) return rays;
				else if (!Number.between(r.angle, aMin, aMax)) return rays;
			}

			// Emit 3 rays, one directly at the point, and two slightly to either side
			const ray = Ray.fromAngle(x, y, ra, distance);
			return rays.concat([
				ray.shiftAngle(-endpointOffsetAngle),
				ray,
				ray.shiftAngle(endpointOffsetAngle),
			]);
		}, []);

		// Add limiting Rays
		if (limitAngle) rays.push(rMin, rMax);

		// De-dupe rays before testing collision
		const angles = new Set();
		rays = rays.filter(r => {
			let a = Math.round(r.angle / endpointOffsetAngle);
			if (angles.has(a)) return false;
			angles.add(a);
			return true;
		});

		// Insert additional rays for any non-represented angles given a target radial density
		const da = toRadians(radialDensity),
			nfill = Math.ceil(
				(aMax < aMin ? aMax + 2 * Math.PI - aMin : aMax - aMin) / da
			),
			targets = Array.fromRange(nfill).map(a => aMin + a * da),
			emitted = rays.map(r => Math.round(r.angle / da) * da);
		for (let t of targets.filter(t => !emitted.includes(t))) {
			rays.push(Ray.fromAngle(x, y, t, distance));
		}
		return rays;
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Wall collisions for a vision Ray
	 * @param {Ray} ray                 The vision ray to test
	 * @param {Array.<Wall>} walls      The walls against which to test
	 * @return {Array}                  An array of collision points
	 * @private
	 */
	_getWallCollisionsForRay(ray, walls) {
		let collisions = {};
		for (let w of walls) {
			// Skip directional walls where the ray angle is not in the same hemisphere as the wall direction
			let bounds = [ray.angle - Math.PI / 2, ray.angle + Math.PI / 2];
			if (w.direction !== null) {
				if (!w.isDirectionBetweenAngles(...bounds)) continue;
			}

			// Test for intersections
			let i = ray.intersectSegment(w.coords);
			if (i && i.t0 > 0) {
				i.x = Math.round(i.x);
				i.y = Math.round(i.y);

				// Ensure uniqueness of the collision point
				let pt = `${i.x}.${i.y}`;
				const c = collisions[pt];
				if (c) {
					c.sense = Math.min(w.data.sense, c.sense);
				} else {
					i.sense = w.data.sense;
					collisions[pt] = i;
				}
			}
		}
		return Array.from(Object.values(collisions));
	}

	/* -------------------------------------------- */

	/**
	 * Get the closest collision point from an Array of collision points
	 * @param {Array} collisions    The Array of collision point Objects
	 * @returns {Object}            The closest collision point to the origin of the Ray
	 * @private
	 */
	_getClosestCollisionPoint(ray, collisions) {
		collisions.sort((a, b) => a.t0 - b.t0);
		let closest;
		if (collisions.length) {
			closest =
				collisions[0].sense === CONST.WALL_SENSE_TYPES.LIMITED
					? collisions[1]
					: collisions[0];
		}
		if (!closest) closest = { x: ray.B.x, y: ray.B.y, t0: 1, t1: 0 };
		return closest;
	}

	/* -------------------------------------------- */

	/**
	 * Debug a sight check by plotting the tested rays and their collision points
	 * @private
	 */
	_debugSight(rays, los, fov) {
		const d = canvas.controls.debugSight;

		// Draw rays in green and collisions in red
		for (let r of rays) {
			d.lineStyle(1, 0x00ff00, 1.0)
				.moveTo(r.A.x, r.A.y)
				.lineTo(r.B.x, r.B.y)
				.drawCircle(r.B.x, r.B.y, 4);
			d.lineStyle(1, 0xff0000, 1.0).drawCircle(
				r.collision.x,
				r.collision.y,
				4
			);
		}

		// Lastly highlight the visible polygon in green
		d.beginFill(0x00ff00, 0.1).drawPolygon(los);
		d.beginFill(0xff0000, 0.05).drawPolygon(fov);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
  /* -------------------------------------------- */

	/**
	 * Handle changing of the Soft Shadows canvas setting
	 * @private
	 */
	_onChangeSoftShadows(enabled) {
		this.draw();
		this.initialize();
	}
}

/**
 * The default sight visibility layer alpha channels
 * @type {Object}
 */
SightLayer.DEFAULT_ALPHAS = {
	unexplored: 1.0,
	gmUnexplored: 0.7,
	dark: 0.75,
	dim: 0.5,
	bright: 0.0,
};
/**
 * The Ambient Sounds Container
 * @extends {PlaceablesLayer}
 */
class SoundsLayer extends PlaceablesLayer {
	/** @override */
	static get dataArray() {
		return 'sounds';
	}

	/** @override */
	static get placeableClass() {
		return AmbientSound;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Initialize the field of "view" for all AmbientSound effects in the layer
	 */
	initialize() {
		this.placeables.forEach(s => s.computeFOV());
		if (Howler.state === 'suspended')
			game.audio.pending.push(() => this.update());
		else this.update();
	}

	/* -------------------------------------------- */

	/**
	 * Update all AmbientSound effects in the layer by toggling their playback status
	 */
	update() {
		// Get the tokens against which to check hearing
		const tokens = game.user.isGM
			? canvas.tokens.controlled
			: canvas.tokens.ownedTokens;

		// Classify distinct sounds as audible or not
		const audible = this.placeables.reduce((obj, sound) => {
			let p = sound.data.path,
				r = sound.radius;

			// Get the tokens which can hear this sound
			let audible = tokens.filter(t => {
				let c = t.center;
				return sound.fov.contains(c.x, c.y);
			});

			// Get or create the record
			if (!obj.hasOwnProperty(p))
				obj[p] = {
					sound: sound,
					audible: false,
					volume: 0,
				};

			// Flag audible status
			if (!audible.length) return obj;
			obj[p].audible = true;

			// Determine the loudest audible volume
			if (sound.data.easing) {
				let distance = Math.min(
					...audible.map(t => {
						let c = t.center;
						return Math.hypot(c.x - sound.x, c.y - sound.y);
					})
				);
				const scale = Math.clamped((r - distance) / r, 0.2, 1.0);
				obj[p].volume = sound.data.volume * scale;
			} else {
				obj[p].volume = sound.data.volume;
			}

			// Return the updated sound
			return obj;
		}, {});

		// Play each sound
		Object.values(audible).forEach(a => {
			a.sound.play(a.audible, a.volume);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Terminate playback of all ambient audio sources
	 */
	stopAll() {
		this.placeables.forEach(s => s.play(false));
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onDragStart} */
	_onDragStart(event) {
		super._onDragStart(event);
		let origin = event.data.origin,
			sound = new AmbientSound({
				x: origin.x,
				y: origin.y,
				type: 'l',
			}).draw();
		event.data.object = this.preview.addChild(sound);
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onMouseMove} */
	_onMouseMove(event) {
		super._onMouseMove(event);
		if (event.data.createState >= 1) {
			let sound = event.data.object;
			let radius = Math.hypot(
				event.data.destination.x - event.data.origin.x,
				event.data.destination.y - event.data.origin.y
			);
			sound.data.radius =
				radius * (canvas.dimensions.distance / canvas.dimensions.size);
			sound.refresh();
			event.data.createState = 2;
		}
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onMouseUp} */
	_onMouseUp(event) {
		if (event.data.createState === 2) {
			event.stopPropagation();
			let sound = event.data.object,
				distance = Math.hypot(
					event.data.destination.x - event.data.origin.x,
					event.data.destination.y - event.data.origin.y
				);

			// Terminate the drag event
			this._onDragCancel(event);

			// Render the preview sheet
			if (distance >= canvas.dimensions.size / 2) {
				['x', 'y'].forEach(
					k => (sound.data[k] = Math.floor(sound.data[k]))
				);
				sound.data['radius'] =
					Math.floor(sound.data['radius'] * 100) / 100;
				sound.sheet.render(true);
				this.preview.addChild(sound);
				sound.refresh();
				sound.sheet.preview = this.preview;
			}
		}
	}
}

/**
 * The Templates Container
 * @extends {PlaceablesLayer}
 */
class TemplateLayer extends PlaceablesLayer {
	/** @extends {PlaceablesLayer.layerOptions} */
	static get layerOptions() {
		return {
			canDragCreate: true,
			controllableObjects: false,
			rotatableObjects: true,
			snapToGrid: true,
			gridPrecision: 2,
		};
	}

	/** @override */
	static get dataArray() {
		return 'templates';
	}

	/** @override */
	static get placeableClass() {
		return MeasuredTemplate;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @extends {PlaceablesLayer.activate} */
	activate() {
		super.activate();
		if (this.objects) {
			this.placeables.forEach(p => {
				p.controlIcon.visible = true;
				p.ruler.visible = true;
			});
		}
	}

	/* -------------------------------------------- */

	/** @extends {PlaceablesLayer.deactivate} */
	deactivate() {
		super.deactivate();
		if (this.objects) {
			this.objects.visible = true;
			this.placeables.forEach(p => {
				p.controlIcon.visible = false;
				p.ruler.visible = false;
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Register game settings used by the TemplatesLayer
	 */
	static registerSettings() {
		game.settings.register('core', 'coneTemplateType', {
			name: 'TEMPLATE.ConeTypeSetting',
			hint: 'TEMPLATE.ConeTypeSettingHint',
			scope: 'world',
			config: true,
			default: 'round',
			type: String,
			choices: {
				flat: 'TEMPLATE.ConeTypeFlat',
				round: 'TEMPLATE.ConeTypeRound',
			},
			onChange: () =>
				canvas.templates.placeables
					.filter(t => t.data.t === 'cone')
					.forEach(t => t.draw()),
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onMouseDown(event) {
		if (game.activeTool === 'ruler' || event.ctrlKey || event.metaKey)
			return;
		super._onMouseDown(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		super._onDragStart(event);

		// Create the new preview template
		const tool = game.activeTool;
		const origin = event.data.origin;
		const { x, y } = canvas.grid.getSnappedPosition(origin.x, origin.y, 2);
		origin.x = x;
		origin.y = y;

		// Create the template
		const data = {
			user: game.user._id,
			t: tool,
			x: x,
			y: y,
			distance: 0,
			direction: 0,
			fillColor: game.user.data.color || '#FF0000',
		};
		if (tool === 'cone') data['angle'] = 53.13;
		else if (tool === 'ray') data['width'] = canvas.dimensions.distance;

		// Assign the template
		let template = new MeasuredTemplate(data);
		event.data.object = this.preview.addChild(template);
		template.draw();
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseMove(event) {
		super._onMouseMove(event);
		if (event.data.createState >= 1) {
			// Snap the destination to the grid
			let dest = event.data.destination;
			let { x, y } = canvas.grid.getSnappedPosition(dest.x, dest.y, 2);
			dest.x = x;
			dest.y = y;

			// Compute the ray
			let template = event.data.object,
				ray = new Ray(event.data.origin, event.data.destination),
				ratio = canvas.dimensions.size / canvas.dimensions.distance;

			// Update the shape data
			template.data.direction = toDegrees(ray.angle);
			template.data.distance = ray.distance / ratio;

			// Draw the pending shape
			template.refresh();
			event.data.createState = 2;
		}
	}

	/* -------------------------------------------- */

	/** @extends {PlaceablesLayer._onMouseUp} */
	_onMouseUp(event) {
		if (game.activeTool === 'ruler' || event.ctrlKey || event.metaKey)
			return;
		super._onMouseUp(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseWheel(event) {
		// Determine whether we have a hovered template?
		const template = this._hover;
		if (!template) return;

		// Rate limit PlaceableObject rotation since it triggers a database update
		let t = Date.now();
		let dt = t - (keyboard._wheelTime || 0);
		if (dt < keyboard.constructor.MOUSE_WHEEL_RATE_LIMIT) return;
		keyboard._wheelTime = t;

		// Determine the incremental angle of rotation from event data
		let snap = event.shiftKey ? 15 : 5;
		let delta = snap * Math.sign(event.deltaY);
		return template.rotate(template.data.direction + delta, snap);
	}
}

/**
 * The Tiles canvas layer which provides a container for {@link Tile} objects which are rendered immediately above the
 * {@link BackgroundLayer} and below the {@link GridLayer}.
 *
 * @extends {PlaceablesLayer}
 *
 * @see {@link Tile}
 * @see {@link TileHUD}
 */
class TilesLayer extends PlaceablesLayer {
	/** @override */
	static get layerOptions() {
		return mergeObject(super.layerOptions, {
			controllableObjects: true,
			rotatableObjects: true,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	static get dataArray() {
		return 'tiles';
	}

	/* -------------------------------------------- */

	/** @override */
	static get placeableClass() {
		return Tile;
	}

	/* -------------------------------------------- */

	/**
	 * Tile objects on this layer utilize the TileHUD
	 * @type {TileHUD}
	 */
	get hud() {
		return canvas.hud.tile;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/** @override */
	deactivate() {
		super.deactivate();
		if (this.objects) this.objects.visible = true;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		super._onDragStart(event);
		let tile = new Tile({
			x: event.data.origin.x,
			y: event.data.origin.y,
			rotation: 0,
			z: 0,
		});
		tile.draw();
		tile._controlled = true;
		event.data.object = this.preview.addChild(tile);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragCreate(event) {
		let { object, destination, origin, originalEvent } = event.data;

		// Determine destination position
		if (!originalEvent.shiftKey)
			destination = canvas.grid.getSnappedPosition(
				destination.x,
				destination.y
			);

		// Terminate the drag event
		this._onDragCancel(event);

		// Check the dragged distance
		let distance = Math.hypot(
			destination.x - origin.x,
			destination.y - origin.y
		);
		if (distance >= canvas.dimensions.size / 2) {
			// Store final data
			object.data.x = Math.min(destination.x, origin.x);
			object.data.y = Math.min(destination.y, origin.y);
			object.data.width = Math.abs(destination.x - origin.x);
			object.data.height = Math.abs(destination.y - origin.y);

			// Render the preview sheet
			object.sheet.render(true);
			object.sheet.preview = this.preview;

			// Re-render the preview tile
			this.preview.addChild(object);
			object.refresh();
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseMove(event) {
		super._onMouseMove(event);
		if (event.data.createState >= 1) {
			let tile = event.data.object;

			// Determine the drag distance and direction
			let dx = event.data.destination.x - event.data.origin.x,
				dy = event.data.destination.y - event.data.origin.y,
				dist = Math.min(Math.abs(dx), Math.abs(dy));

			// If we have moved at least 1/4 of a grid space
			if (
				event.data.createState === 2 ||
				dist >= canvas.dimensions.size / 4
			) {
				let isAlt = event.data.originalEvent.altKey;
				tile.data.width = isAlt ? dx : dist * Math.sign(dx);
				tile.data.height = isAlt ? dy : dist * Math.sign(dy);
				event.data.destination = {
					x: tile.data.x + tile.data.width,
					y: tile.data.y + tile.data.height,
				};
				tile.refresh();
				event.data.createState = 2;
			}
		}
	}
}

/**
 * The Tokens Container
 * @type {PlaceablesLayer}
 */
class TokenLayer extends PlaceablesLayer {
	constructor() {
		super();
		this._tabCycle = false;
		this._tabOrder = 0;

		/**
		 * Remember the last drawn wildcard token image to avoid repetitions
		 * @type {string}
		 */
		this._lastWildcard = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get layerOptions() {
		return {
			canDragCreate: false,
			controllableObjects: true,
			rotatableObjects: true,
			snapToGrid: true,
			gridPrecision: 1,
		};
	}

	/* -------------------------------------------- */

	/** @override */
	static get dataArray() {
		return 'tokens';
	}

	/* -------------------------------------------- */

	/** @override */
	static get placeableClass() {
		return Token;
	}

	/* -------------------------------------------- */
	/*  Properties
  /* -------------------------------------------- */

	/**
	 * Token objects on this layer utilize the TokenHUD
	 */
	get hud() {
		return canvas.hud.token;
	}

	/**
	 * An Array of tokens which are currently controlled
	 * @type {Array}
	 */
	get controlledTokens() {
		return Object.values(this._controlled || {});
	}

	/**
	 * An Array of tokens which belong to actors which are owned
	 * @type {Array}
	 */
	get ownedTokens() {
		return this.placeables.filter(t => t.actor && t.actor.owner);
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/** @override */
	deactivate() {
		super.deactivate();
		if (this.objects) this.objects.visible = true;
	}

	/* -------------------------------------------- */

	/**
	 * Drop the Token representing an Actor on the canvas at a specific position
	 * @param {Actor} actor        The ID of the Actor whose token should be dropped
	 * @param {Object} tokenData   An objet of additional Token data with which to override the Actor prototype
	 */
	async dropActor(actor, tokenData) {
		// Get the Token image to use
		if (actor.data.token.randomImg) {
			let images = await actor.getTokenImages();
			images = images.filter(
				i => images.length === 1 || !(i === this._lastWildcard)
			);
			const image = images[Math.floor(Math.random() * images.length)];
			tokenData.img = this._lastWildcard = image;
		}

		// Merge token data with the default
		tokenData = mergeObject(actor.data.token, tokenData, {
			inplace: false,
		});

		// Validate the final position is in-bounds
		if (!canvas.grid.hitArea.contains(tokenData.x, tokenData.y))
			return false;

		// Send the token creation request to the server and wait for acknowledgement
		await Token.create(canvas.scene._id, tokenData);
		this.activate();
	}

	/* -------------------------------------------- */

	/**
	 * Select all the tokens within a provided set of rectangular coordinates.
	 * Control any tokens within the area which you are able to control based on token permissions.
	 * See the parent PlaceablesLayer.selectObject method for more details
	 */
	selectObjects({
		x,
		y,
		width,
		height,
		releaseOptions = {},
		controlOptions = {},
	}) {
		releaseOptions = { releaseSight: false };
		controlOptions = { releaseOthers: false, initializeSight: false };
		const cl = super.selectObjects({
			x,
			y,
			width,
			height,
			releaseOptions,
			controlOptions,
		});
		canvas.sight.initializeSight();
		return cl;
	}

	/* -------------------------------------------- */

	/**
	 * Target all Token instances which fall within a coordinate rectangle.
	 *
	 * @param {number} x                The top-left x-coordinate of the selection rectangle
	 * @param {number} y                The top-left y-coordinate of the selection rectangle
	 * @param {number} width            The width of the selection rectangle
	 * @param {number} height           The height of the selection rectangle
	 * @param {boolean} releaseOthers   Whether or not to release other targeted tokens
	 * @return {number}                 The number of Token instances which were targeted.
	 */
	targetObjects({ x, y, width, height }, { releaseOthers = true } = {}) {
		const user = game.user;

		// Get the set of targeted tokens
		const targets = this.placeables.filter(obj => {
			if (!obj.visible) return false;
			let c = obj.center;
			return (
				Number.between(c.x, x, x + width) &&
				Number.between(c.y, y, y + height)
			);
		});

		// Maybe release other targets
		if (releaseOthers) {
			for (let t of user.targets) {
				if (!targets.includes(t))
					t.setTarget(false, { releaseOthers: false });
			}
		}

		// Acquire targets for tokens which are not yet targeted
		targets.forEach(t => {
			if (!user.targets.has(t))
				t.setTarget(true, { releaseOthers: false });
		});

		// Return the number of targeted tokens
		return user.targets.size;
	}

	/* -------------------------------------------- */

	/**
	 * Cycle the controlled token by rotating through the list of Owned Tokens that are available within the Scene
	 * Tokens are currently sorted in order of their TokenID
	 *
	 * @param {Boolean} direction Which direction to cycle. A "truthy" value cycles forward, while a "falsey" value
	 *                            cycles backwards.
	 * @param {Boolean} reset     Restart the cycle order back at the beginning?
	 * @return {Boolean}          A flag for whether token control was cycled
	 */
	cycleTokens(direction, reset) {
		// Maybe reset
		if (reset) {
			this._tabCycle = false;
			this._tabOrder = -1;
		}

		// If we are not tab cycling, try and jump to the currently controlled or impersonated token
		if (!this._tabCycle) {
			this._tabCycle = true;

			// Get the currently controlled token
			let current = this.controlled.shift();
			if (!current && game.user.character)
				current = game.user.character.getActiveTokens().shift();
			if (current) {
				current.control({ initializeSight: false });
				canvas.animatePan({
					x: current.x,
					y: current.y,
					duration: 250,
				});
				return true;
			}
		}

		// Get the next observable token
		const observable = this.placeables.filter(
			t => t.actor && t.actor.hasPerm(game.user, 'OBSERVER')
		);
		if (!observable.length) return false;

		// Increment the tab order
		if (direction)
			this._tabOrder =
				this._tabOrder < observable.length - 1 ? this._tabOrder + 1 : 0;
		else
			this._tabOrder =
				this._tabOrder > 0 ? this._tabOrder - 1 : observable.length - 1;

		// Control the next token in order
		let next = observable[this._tabOrder];
		next.control();
		canvas.animatePan({ x: next.x, y: next.y, duration: 250 });
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Immediately conclude the animation of any/all tokens
	 */
	concludeAnimation() {
		this.placeables
			.filter(t => t._movement)
			.forEach(t => {
				let ray = t._movement;
				t._movement = null;
				canvas.app.ticker.remove(t._animate, t);
				t.position.set(ray.B.x, ray.B.y);
			});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Handle dropping of Actor data onto the Scene canvas
	 * @private
	 */
	async _onDropActorData(event, data) {
		// Acquire Actor entity
		let actor;
		if (data.pack)
			actor = await game.actors.importFromCollection(data.pack, data.id);
		else actor = game.actors.get(data.id);

		// Acquire cursor position transformed to Canvas coordinates
		let [x, y] = [event.clientX, event.clientY];
		let t = this.worldTransform,
			tx = (x - t.tx) / canvas.stage.scale.x,
			ty = (y - t.ty) / canvas.stage.scale.y;
		let p = canvas.grid.getTopLeft(tx, ty);

		// Prepare Token data specific to this placement
		const tokenData = {
			x: p[0],
			y: p[1],
			hidden: event.altKey,
		};

		// Call the Actor drop method
		this.dropActor(actor, tokenData);
	}
}

/* -------------------------------------------- */

/**
 * The Walls canvas layer which provides a container for {@link Wall} objects within the rendered Scene.
 * @extends {PlaceablesLayer}
 * @see {@link Wall}
 */
class WallsLayer extends PlaceablesLayer {
	constructor() {
		super();

		/**
		 * The Walls Container - just references objects array for backwards compatibility
		 * @type {PIXI.Container}
		 */
		this.walls = this.objects;

		/**
		 * A graphics layer used to display chained Wall selection
		 * @type {PIXI.Graphics}
		 */
		this.chain = null;

		/**
		 * The set of unique vision-blocking wall endpoints
		 * Used to shortcut calculation of line-of-sight
		 * @type {Array}
		 */
		this.endpoints = [];

		/**
		 * Track the most recently created or updated wall data for use with the clone tool
		 * @type {Object}
		 * @private
		 */
		this._cloneType = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	static get dataArray() {
		return 'walls';
	}

	/* -------------------------------------------- */

	/** @override */
	static get layerOptions() {
		return {
			canDragCreate: true,
			controllableObjects: true,
			snapToGrid: true,
		};
	}

	/* -------------------------------------------- */

	/** @override */
	static get placeableClass() {
		return Wall;
	}

	/* -------------------------------------------- */

	/**
	 * An Array of Wall instances in the current Scene which currently block Token vision.
	 * @type {Array.<Wall>}
	 */
	get blockVision() {
		return this.objects.children.filter(w => {
			if (w.data.sense === CONST.WALL_SENSE_TYPES.NONE) return false;
			if (w.data.door > CONST.WALL_DOOR_TYPES.NONE)
				return w.data.ds !== CONST.WALL_DOOR_STATES.OPEN;
			return true;
		});
	}

	/* -------------------------------------------- */

	/**
	 * An Array of Wall instances in the current Scene which block Token movement.
	 * @type {Array.<Wall>}
	 */
	get blockMovement() {
		return this.objects.children.filter(w => {
			if (w.data.move === CONST.WALL_MOVEMENT_TYPES.NONE) return false;
			if (w.data.door > CONST.WALL_DOOR_TYPES.NONE)
				return w.data.ds !== CONST.WALL_DOOR_STATES.OPEN;
			return true;
		});
	}

	/* -------------------------------------------- */

	/**
	 * An Array of Wall instances in the current Scene which act as Doors.
	 * @type {Array.<Wall>}
	 */
	get doors() {
		return this.objects.children.filter(
			w => w.data.door > CONST.WALL_DOOR_TYPES.NONE
		);
	}

	/* -------------------------------------------- */

	/**
	 * Gate the precision of wall snapping to become less precise for small scale maps.
	 * @type {number}
	 */
	get gridPrecision() {
		let size = canvas.dimensions.size;
		if (size >= 128) return 16;
		else if (size >= 64) return 8;
		else if (size >= 32) return 4;
		else if (size >= 16) return 2;
		return 1;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Initialize the Walls Layer. This operation is needed when the canvas is first drawn, or when walls data changes.
	 */
	initialize() {
		this._getVisionEndpoints();
	}

	/* -------------------------------------------- */

	/** @override */
	async draw() {
		await super.draw();
		this.initialize();
		this.chain = this.addChildAt(new PIXI.Graphics(), 0);
		this.highlightControlledSegments();
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * This function returns a set of unique coordinates which represent a wall endpoint.
	 * When the walls layer is modified, we can get and cache the unique wall endpoints so that we have this list
	 * pre-determined for sight and collision checks.
	 * @private
	 * @return {Array}    An Array of points [x,y] which each represent a unique visible wall endpoint
	 */
	_getVisionEndpoints() {
		const unique = new Set();
		for (let w of this.blockVision) {
			unique.add(JSON.stringify(w.coords.slice(0, 2)));
			unique.add(JSON.stringify(w.coords.slice(2)));
		}
		return (this.endpoints = Array.from(unique).map(JSON.parse));
	}

	/* -------------------------------------------- */

	/** @override */
	activate() {
		super.activate();
		if (canvas.controls) canvas.controls.doors.visible = false;
	}

	/* -------------------------------------------- */

	/** @override */
	deactivate() {
		super.deactivate();
		if (this.chain) this.chain.clear();
		if (canvas.controls) canvas.controls.doors.visible = true;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether movement along a given Ray collides with a Wall.
	 * @param {Ray} ray   The attempted movement
	 * @return {boolean}  Does a collision occur?
	 */
	checkCollision(ray) {
		const walls = this.blockMovement;
		if (!walls.length) return false;

		// Never allow movement out of bounds
		if (!canvas.grid.hitArea.contains(ray.B.x, ray.B.y)) return true;

		// Iterate over walls, checking for a collision
		let bounds = [ray.angle - Math.PI / 2, ray.angle + Math.PI / 2];
		for (let w of walls) {
			// Skip directional walls where the ray angle is not in the same hemisphere as the wall direction
			if (w.direction !== null) {
				if (!w.isDirectionBetweenAngles(...bounds)) continue;
			}

			// Test for collision
			let i = ray.intersectSegment(w.coords);
			if (i.t0 > 0 && i.t0 < 1) return true;
		}
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer
	 */
	highlightControlledSegments() {
		if (!this.chain) return;
		const drawn = new Set();
		const c = this.chain.clear();
		for (let p of Object.values(this._controlled)) {
			let p1 = p.coords.slice(0, 2);
			if (!drawn.has(p1.join('.')))
				c.lineStyle(4, 0xff9829).drawRoundedRect(
					p1[0] - 8,
					p1[1] - 8,
					16,
					16,
					3
				);
			let p2 = p.coords.slice(2);
			if (!drawn.has(p2.join('.')))
				c.lineStyle(4, 0xff9829).drawRoundedRect(
					p2[0] - 8,
					p2[1] - 8,
					16,
					16,
					3
				);
			c.lineStyle(8, 0xff9829)
				.moveTo(...p1)
				.lineTo(...p2);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	releaseAll() {
		Object.values(this._controlled).forEach(w => (w._controlled = false));
		this._controlled = {};
		this.chain.clear();
	}

	/* -------------------------------------------- */

	/** @override */
	async pasteObjects(position, options = {}) {
		if (!this._copy.length) return;
		const cls = this.constructor.placeableClass;

		// Transform walls to reference their upper-left coordinates as {x,y}
		const [xs, ys] = this._copy.reduce(
			(arr, w) => {
				arr[0].push(Math.min(w.data.c[0], w.data.c[2]));
				arr[1].push(Math.min(w.data.c[1], w.data.c[3]));
				return arr;
			},
			[[], []]
		);

		// Get the top-left most coordinate
		const topX = Math.min(...xs);
		const topY = Math.min(...ys);

		// Get the magnitude of shift
		const dx = Math.floor(topX - position.x);
		const dy = Math.floor(topY - position.y);
		const shift = [dx, dy, dx, dy];

		// Iterate over objects
		const toCreate = [];
		for (let w of this._copy) {
			let data = duplicate(w.data);
			data.c = data.c.map((c, i) => c - shift[i]);
			delete data.id;
			toCreate.push(data);
		}

		// Call paste hooks
		Hooks.call(`paste${cls.name}`, this._copy, toCreate);

		// Create all objects
		for (let o of toCreate) {
			await cls.create(o);
		}
		ui.notifications.info(
			`Pasted data for ${toCreate.length} ${cls.name} objects.`
		);
		return toCreate;
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onMouseDown(event) {
		event.stopPropagation();
		let { createState, object, originalEvent } = event.data;
		if (object && createState === 2) {
			this._onDragCreate(event);
			if (!(originalEvent.ctrlKey || originalEvent.metaKey)) return;
		}
		super._onMouseDown(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragStart(event) {
		super._onDragStart(event);

		// Construct wall data, coercing location to the nearest pixel
		const data = this._getWallDataFromActiveTool(game.activeTool);

		// Get initial coordinates and construct the new Wall
		let dest = this._getWallEndpointCoordinates(event, event.data.origin);
		data.c = event.data.chainStart
			? event.data.chainStart.concat(dest)
			: dest.concat(dest);
		const wall = new Wall(data).draw();

		// Update event data
		event.data.origin = { x: dest[0], y: dest[1] };
		event.data.object = this.preview.addChild(wall);
		delete event.data.chainStart;
	}

	/* -------------------------------------------- */

	/**
	 * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision
	 * Require snap-to-grid until a redesign of the wall chaining system can occur.
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @param {Object} point
	 * @return {Array}
	 * @private
	 */
	_getWallEndpointCoordinates(event, point) {
		let snapped = canvas.grid.getSnappedPosition(
			point.x,
			point.y,
			this.gridPrecision
		);
		return [snapped.x, snapped.y].map(Math.round);
	}

	/* -------------------------------------------- */

	/**
	 * The Scene Controls tools provide several different types of prototypical Walls to choose from
	 * This method helps to translate each tool into a default wall data configuration for that type
	 * @param {String} tool     The active canvas tool
	 * @private
	 */
	_getWallDataFromActiveTool(tool) {
		// Using the clone tool
		if (tool === 'clone' && this._cloneType) return this._cloneType;

		// Using a wall type
		const wallData = {};
		wallData.move =
			tool === 'ethereal'
				? CONST.WALL_MOVEMENT_TYPES.NONE
				: CONST.WALL_MOVEMENT_TYPES.NORMAL;
		wallData.sense =
			tool === 'invisible'
				? CONST.WALL_SENSE_TYPES.NONE
				: CONST.WALL_SENSE_TYPES.NORMAL;
		if (tool === 'terrain') wallData.sense = CONST.WALL_SENSE_TYPES.LIMITED;
		else if (tool === 'doors') wallData.door = CONST.WALL_DOOR_TYPES.DOOR;
		else if (tool === 'secret')
			wallData.door = CONST.WALL_DOOR_TYPES.SECRET;
		return wallData;
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseMove(event) {
		super._onMouseMove(event);
		if (event.data.createState >= 1) {
			const wall = event.data.object;
			const [x0, y0] = wall.data.c.slice(0, 2);
			const [x1, y1] = [
				event.data.destination.x,
				event.data.destination.y,
			];
			const [gx, gy] = [
				event.data.originalEvent.x,
				event.data.originalEvent.y,
			];

			// If the cursor has moved close to the edge of the window
			this._panCanvasEdge(gx, gy);

			// Draw the wall update
			wall.data.c = [x0, y0, x1, y1];
			wall.refresh();
			event.data.createState = 2;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Pan the canvas view when the cursor position gets close to the edge of the frame
	 * @param {number} x    The x-coordinate
	 * @param {number} y    The y-coordinate
	 * @private
	 */
	_panCanvasEdge(x, y) {
		const pad = 50,
			shift = 500 / canvas.stage.scale.x;
		let dx = 0;
		if (x < pad) dx = -shift;
		else if (x > window.innerWidth - pad) dx = shift;
		let dy = 0;
		if (y < pad) dy = -shift;
		else if (y > window.innerHeight - pad) dy = shift;
		if ((dx || dy) && !this._panning) {
			this._panning = true;
			canvas
				.animatePan(
					{
						x: canvas.stage.pivot.x + dx,
						y: canvas.stage.pivot.y + dy,
					},
					{ duration: 100 }
				)
				.then(() => {
					this._panning = false;
				});
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseUp(event) {
		let { createState, createTime, object } = event.data;
		event.stopPropagation();

		// Handle successful creation and chaining
		if (createState === 2) {
			// Check time to cull double-clicks
			let now = Date.now();
			if (now - (createTime || 0) < 50) return;
			event.data.createTime = now;

			// Create a new Wall
			this._onDragCreate(event);
			if (game.keyboard.isCtrl(event)) {
				event.data.chainStart = object.data.c.slice(2, 4);
				this._onDragStart(event);
			} else event.data.createState = 0;
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragCreate(event) {
		const wall = event.data.object;
		if (!wall) return;
		let [x0, y0] = wall.data.c.slice(0, 2);
		let dest = this._getWallEndpointCoordinates(
			event,
			event.data.destination
		);
		if (!(x0 === dest[0] && y0 === dest[1])) {
			wall.data.c = [x0, y0].concat(dest);
			this.constructor.placeableClass.create(wall.data);
		}
		this._onDragCancel(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDragCancel(event) {
		super._onDragCancel(event);
		delete event.data.chainStart;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDeleteKey(event) {
		super._onDeleteKey(event);
		this.releaseAll();
	}
}

/**
 * The Drawing object is an implementation of the :class:`PlaceableObject` container.
 * Each Drawing is a placeable object in the :class:`DrawingsLayer`.
 * @extends {PlaceableObject}
 *
 * @example
 * Drawing.create({
 *   type: CONST.DRAWING_TYPES.RECTANGLE,
 *   author: game.user._id,
 *   x: 1000,
 *   y: 1000,
 *   width: 800,
 *   height: 600,
 *   fillType: CONST.DRAWING_FILL_TYPES.SOLID,
 *   fillColor: "#0000FF",
 *   fillAlpha: 0.5,
 *   strokeWidth: 4,
 *   strokeColor: "#FF0000",
 *   strokeAlpha: 0.75,
 *   texture: "ui/parchment.jpg",
 *   textureAlpha: 0.5,
 *   text: "HELLO DRAWINGS!",
 *   fontSize: 48,
 *   textColor: "#00FF00",
 *   points: []
 * });
 */
class Drawing extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * The inner drawing container
		 * @type {PIXI.Container}
		 */
		this.drawing = null;

		/**
		 * The primary drawing shape
		 * @type {PIXI.Graphics}
		 */
		this.shape = null;

		/**
		 * Text content, if included
		 * @type {PIXI.Text}
		 */
		this.text = null;

		/**
		 * The Graphics outer frame and handles
		 * @type {PIXI.Container}
		 */
		this.frame = null;

		/**
		 * Internal timestamp for the previous freehand draw time, to limit sampling
		 * @type {Number}
		 * @private
		 */
		this._drawTime = 0;
		this._sampleTime = 0;

		/**
		 * Internal flag for whether the last point in the points array is a temporary one for the purposes of drawing
		 * @type {Boolean}
		 * @private
		 */
		this._tempPoint = false;
	}

	/* -------------------------------------------- */
	/* Object Properties                            */
	/* -------------------------------------------- */

	/**
	 * Provide a reference to the canvas layer which contains placeable objects of this type
	 * @type {PlaceablesLayer}
	 */
	static get layer() {
		return DrawingsLayer;
	}

	/**
	 * The central coordinate pair of a Tile
	 * @return {Object}
	 */
	get center() {
		let { x, y, width, height } = this.data;
		return { x: x + width / 2, y: y + height / 2 };
	}

	/**
	 * Provide a reference to the DrawingConfig sheet used to configure this Drawing instance
	 * @type {DrawingConfig}
	 */
	get sheet() {
		if (!this._sheet) this._sheet = new DrawingConfig(this);
		return this._sheet;
	}

	/**
	 * A reference to the User who created the Drawing object
	 * @type {User}
	 */
	get author() {
		return game.users.get(this.data.author);
	}

	/**
	 * A Boolean flag for whether the current game User has permission to control this token
	 * @type {Boolean}
	 */
	get owner() {
		return (
			game.user.isGM ||
			(game.user.isTrusted && this.data.author === game.user._id)
		);
	}

	/**
	 * A Boolean flag for whether or not the Drawing utilizes a tiled texture background
	 * @type {Boolean}
	 */
	get isTiled() {
		return [
			CONST.DRAWING_FILL_TYPES.PATTERN,
			CONST.DRAWING_FILL_TYPES.CONTOUR,
		].includes(this.data.fillType);
	}

	/**
	 * A Boolean flag for whether or not the Drawing is a Polygon type (either linear or freehand)
	 * @return {Boolean}
	 */
	get isPolygon() {
		return [
			CONST.DRAWING_TYPES.POLYGON,
			CONST.DRAWING_TYPES.FREEHAND,
		].includes(this.data.type);
	}

	/* -------------------------------------------- */
	/* Rendering                                    */
	/* -------------------------------------------- */

	/**
	 * Draw the elements of the Drawing instance
	 * @return {Promise}
	 */
	async draw() {
		this.clear();

		// Load the texture
		if (this.data.texture) {
			this.texture = await loadTexture(this.data.texture).catch(err => {
				console.error(err);
				this.data.texture = '';
				return null;
			});
		} else this.texture = null;

		// Create the inner Drawing container
		this._createDrawing();

		// Control Border
		this._createFrame();

		// Render Appearance
		this.refresh();

		// Enable Interactivity
		this._activateListeners();

		// Return the Drawing
		return this;
	}

	/* -------------------------------------------- */

	_createDrawing() {
		// Drawing container
		this.drawing = this.addChild(new PIXI.Container());

		// Drawing Shape
		this.shape = this.drawing.addChild(new PIXI.Graphics());

		// Overlay Text
		if (this.data.text) {
			this.text = this.drawing.addChild(this._createText());
		}
	}

	/* -------------------------------------------- */

	/**
	 * Create elements for the foreground text
	 * @private
	 */
	_createText() {
		if (this.text) {
			try {
				this.text.destroy();
			} catch (err) {
				console.debug('Error destroying previous drawing text');
			}
			this.text = null;
		}

		// Define the text style
		const textStyle = new PIXI.TextStyle({
			fontFamily: this.data.fontFamily || CONFIG.defaultFontFamily,
			fontSize: this.data.fontSize,
			fill: this.data.textColor || '#FFFFFF',
			stroke: '#111111',
			strokeThickness: Math.max(Math.round(this.data.fontSize / 32), 2),
			dropShadow: true,
			dropShadowColor: '#000000',
			dropShadowBlur: Math.max(Math.round(this.data.fontSize / 16), 2),
			dropShadowAngle: 0,
			dropShadowDistance: 0,
			align: 'center',
			wordWrap: true,
			wordWrapWidth: 1.5 * this.data.width,
		});

		// Create the text container
		return new PIXI.Text(this.data.text, textStyle);
	}

	/* -------------------------------------------- */

	/**
	 * Create elements for the Drawing border and handles
	 * @private
	 */
	_createFrame() {
		this.frame = this.addChild(new PIXI.Container());
		this.frame.border = this.frame.addChild(new PIXI.Graphics());
		this.frame.handle = this.frame.addChild(new PIXI.Graphics());
	}

	/* -------------------------------------------- */

	/**
	 * Repaint the drawing, updating in real time the shape, texture, text and more
	 */
	refresh() {
		if (this._destroyed) return;
		this.shape.clear();

		// Outer Stroke
		if (this.data.strokeWidth) {
			let sc = colorStringToHex(this.data.strokeColor);
			this.shape.lineStyle(
				this.data.strokeWidth,
				sc,
				this.data.strokeAlpha
			);
		}

		// Fill Color or Texture
		if (this.data.fillType) {
			let fc = colorStringToHex(this.data.fillColor);
			let fillOpts = fc ? [fc, this.data.fillAlpha] : [];
			if (this.data.fillType === CONST.DRAWING_FILL_TYPES.PATTERN) {
				this.shape.beginTextureFill(this.texture, ...fillOpts);
			} else {
				this.shape.beginFill(...fillOpts);
			}
		}

		// Draw the shape
		switch (this.data.type) {
			case CONST.DRAWING_TYPES.RECTANGLE:
				this._drawRectangle();
				break;
			case CONST.DRAWING_TYPES.ELLIPSE:
				this._drawEllipse();
				break;
			case CONST.DRAWING_TYPES.POLYGON:
				this._drawPolygon();
				break;
			case CONST.DRAWING_TYPES.FREEHAND:
				if (this.id) this._drawFreehand();
				else this._drawPolygon();
				break;
		}

		// Conclude fills
		this.shape.lineStyle(0x000000, 0.0).closePath();
		this.shape.endFill();

		// Set shape rotation, pivoting about the non-rotated center
		this.shape.pivot.set(this.data.width / 2, this.data.height / 2);
		this.shape.position.set(this.data.width / 2, this.data.height / 2);
		this.shape.rotation = toRadians(this.data.rotation || 0);

		// Draw border frame based on the bounds of the drawing container
		if (this.id && this._controlled) this._refreshFrame();
		else this.frame.visible = false;

		// Update text position and visibility
		if (this.text) {
			this.text.position.set(
				this.data.width / 2 - this.text.width / 2,
				this.data.height / 2 - this.text.height / 2
			);
			this.text.alpha = this.data.textAlpha || 1.0;
		}

		// Toggle visibility
		this.position.set(this.data.x, this.data.y);
		this.drawing.hitArea = new PIXI.Rectangle(
			0,
			0,
			this.data.width,
			this.data.height
		);
		this.alpha = this.data.hidden ? 0.5 : 1.0;
		this.visible = !this.data.hidden || game.user.isGM;
	}

	/* -------------------------------------------- */

	/**
	 * Draw rectangular shapes
	 * @private
	 */
	_drawRectangle() {
		let hs = this.data.strokeWidth / 2;
		this.shape.drawRect(
			hs,
			hs,
			this.data.width - 2 * hs,
			this.data.height - 2 * hs
		);
	}

	/* -------------------------------------------- */

	/**
	 * Draw ellipsoid shapes
	 * @private
	 */
	_drawEllipse() {
		let hw = this.data.width / 2,
			hh = this.data.height / 2,
			hs = this.data.strokeWidth / 2;
		this.shape.drawEllipse(hw, hh, Math.abs(hw) - hs, Math.abs(hh) - hs);
	}

	/* -------------------------------------------- */

	/**
	 * Draw polygonal shapes
	 * @private
	 */
	_drawPolygon() {
		let points = this.data.points || [];
		if (points.length < 2) return;
		else if (points.length === 2) this.shape.endFill();

		// Get drawing points
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);

		// If the polygon is closed, or if we are filling it, we can shortcut using the drawPolygon helper
		if (points.length > 2 && (isClosed || this.data.fillType))
			this.shape.drawPolygon(points.deepFlatten());
		// Otherwise, draw each line individually
		else {
			this.shape.moveTo(...points[0]);
			for (let p of points.slice(1)) {
				this.shape.lineTo(...p);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw freehand shapes with bezier spline smoothing
	 * @private
	 */
	_drawFreehand() {
		let factor = this.data.bezierFactor || 0.1;

		// Get drawing points
		let points = this.data.points;
		let last = points[points.length - 1];
		let isClosed = points[0].equals(last);

		// Handle edge cases
		this.shape.moveTo(...points[0]);
		if (points.length < 2) return;
		else if (points.length === 2) {
			this.shape.lineTo(...points[1]);
			return;
		}

		// Set initial conditions
		let [previous, point] = points.slice(0, 2);
		if (this.data.fillType) points = points.concat([previous, point]);
		let cp0 = this._getBezierControlPoints(factor, last, previous, point)
			.next_cp0;
		let cp1, next_cp0, next;

		// Begin iteration
		for (let i = 1; i < points.length; i++) {
			next = points[i + 1];
			if (next) {
				let bp = this._getBezierControlPoints(
					factor,
					previous,
					point,
					next
				);
				cp1 = bp.cp1;
				next_cp0 = bp.next_cp0;
			}

			// First point
			if (i === 1 && !isClosed) {
				this.shape.quadraticCurveTo(cp1.x, cp1.y, point[0], point[1]);
			}

			// Last Point
			else if (i === points.length - 1 && !isClosed) {
				this.shape.quadraticCurveTo(cp0.x, cp0.y, point[0], point[1]);
			}

			// Bezier points
			else {
				this.shape.bezierCurveTo(
					cp0.x,
					cp0.y,
					cp1.x,
					cp1.y,
					point[0],
					point[1]
				);
			}

			// Increment
			previous = point;
			point = next;
			cp0 = next_cp0;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Attribution: The equations for how to calculate the bezier control points are derived from Rob Spencer's article:
	 * http://scaledinnovation.com/analytics/splines/aboutSplines.html
	 * @param {Number} factor     The smoothing factor
	 * @param {Array} previous    The prior point
	 * @param {Array} point       The current point
	 * @param {Array} next        The next point
	 * @private
	 */
	_getBezierControlPoints(factor, previous, point, next) {
		// Calculate distance vectors
		let vector = { x: next[0] - previous[0], y: next[1] - previous[1] },
			preDistance = Math.hypot(
				previous[0] - point[0],
				previous[1] - point[1]
			),
			postDistance = Math.hypot(next[0] - point[0], next[1] - point[1]),
			distance = preDistance + postDistance;

		// Compute control point locations
		let cp0d = distance === 0 ? 0 : factor * (preDistance / distance),
			cp1d = distance === 0 ? 0 : factor * (postDistance / distance);

		// Return points
		return {
			cp1: {
				x: point[0] - vector.x * cp0d,
				y: point[1] - vector.y * cp0d,
			},
			next_cp0: {
				x: point[0] + vector.x * cp1d,
				y: point[1] + vector.y * cp1d,
			},
		};
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the boundary frame which outlines the Drawing shape
	 * @private
	 */
	_refreshFrame() {
		let { x, y, width, height } = this.drawing.getLocalBounds();
		let pad = 10;
		this.frame.border
			.clear()
			.lineStyle(6.0, 0x000000)
			.drawRect(x - pad, y - pad, width + 2 * pad, height + 2 * pad)
			.lineStyle(2.0, 0xff9829)
			.drawRect(x - pad, y - pad, width + 2 * pad, height + 2 * pad)
			.beginFill(0x000000, 1.0)
			.lineStyle(2.0, 0x00000)
			.drawCircle(x - pad, y - pad, 6)
			.drawCircle(x + width + pad, y - pad, 6)
			.drawCircle(x - pad, y + height + pad, 6);

		// Draw the handle
		this.frame.handle.position.set(x + width + pad, y + height + pad);
		this.frame.handle
			.clear()
			.beginFill(0x000000, 1.0)
			.lineStyle(4.0, 0x000000)
			.drawCircle(0, 0, 10)
			.lineStyle(3.0, 0xff9829)
			.drawCircle(0, 0, 8);
		this.frame.visible = true;
	}

	/* -------------------------------------------- */

	/**
	 * Add a new polygon point to the drawing, ensuring it differs from the last one
	 * @private
	 */
	_addPoint(position, temporary = true) {
		const points = this.data.points || [];
		const point = [position.x - this.data.x, position.y - this.data.y];
		if (points.length > 1 && this._tempPoint) points.pop();
		points.push(point);
		this.data.points = points;
		this._tempPoint = temporary;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @extends {Entity.createEmbeddedEntity} */
	static async create(...args) {
		if (typeof args[0] === 'string') {
			// TODO: Remove in 0.5.x
			console.warn(
				'You are passing the sceneId as the first argument to PlaceableObject.create() which is no longer required'
			);
			args.shift();
		}
		const data = args[0];
		mergeObject(data, this._adjustPoints(data.x, data.y, data.points));
		return super.create(...args);
	}

	/* -------------------------------------------- */

	/** @extends {Entity.updateEmbeddedEntity} */
	async update(...args) {
		if (typeof args[0] === 'string') {
			// TODO: Remove in 0.5.x
			console.warn(
				'You are passing the sceneId as the first argument to PlaceableObject.update() which is no longer required'
			);
			args.shift();
		}
		const [data, options] = args;
		mergeObject(
			data,
			this.constructor._adjustPoints(
				data.x || this.data.x,
				data.y || this.data.y,
				data.points
			)
		);
		return super.update(data, options);
	}

	/* -------------------------------------------- */

	/**
	 * Update the top-left coordinates, width, and height of the drawing based on the provided array of points
	 * @private
	 */
	static _adjustPoints(x, y, points) {
		if (!points || !points.length) return null;

		// De-dupe any points which were repeated in sequence
		points = points.reduce((arr, p1) => {
			let p0 = arr.length ? arr[arr.length - 1] : null;
			if (!p0 || !p1.equals(p0)) arr.push(p1);
			return arr;
		}, []);

		// Adjust points for the minimal x and y values
		const [xs, ys] = points.reduce(
			(arr, p) => {
				arr[0].push(p[0]);
				arr[1].push(p[1]);
				return arr;
			},
			[[], []]
		);

		// Determine minimal and maximal points
		let minX = Math.min(...xs);
		let maxX = Math.max(...xs);
		let minY = Math.min(...ys);
		let maxY = Math.max(...ys);

		// Normalize points
		points = points.map(p => [p[0] - minX, p[1] - minY]);

		// Update data
		return {
			x: x + minX,
			y: y + minY,
			width: maxX - minX,
			height: maxY - minY,
			points: points,
		};
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onUpdate} */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		const redraw = ['type', 'text', 'texture', 'fontSize', 'textColor'];
		if (redraw.some(k => changed.has(k))) this.draw();
		else this.refresh();
		super._onUpdate(data);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * Enable interactivity of the Drawing object
	 * @private
	 */
	_activateListeners() {
		if (!this.id) {
			this.interactive = false;
			return;
		}
		this.interactive = true;

		// Tile control
		new HandleManager(
			this.drawing,
			this.layer,
			{
				mouseover: this._onMouseOver.bind(this),
				mouseout: this._onMouseOut.bind(this),
				mousemove: this._onMouseMove.bind(this),
				mousedown: this._onMouseDown.bind(this),
				mouseup: this._onMouseUp.bind(this),
				doubleleft: this._onDoubleLeft.bind(this),
				rightdown: this._onRightDown.bind(this),
				cancel: this._onDragCancel.bind(this),
			},
			{
				candrag: event => !this.data.locked,
				canright: event => this._controlled,
				canclick: event =>
					this._controlled ||
					(this.owner && game.activeTool === 'select'),
				canhover: event =>
					this._controlled ||
					(this.owner && game.activeTool === 'select'),
			}
		);

		// Scale handler
		new HandleManager(
			this.frame.handle,
			this.layer,
			{
				mouseover: event => this._onHandleMouseOver(event),
				mouseout: event => this._onHandleMouseOut(event),
				mousedown: event => this._onHandleMouseDown(event),
				mousemove: event => this._onHandleMouseMove(event),
				mouseup: event => this._onHandleMouseUp(event),
			},
			{
				canclick: event => !this.data.locked,
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse movement which modifies the dimensions of the drawn shape
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onMouseDraw(event) {
		let position = event.data.destination,
			isShift = event.data.originalEvent.shiftKey,
			isAlt = event.data.originalEvent.altKey;

		// Determine position
		if (!isShift && this.data.type !== CONST.DRAWING_TYPES.FREEHAND) {
			position = canvas.grid.getSnappedPosition(
				position.x,
				position.y,
				this.layer.gridPrecision
			);
		} else {
			position = { x: parseInt(position.x), y: parseInt(position.y) };
		}

		// Drag differently depending on shape type
		switch (this.data.type) {
			// Freehand Shapes
			case CONST.DRAWING_TYPES.FREEHAND:
				const now = Date.now();

				// If the time since any drawing activity last occurred exceeds the sample rate - upgrade the prior point
				if (
					now - this._drawTime >=
					this.constructor.FREEHAND_SAMPLE_RATE
				) {
					this._tempPoint = false;
					this._sampleTime = now;
				}

				// Determine whether the new point should be permanent based on the time since last sample
				let takeSample =
					now - this._drawTime >=
					this.constructor.FREEHAND_SAMPLE_RATE;
				this._drawTime = takeSample ? now : this._drawTime;
				this._addPoint(position, !takeSample);
				break;

			// Polygon Shapes
			case CONST.DRAWING_TYPES.POLYGON:
				this._addPoint(position, true);
				break;

			// Geometric Shapes
			default:
				let dx = position.x - this.data.x;
				let dy = position.y - this.data.y;
				if (dx === 0)
					dx =
						canvas.dimensions.size *
						Math.sign(this.data.width) *
						0.5;
				if (dy === 0)
					dy =
						canvas.dimensions.size *
						Math.sign(this.data.height) *
						0.5;
				if (isAlt) {
					dx =
						Math.abs(dy) < Math.abs(dx)
							? Math.abs(dy) * Math.sign(dx)
							: dx;
					dy =
						Math.abs(dx) < Math.abs(dy)
							? Math.abs(dx) * Math.sign(dy)
							: dy;
				}
				this.data.width = dx;
				this.data.height = dy;
		}

		// Refresh the display
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-over events for the rescaling handle
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHandleMouseOver(event) {
		this.frame.handle.scale.set(1.5, 1.5);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out events for the rescaling handle
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHandleMouseOut(event) {
		this.frame.handle.scale.set(1.0, 1.0);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-down events for the rescaling handle
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHandleMouseDown(event) {
		event.data.original = duplicate(this.data);
		event.data.origin = {
			x: this.data.x + this.data.width,
			y: this.data.y + this.data.height,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-move events for the rescaling handle
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHandleMouseMove(event) {
		const { origin, original, destination } = event.data;
		let dx = destination.x - origin.x,
			dy = destination.y - origin.y;
		this._rescaleDimensions(original, dx, dy);
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Apply a vectorized rescaling transformation for the drawing data
	 * @param {Object} original     The original drawing data
	 * @param {Number} dx           The pixel distance dragged in the horizontal direction
	 * @param {Number} dy           The pixel distance dragged in the vertical direction
	 * @private
	 */
	_rescaleDimensions(original, dx, dy) {
		const { points, width, height } = original;
		if (this.isPolygon) {
			let scaleX = 1 + dx / original.width,
				scaleY = 1 + dy / original.height;
			this.data.points = points.map(p => [p[0] * scaleX, p[1] * scaleY]);
		} else {
			this.data.width = width + dx;
			this.data.height = height + dy;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-up events for the rescaling handle
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onHandleMouseUp(event) {
		let { origin, original, originalEvent, destination } = event.data;
		if (!originalEvent.shiftKey) {
			destination = canvas.grid.getSnappedPosition(
				destination.x,
				destination.y,
				this.layer.gridPrecision
			);
		}
		let dx = destination.x - origin.x,
			dy = destination.y - origin.y;
		this._rescaleDimensions(original, dx, dy);

		// Update the Drawing
		const updateData = {
			width: this.data.width,
			height: this.data.height,
			points: this.data.points,
		};
		this.data = original;
		return this.update(this.scene._id, updateData);
	}
}

Drawing.FREEHAND_SAMPLE_RATE = 100;
/**
 * An AmbientLight is an implementation of PlaceableObject which represents a dynamic light source within the Scene.
 * @extends {PlaceableObject}
 *
 * @example
 * AmbientLight.create({
 *   t: "l",
 *   x: 1000,
 *   y: 1000,
 *   rotation: 0,
 *   dim: 30,
 *   bright: 15,
 *   angle: 360,
 *   tintColor: "#FF0000",
 *   tintAlpha: 0.05
 * });
 */
class AmbientLight extends PlaceableObject {
	/* -------------------------------------------- */
	/* Properties
  /* -------------------------------------------- */

	/** @override */
	static get layer() {
		return LightingLayer;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether a specific AmbientLight source provides global illumination
	 * @type {Boolean}
	 */
	get global() {
		return this.data.t === 'g';
	}

	/* -------------------------------------------- */

	/**
	 * Get the pixel radius of dim light emitted by this light source
	 * @return {Number}
	 */
	get dimRadius() {
		let d = canvas.dimensions;
		return (this.data.dim / d.distance) * d.size;
	}

	/* -------------------------------------------- */

	/**
	 * Get the pixel radius of bright light emitted by this light source
	 * @return {Number}
	 */
	get brightRadius() {
		let d = canvas.dimensions;
		return (this.data.bright / d.distance) * d.size;
	}

	/* -------------------------------------------- */

	get hasTint() {
		return ![undefined, null, ''].includes(this.data.tintColor);
	}

	/* -------------------------------------------- */

	/**
	 * Get a reference to the LightConfig sheet that is used to configure this light source
	 * @return {LightConfig}
	 */
	get sheet() {
		if (!this._sheet) this._sheet = new LightConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */
	/* Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the Light source
	 */
	draw() {
		this.clear();

		// Draw components
		this.field = this.drawField();
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Draw the light field graphic
		this.refresh();

		// Add control interactivity if the placeable has an ID
		if (this.id) {
			new HandleManager(this.controlIcon, this.layer, {
				mouseover: event => this._onMouseOver(event),
				mouseout: event => this._onMouseOut(event),
				mousemove: event => this._onMouseMove(event),
				mouseup: event => this._onMouseUp(event),
				doubleleft: event => this._onDoubleLeft(event),
				cancel: event => this._onDragCancel(event),
			});
		}
		return this;
	}

	/* -------------------------------------------- */

	drawField() {
		let field = new PIXI.Container();

		// Light field tint
		field.light = field.addChild(new PIXI.Graphics());
		field.light.blendMode = PIXI.BLEND_MODES.OVERLAY;
		field.light.alpha = this.data.tintAlpha || 0.1;
		field.light.filters = [new PIXI.filters.BlurFilter(10)];

		// Area guide lines
		field.lines = field.addChild(new PIXI.Graphics());

		// Masking polygon
		field.msk = field.addChild(new PIXI.Graphics());
		field.msk.position.set(...this.coords.map(c => -1 * c));
		field.mask = field.msk;
		return this.addChild(field);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		let icon = new ControlIcon({ texture: 'icons/svg/fire.svg', size: 40 });
		icon.x -= 22;
		icon.y -= 22;
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Render the light field which previews the light source area of effect
	 */
	refresh() {
		// Update position and FOV
		this.position.set(this.data.x, this.data.y);
		this.computeFOV();

		// Draw the light field
		let dimR = Math.abs(this.dimRadius);
		let brightR = Math.abs(this.brightRadius);
		this.field.lines
			.clear()
			.lineStyle(1, 0xffffff, 0.5)
			.drawCircle(0, 0, dimR)
			.lineStyle(1, 0xffffff, 0.5)
			.drawCircle(0, 0, brightR);

		// Update the tint field
		let color =
			Math.min(this.dimRadius, this.brightRadius) < 0
				? 0xff6633
				: 0xffcc99;
		if (this.hasTint) color = colorStringToHex(this.data.tintColor);
		this.field.light
			.clear()
			.beginFill(color, 1.0)
			.drawCircle(0, 0, Math.max(dimR, brightR))
			.endFill();

		// Update the masking polygon
		this.field.msk
			.clear()
			.beginFill(0xffffff)
			.drawPolygon(this.fov)
			.endFill();
		this.field.msk.position.set(-this.data.x, -this.data.y);

		// Update visibility
		const layerActive = this.layer._active;
		this.controlIcon.visible = layerActive;
		this.field.light.visible = layerActive || this.hasTint;
		this.field.lines.visible = layerActive;
	}

	/* -------------------------------------------- */

	/**
	 * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
	 * @returns {Object}      An object containing the rays, LOS polygon, and FOV polygon for the light
	 */
	computeFOV() {
		const radius =
			Math.max(Math.abs(this.dimRadius), Math.abs(this.brightRadius)) +
			canvas.dimensions.size * 0.1;
		let [rays, los, fov] = canvas.sight.checkSight(this.center, radius, {
			angle: this.data.angle,
			cullMultiplier: 1.0,
			radialDensity: 6.0,
			rotation: this.data.rotation,
		});
		this.fov = fov;
		return { rays, los, fov };
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onCreate} */
	_onCreate() {
		super._onCreate();
		canvas.addPendingOperation(
			`SightLayer.initialize`,
			canvas.sight.initialize,
			canvas.sight
		);
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onUpdate} */
	_onUpdate(data) {
		super._onUpdate(data);
		this.draw();
		canvas.addPendingOperation(
			`SightLayer.initialize`,
			canvas.sight.initialize,
			canvas.sight
		);
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onDelete} */
	_onDelete() {
		super._onDelete();
		canvas.addPendingOperation(
			`SightLayer.initialize`,
			canvas.sight.initialize,
			canvas.sight
		);
	}
}

/**
 * A Note is an implementation of PlaceableObject which represents an annotated location within the Scene.
 * Each Note links to a JournalEntry entity and represents it's location on the map.
 * @extends {PlaceableObject}
 *
 * @example
 * Note.create({
 *   entryId: journalEntry.id,
 *   x: 1000,
 *   y: 1000,
 *   icon: "icons/my-journal-icon.svg",
 *   iconSize: 40,
 *   iconTint: "#00FF000",
 *   text: "A custom label",
 *   fontSize: 48,
 *   textAnchor: CONST.TEXT_ANCHOR_POINTS.CENTER,
 *   textColor: "#00FFFF"
 * });
 */
class Note extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * The associated JournalEntry which is described by this note
		 * @type {JournalEntry}
		 */
		this.entry = game.journal.get(this.data.entryId);
	}

	/* -------------------------------------------- */
	/* Attributes
  /* -------------------------------------------- */

	/** @override */
	static get layer() {
		return NotesLayer;
	}

	/* -------------------------------------------- */

	/** @override */
	get sheet() {
		return new NoteConfig(this);
	}

	/* -------------------------------------------- */

	/**
	 * Return the text label which describes the Note
	 * Use a manually specified label with a fallback to the JournalEntry name
	 * @type {string}
	 */
	get text() {
		return this.data.text || (this.entry ? this.entry.name : 'Unknown');
	}

	/* -------------------------------------------- */

	/**
	 * The Map Note icon size
	 * @type {number}
	 */
	get size() {
		return this.data.iconSize || 40;
	}

	/* -------------------------------------------- */
	/* Rendering
  /* -------------------------------------------- */

	/** @override */
	draw() {
		this.clear();

		// Draw components
		this.controlIcon = this.addChild(this._drawControlIcon());
		this.tooltip = this.addChild(this._drawTooltip());
		this.refresh();

		// Add control interactivity if the placeable has an ID
		if (this.id) {
			new HandleManager(
				this.controlIcon,
				this.layer,
				{
					mouseover: event => this._onMouseOver(event),
					mouseout: event => this._onMouseOut(event),
					mousemove: event => this._onMouseMove(event),
					mouseup: event => this._onMouseUp(event),
					doubleleft: event => this._onDoubleLeft(event),
					doubleright: event => this._onDoubleRight(event),
					cancel: event => this._onDragCancel(event),
				},
				{
					canhover: true,
					canclick:
						this.entry && this.entry.hasPerm(game.user, 'LIMITED'),
					canright: game.user.isGM,
					candrag: game.user.isGM,
				}
			);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the Map Note
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		let tint = this.data.iconTint
			? colorStringToHex(this.data.iconTint)
			: null;
		let icon = new ControlIcon({
			texture: this.data.icon,
			size: this.size,
			tint: tint,
		});
		icon.x -= this.size / 2;
		icon.y -= this.size / 2;
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the map note Tooltip as a Text object
	 * @return {PIXI.Text}
	 */
	_drawTooltip() {
		// Create the Text object
		const textStyle = this._getTextStyle();
		const text = new PIXI.Text(this.text, textStyle);
		text.visible = false;
		const halfPad = 0.5 * this.size + 12;

		// Configure Text position
		switch (this.data.textAnchor) {
			case CONST.TEXT_ANCHOR_POINTS.CENTER:
				text.anchor.set(0.5, 0.5);
				text.position.set(0, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.BOTTOM:
				text.anchor.set(0.5, 0);
				text.position.set(0, halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.TOP:
				text.anchor.set(0.5, 1);
				text.position.set(0, -halfPad);
				break;
			case CONST.TEXT_ANCHOR_POINTS.LEFT:
				text.anchor.set(1, 0.5);
				text.position.set(-halfPad, 0);
				break;
			case CONST.TEXT_ANCHOR_POINTS.RIGHT:
				text.anchor.set(0, 0.5);
				text.position.set(halfPad, 0);
				break;
		}
		return text;
	}

	/* -------------------------------------------- */

	/**
	 * Define a PIXI TextStyle object which is used for the tooltip displayed for this Note
	 * @returns {PIXI.TextStyle}
	 */
	_getTextStyle() {
		// Text alignment based on anchor point
		let align = 'center';
		if (this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.LEFT)
			align = 'right';
		else if (this.data.textAnchor === CONST.TEXT_ANCHOR_POINTS.RIGHT)
			align = 'left';

		// Return TextStyle object
		return new PIXI.TextStyle({
			fontFamily: 'Signika',
			fontSize: this.data.fontSize,
			fill: this.data.textColor,
			stroke: '#111111',
			strokeThickness: 1,
			dropShadow: true,
			dropShadowColor: '#000000',
			dropShadowBlur: 4,
			dropShadowAngle: 0,
			dropShadowDistance: 0,
			align: align,
			wordWrap: false,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		this.position.set(this.data.x, this.data.y);
		this.visible = this.entry
			? this.entry.hasPerm(game.user, 'LIMITED')
			: true;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers
  /* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		if (changed.has('entryId')) this.entry = game.journal.get(data.entryId);
		this.draw();
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onMouseOver} */
	_onMouseOver(event) {
		super._onMouseOver(event);
		this.tooltip.visible = true;
	}

	/* -------------------------------------------- */

	/** @extends {PlaceableObject._onMouseOut} */
	_onMouseOut(event) {
		super._onMouseOut(event);
		this.tooltip.visible = false;
	}

	/* -------------------------------------------- */

	/** @override */
	_onDoubleLeft(event) {
		const entry = this.entry;
		if (entry) entry.sheet.render(true);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDoubleRight(event) {
		super._onDoubleLeft(event);
	}
}

/**
 * An AmbientSound is an implementation of PlaceableObject which represents a dynamic audio source within the Scene.
 * @extends {PlaceableObject}
 *
 * @example
 * AmbientSound.create({
 *   t: "l",
 *   x: 1000,
 *   y: 1000,
 *   radius: 60,
 *   easing: true,
 *   path: "sounds/audio-file.mp3",
 *   repeat: true,
 *   volume: 0.4
 * });
 */
class AmbientSound extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * The Howl instance used to play this AmbientSound effect
		 * @type {Howl}
		 */
		this.howl = this._createHowl();

		/**
		 * The Howl sound ID of the playing instance of this sound
		 * @type {Number}
		 */
		this.howlId = undefined;
	}

	/* -------------------------------------------- */

	/**
	 * Create an audio helper instance to use for the Ambient Sound
	 * @return {Object|null}
	 * @private
	 */
	_createHowl() {
		if (!this.data.path) return null;
		return game.audio.create({
			src: this.data.path,
			preload: true,
			loop: true,
			volume: Number(this.data.volume),
		});
	}

	/* -------------------------------------------- */

	/** @override */
	static get layer() {
		return SoundsLayer;
	}

	/* -------------------------------------------- */
	/* Properties
  /* -------------------------------------------- */

	/**
	 * A convenience accessor for the sound type
	 * @return {string}
	 */
	get type() {
		return this.data.type;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the sound radius in pixels
	 * @return {number}
	 */
	get radius() {
		let d = canvas.dimensions;
		return (this.data.radius / d.distance) * d.size;
	}

	/* -------------------------------------------- */

	/** @override */
	get sheet() {
		if (!this._sheet) this._sheet = new AmbientSoundConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */
	/* Methods
  /* -------------------------------------------- */

	/**
	 * Toggle playback of the sound depending on whether or not it is audible
	 * @param {Boolean} isAudible   Is the sound audible?
	 * @param {Number} volume       The target playback volume
	 */
	play(isAudible, volume) {
		let howl = this.howl;
		let cv = howl.volume(null, this.howlId);
		volume =
			(volume || this.data.volume) *
			game.settings.get('core', 'globalAmbientVolume');

		// Fade the sound out if not currently audible
		if (!isAudible) {
			if (this.howlId) {
				howl.fade(cv, 0, 500);
				howl.once('fade', () => howl.pause(this.howlId));
			}
			return;
		}
		if (howl.state() !== 'loaded') howl.load();

		// Begin playback and set volume
		this.howlId = this.howlId ? howl.play(this.howlId) : howl.play();
		howl.fade(cv, volume, 500, this.howlId);
		return this.howlId;
	}

	/* -------------------------------------------- */
	/* Rendering
  /* -------------------------------------------- */

	/**
	 * Clear the display of the existing object
	 */
	clear() {
		if (this.controlIcon) {
			this.controlIcon.parent.removeChild(this.controlIcon).destroy();
			this.controlIcon = null;
		}
		super.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Draw the AmbientSound source
	 */
	draw() {
		this.clear();

		// Draw components
		this.field = this.drawField();
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Render the Sound appearance
		this.refresh();

		// Add control interactivity if the placeable has an ID
		if (this.id) {
			new HandleManager(this.controlIcon, this.layer, {
				mouseover: event => this._onMouseOver(event),
				mouseout: event => this._onMouseOut(event),
				mousemove: event => this._onMouseMove(event),
				mouseup: event => this._onMouseUp(event),
				doubleleft: event => this._onDoubleLeft(event),
				cancel: event => this._onDragCancel(event),
			});
		}
		return this;
	}

	/* -------------------------------------------- */

	drawField() {
		let field = new PIXI.Container();
		field.light = field.addChild(new PIXI.Graphics());
		field.msk = field.addChild(new PIXI.Graphics());
		field.msk.position.set(...this.coords.map(c => -1 * c));
		field.mask = field.msk;
		return this.addChild(field);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the AmbientLight
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		let icon = new ControlIcon({
			texture: 'icons/svg/sound.svg',
			size: 40,
		});
		icon.x -= 20;
		icon.y -= 20;
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the AmbientSound appearance by populating child Graphics elements.
	 */
	refresh() {
		// Update position and FOV
		this.position.set(this.data.x, this.data.y);
		this.computeFOV();

		// Draw the light field
		this.field.light
			.clear()
			.beginFill(0xaaddff, 0.15)
			.lineStyle(1, 0xffffff, 0.5)
			.drawCircle(0, 0, this.radius)
			.endFill();

		// Global light is not masked
		if (this.type === 'g') {
			this.field.msk.clear();
			this.field.mask = null;
		}

		// Local light is masked by the FOV polygon
		else {
			this.field.msk
				.clear()
				.beginFill(0xffffff)
				.drawPolygon(this.fov)
				.endFill();
			this.field.msk.position.set(-this.data.x, -this.data.y);
			this.field.mask = this.field.msk;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
	 * @returns {Object}      An object containing the rays, LOS polygon, and FOV polygon for the light
	 */
	computeFOV() {
		// Global audio
		if (this.type === 'g') {
			this.fov = new PIXI.Circle(
				...Object.values(this.center),
				this.radius
			);
			return { rays: null, fov: this.fov, los: null };
		}

		// Local audio
		else {
			let r = this.radius * 1.02;
			let [rays, los, fov] = canvas.sight.checkSight(this.center, r, {
				cullMultiplier: 1,
				radialDensity: 6,
			});
			this.fov = fov;
			return { rays, los, fov };
		}
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	_onCreate() {
		canvas.addPendingOperation(
			`SoundsLayer.initialize`,
			canvas.sounds.initialize,
			canvas.sounds
		);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));
		if (changed.has('path')) this.howl = this._createHowl();
		this.draw();
		canvas.addPendingOperation(
			`SoundsLayer.initialize`,
			canvas.sounds.initialize,
			canvas.sounds
		);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete() {
		if (this.howl) this.howl.stop(this.howlId);
		canvas.addPendingOperation(
			`SoundsLayer.initialize`,
			canvas.sounds.initialize,
			canvas.sounds
		);
	}
}

/**
 * A MeasuredTemplate is an implementation of PlaceableObject which represents an area of the canvas grid which is
 * covered by some effect.
 * @extends {PlaceableObject}
 *
 * @example
 * MeasuredTemplate.create({
 *   t: "cone",
 *   user: game.user._id,
 *   x: 1000,
 *   y: 1000,
 *   direction: 0.45,
 *   angle: 63.13,
 *   distance: 30,
 *   borderColor: "#FF0000",
 *   fillColor: "#FF3366",
 *   texture: "tiles/fire.jpg"
 * });
 */
class MeasuredTemplate extends PlaceableObject {
	constructor(...args) {
		super(...args);

		// Draw portions of the content
		this.controlIcon = null;
		this.template = null;
		this.ruler = null;

		/**
		 * The tiling texture used for this template, if any
		 * @type {PIXI.Texture}
		 */
		this.texture = null;

		/**
		 * The template shape used for testing point intersection
		 * @type {PIXI.Circle | PIXI.Ellipse | PIXI.Polygon | PIXI.Rectangle | PIXI.RoundedRectangle}
		 */
		this.shape = null;

		/**
		 * Create a highlighting layer to use for this Template
		 */
		canvas.grid.addHighlightLayer(`Template.${this.id}`);

		/**
		 * Internal property used to configure the control border thickness
		 * @type {number}
		 * @private
		 */
		this._borderThickness = 3;
	}

	/* -------------------------------------------- */
	/* Properties
  /* -------------------------------------------- */

	/** @override */
	static get layer() {
		return TemplateLayer;
	}

	/** @override */
	get sheet() {
		if (!this._sheet) this._sheet = new MeasuredTemplateConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the border color as a numeric hex code
	 * @return {number}
	 */
	get borderColor() {
		return this.data.borderColor
			? this.data.borderColor.replace('#', '0x')
			: 0x000000;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience accessor for the fill color as a numeric hex code
	 * @return {number}
	 */
	get fillColor() {
		return this.data.fillColor
			? this.data.fillColor.replace('#', '0x')
			: 0x000000;
	}

	/* -------------------------------------------- */
	/*  Rendering
  /* -------------------------------------------- */

	/** @override */
	async draw() {
		// Clear existing and set position
		this.clear();

		// Load the texture
		if (this.data.texture) {
			this.texture = await loadTexture(this.data.texture).catch(err => {
				console.error(err);
				this.data.texture = '';
				return null;
			});
		} else this.texture = null;

		// Template shape
		this.template = this.addChild(new PIXI.Graphics());

		// Rotation handle
		this.handle = this.addChild(new PIXI.Graphics());

		// Draw the control icon
		this.controlIcon = this.addChild(this._drawControlIcon());

		// Draw the ruler measurement
		this.ruler = this.addChild(
			new PIXI.Text(null, CONFIG.canvasTextStyle.clone())
		);

		// Update the shape and highlight grid squares
		this.refresh();

		// Highlight
		this._highlightGrid();

		// Add control interactivity if the placeable has an ID
		if (this.id) {
			new HandleManager(this.controlIcon, this.layer, {
				mouseover: event => this._onMouseOver(event),
				mouseout: event => this._onMouseOut(event),
				mousemove: event => this._onMouseMove(event),
				mouseup: event => this._onMouseUp(event),
				doubleleft: event => this._onDoubleLeft(event),
				cancel: event => this._onDragCancel(event),
			});
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the ControlIcon for the MeasuredTemplate
	 * @return {ControlIcon}
	 * @private
	 */
	_drawControlIcon() {
		let icon = new ControlIcon({
			texture: 'icons/svg/explosion.svg',
			size: 40,
		});
		icon.x -= 20;
		icon.y -= 20;
		return icon;
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		let d = canvas.dimensions;
		this.position.set(...this.coords);

		// Extract and prepare data
		let { direction, distance, angle, width } = this.data;
		distance *= d.size / d.distance;
		width *= d.size / d.distance;
		direction = toRadians(direction);

		// Create ray and bounding rectangle
		this.ray = Ray.fromAngle(...this.coords, direction, distance);

		// Get the Template shape
		switch (this.data.t) {
			case 'circle':
				this.shape = this._getCircleShape(distance);
				break;
			case 'cone':
				this.shape = this._getConeShape(direction, angle, distance);
				break;
			case 'rect':
				this.shape = this._getRectShape(direction, distance);
				break;
			case 'ray':
				this.shape = this._getRayShape(direction, distance, width);
		}

		// Draw the Template outline
		this.template
			.clear()
			.lineStyle(this._borderThickness, this.borderColor, 0.75)
			.beginFill(0x000000, 0.0);

		// Fill Color or Texture
		if (this.texture) this.template.beginTextureFill(this.texture);
		else this.template.beginFill(0x000000, 0.0);

		// Draw the shape
		this.template.drawShape(this.shape);

		// Draw origin and destination points
		this.template
			.lineStyle(this._borderThickness, 0x000000)
			.drawCircle(0, 0, 8)
			.drawCircle(this.ray.dx, this.ray.dy, 8);

		// Draw ruler text
		this._refreshRulerText();
	}

	/* -------------------------------------------- */

	/**
	 * Get a Circular area of effect given a radius of effect
	 * @private
	 */
	_getCircleShape(distance) {
		return new PIXI.Circle(0, 0, distance);
	}

	/* -------------------------------------------- */

	/**
	 * Get a Conical area of effect given a direction, angle, and distance
	 * @private
	 */
	_getConeShape(direction, angle, distance) {
		angle = angle || 90;
		const coneType = game.settings.get('core', 'coneTemplateType');

		// For round cones - approximate the shape with a ray every 3 degrees
		let angles;
		if (coneType === 'round') {
			const da = Math.min(angle, 3);
			angles = Array.fromRange(angle / da)
				.map(a => angle / -2 + a * da)
				.concat([angle / 2]);
		}

		// For flat cones, direct point-to-point
		else angles = [angle / -2, angle / 2];

		// Get the cone shape as a polygon
		const rays = angles.map(a =>
			Ray.fromAngle(0, 0, direction + toRadians(a), distance + 1)
		);
		const points = rays
			.reduce(
				(arr, r) => {
					return arr.concat([r.B.x, r.B.y]);
				},
				[0, 0]
			)
			.concat([0, 0]);
		return new PIXI.Polygon(points);
	}

	/* -------------------------------------------- */

	/**
	 * Get a Rectangular area of effect given a width and height
	 * @private
	 */
	_getRectShape(direction, distance) {
		let d = canvas.dimensions,
			r = Ray.fromAngle(0, 0, direction, distance),
			dx = Math.round(r.dx / (d.size / 2)) * (d.size / 2),
			dy = Math.round(r.dy / (d.size / 2)) * (d.size / 2);

		// Create rectangle shape and draw
		return new PIXI.Rectangle(
			Math.min(0, dx),
			Math.min(0, dy),
			Math.abs(dx) + 1,
			Math.abs(dy) + 1
		);
	}

	/* -------------------------------------------- */

	/**
	 * Get a rotated Rectangular area of effect given a width, height, and direction
	 * @private
	 */
	_getRayShape(direction, distance, width) {
		let up = Ray.fromAngle(0, 0, direction - toRadians(90), width / 2 + 1),
			down = Ray.fromAngle(
				0,
				0,
				direction + toRadians(90),
				width / 2 + 1
			),
			l1 = Ray.fromAngle(up.B.x, up.B.y, direction, distance + 1),
			l2 = Ray.fromAngle(down.B.x, down.B.y, direction, distance + 1);

		// Create Polygon shape and draw
		const points = [
			down.B.x,
			down.B.y,
			up.B.x,
			up.B.y,
			l1.B.x,
			l1.B.y,
			l2.B.x,
			l2.B.y,
			down.B.x,
			down.B.y,
		];
		return new PIXI.Polygon(points);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the rotation control handle and assign event listeners
	 * @private
	 */
	_drawRotationHandle(radius) {
		this.handle
			.clear()
			.lineStyle(this._borderThickness, 0x000000)
			.beginFill(this.borderColor, 1.0)
			.drawCircle(0, 0, radius);
	}

	/* -------------------------------------------- */

	/**
	 * Update the displayed ruler tooltip text
	 * @private
	 */
	_refreshRulerText() {
		let text;
		let u = canvas.scene.data.gridUnits;
		if (this.data.t === 'rect') {
			let d = canvas.dimensions;
			let dx = Math.round(this.ray.dx) * (d.distance / d.size);
			let dy = Math.round(this.ray.dy) * (d.distance / d.size);
			let w = Math.round(dx * 10) / 10;
			let h = Math.round(dy * 10) / 10;
			text = `${w}${u} x ${h}${u}`;
		} else {
			let d = Math.round(this.data.distance * 10) / 10;
			text = `${d}${u}`;
		}
		this.ruler.text = text;
		this.ruler.position.set(this.ray.dx, this.ray.dy);
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the grid squares which should be shown under the area of effect
	 */
	_highlightGrid() {
		const grid = canvas.grid,
			d = canvas.dimensions,
			bc = this.borderColor,
			fc = this.fillColor;

		// Only highlight for objects which have a defined shape
		if (!this.id || !this.shape) return;

		// Clear existing highlight
		const hl = grid.getHighlightLayer(`Template.${this.id}`);
		hl.clear();

		// Get number of rows and columns
		let nr = Math.ceil(
				(this.data.distance * 1.5) / d.distance / (d.size / grid.h)
			),
			nc = Math.ceil(
				(this.data.distance * 1.5) / d.distance / (d.size / grid.w)
			);

		// Get the center of the grid position occupied by the template
		let [cx, cy] = grid.getCenter(this.data.x, this.data.y),
			[tx, ty] = canvas.grid.getTopLeft(this.data.x, this.data.y),
			[ox, oy] = [cx - tx, cy - ty],
			[row0, col0] = grid.grid.getGridPositionFromPixels(cx, cy);

		// Identify grid coordinates covered by the template Graphics
		for (let r = -nr; r < nr; r++) {
			for (let c = -nc; c < nc; c++) {
				let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(
					row0 + r,
					col0 + c
				);
				let testX = gx - this.data.x + ox;
				let testY = gy - this.data.y + oy;
				let contains = this.shape.contains(testX, testY);
				if (!contains) continue;
				grid.grid.highlightGridPosition(hl, {
					x: gx,
					y: gy,
					color: fc,
					border: bc,
				});
			}
		}
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Rotate the MeasuredTemplate by some a certain angle of facing
	 * @param {number} angle    The desired angle of rotation
	 * @param {number} snap     Snap the angle of rotation to a certain target degree increment
	 * @return {Promise}        A Promise which resolves once the rotation has completed
	 */
	async rotate(angle, snap) {
		angle = angle % 360;
		if (Number.isFinite(snap)) angle = Math.round(angle / snap) * snap;
		return this.update(this.scene._id, { direction: angle });
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		const changed = new Set(Object.keys(data));

		// If the texture or type was changed, we need to re-draw the whole thing
		const redraw = ['texture', 'type'];
		if (redraw.some(k => changed.has(k))) return this.draw();

		// Otherwise refresh the display and highlighting
		this.refresh();
		this._highlightGrid();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete() {
		canvas.grid.destroyHighlightLayer(`Template.${this.id}`);
	}
}

CONFIG.templateTypes = {
	circle: 'Circle',
	cone: 'Cone',
	rect: 'Rectangle',
	ray: 'Ray',
};

/**
 * A Tile is an implementation of PlaceableObject which represents a static piece of artwork or prop within the Scene.
 * Tiles are drawn above the {@link BackroundLayer} but below the {@link TokenLayer}.
 * @extends {PlaceableObject}
 *
 * @example
 * Tile.create({
 *   img: "path/to/tile-artwork.png",
 *   width: 300,
 *   height: 300,
 *   scale: 1,
 *   x: 1000,
 *   y: 1000,
 *   z: 370,
 *   rotation: 45,
 *   hidden: false,
 *   locked: true
 * });
 *
 * @see {@link TilesLayer}
 * @see {@link TileSheet}
 * @see {@link TileHUD}
 */
class Tile extends PlaceableObject {
	/** @override */
	static get layer() {
		return TilesLayer;
	}

	/* -------------------------------------------- */

	/** @override */
	get center() {
		return {
			x: this.data.x + this.data.width / 2,
			y: this.data.y + this.data.height / 2,
		};
	}

	/* -------------------------------------------- */

	/** @override */
	get sheet() {
		if (!this._sheet) this._sheet = new TileConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * Get the aspect ratio of the base texture for the Tile sprite
	 * @type {number}
	 */
	get aspectRatio() {
		if (!this.img) return null;
		let tex = this.img.texture.baseTexture;
		return tex.width / tex.height;
	}

	/* -------------------------------------------- */

	/** @override */
	async draw() {
		this.clear();

		// Create child elements
		if (this.data.img) this.img = this.addChild(await this._drawTile());
		this.frame = this.addChild(new PIXI.Graphics());
		this.scaleHandle = this.addChild(new PIXI.Graphics());
		this.bg = this.addChild(new PIXI.Graphics());

		// Render the Tile appearance
		this.refresh();

		// Enable interaction - only if the Tile has an ID
		if (this.id) {
			this.interactive = true;

			// Tile control
			new HandleManager(
				this,
				this.layer,
				{
					mouseover: event => this._onMouseOver(event),
					mouseout: event => this._onMouseOut(event),
					mousemove: event => this._onMouseMove(event),
					mousedown: event => this._onMouseDown(event),
					mouseup: event => this._onMouseUp(event),
					doubleleft: event => this._onDoubleLeft(event),
					rightdown: event => this._onRightDown(event),
					cancel: event => this._onDragCancel(event),
				},
				{
					candrag: event => !this.data.locked,
					canright: event => this._controlled,
				}
			);

			// Scale handler
			new HandleManager(
				this.scaleHandle,
				this.layer,
				{
					mouseover: event => this._onHandleMouseOver(event),
					mouseout: event => this._onHandleMouseOut(event),
					mousedown: event => this._onHandleMouseDown(event),
					mousemove: event => this._onHandleMouseMove(event),
					mouseup: event => this._onHandleMouseUp(event),
				},
				{
					canclick: event => !this.data.locked,
				}
			);
		}

		// Return the drawn Tile
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the image Sprite for the Tile
	 * @return {Promise}
	 * @private
	 */
	async _drawTile() {
		let tex = await loadTexture(this.data.img || CONST.DEFAULT_TOKEN),
			img = new PIXI.Sprite(tex);

		// Set dimensions
		img.width = this.data.width;
		img.height = this.data.height;
		img.rotation = toRadians(this.data.rotation);

		// Ensure playback state for video tokens
		let source = tex.baseTexture.resource.source;
		if (source && source.tagName === 'VIDEO') {
			source.loop = true;
			source.muted = true;
			game.video.play(source);
		}

		// Return the tile
		return img;
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		// Set Tile position
		this.alpha = 1;
		this.position.set(
			this.data.x + this.pivot.x,
			this.data.y + this.pivot.y
		);

		// Draw the sprite image (or a temporary background)
		if (this.data.img) {
			this.img.width = Math.abs(this.data.width);
			this.img.height = Math.abs(this.data.height);
			this.img.scale.set(
				Math.sign(this.data.width) * Math.abs(this.img.scale.x),
				Math.sign(this.data.height) * Math.abs(this.img.scale.y)
			);
			this.img.anchor.set(0.5, 0.5);
			this.img.position.set(this.data.width / 2, this.data.height / 2);
			this.img.rotation = toRadians(this.data.rotation);
			this.bg.visible = false;
			this.img.alpha = this.data.hidden ? 0.5 : 1.0;
		} else
			this.bg
				.clear()
				.beginFill(0xffffff, 0.5)
				.drawRect(0, 0, this.data.width, this.data.height);

		// Draw border frame
		this.frame
			.clear()
			.lineStyle(2.0, 0x000000)
			.drawRect(0, 0, this.data.width, this.data.height);

		// Draw scale handle
		this.scaleHandle.position.set(this.data.width, this.data.height);
		this.scaleHandle
			.clear()
			.lineStyle(2.0, 0x000000)
			.beginFill(0xff9829, 1.0)
			.drawCircle(0, 0, 6.0);

		// Toggle visibility
		this.visible = !this.data.hidden || game.user.isGM;
		this.frame.visible = this.scaleHandle.visible = this._controlled;
	}

	/* -------------------------------------------- */

	/**
	 * Update the tile dimensions given a requested destination point
	 * @param {Object} destination
	 * @param {boolean} snap
	 * @param {boolean} constrain
	 * @private
	 */
	_updateDimensions(destination, { snap = true, constrain = true } = {}) {
		// Determine destination position
		if (snap)
			destination = canvas.grid.getSnappedPosition(
				destination.x,
				destination.y
			);
		if (destination.x - this.data.x === 0) {
			destination.x =
				this.data.x +
				canvas.dimensions.size * (Math.sign(this.data.width) || 1);
		}
		if (destination.y - this.data.y === 0) {
			destination.y =
				this.data.y +
				canvas.dimensions.size * (Math.sign(this.data.height) || 1);
		}

		// Identify change
		let dx = destination.x - this.data.x,
			dy = destination.y - this.data.y;

		// Resize, ignoring aspect ratio
		if (!constrain) {
			this.data.width = dx;
			this.data.height = dy;
		}

		// Resize, maintaining aspect ratio
		else {
			let ax = Math.abs(dx),
				ay = Math.abs(dy);
			this.data.width =
				ax <= ay ? dx : ay * this.aspectRatio * Math.sign(dy);
			this.data.height =
				ax <= ay ? (ax / this.aspectRatio) * Math.sign(dx) : dy;
		}
	}

	/* -------------------------------------------- */
	/*  Socket Handlers                             */
	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		if (data.hasOwnProperty('img')) this.draw();
		else this.refresh();
		super._onUpdate(data);
	}

	/* -------------------------------------------- */
	/*  Event Handlers                              */
	/* -------------------------------------------- */

	/** @override */
	_onMouseOver(event) {
		super._onMouseOver(event);
		if (this.layer._active) this.frame.visible = true;
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseOut(event) {
		super._onMouseOut(event);
		this.frame.visible = this.layer._active && this._controlled;
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-over event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The PIXI mouseover event
	 * @private
	 */
	_onHandleMouseOver(event) {
		let { handle } = event.data;
		handle.scale.set(1.5, 1.5);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-out event on a control handle
	 * @param {PIXI.interaction.InteractionEvent} event   The PIXI mouseout event
	 * @private
	 */
	_onHandleMouseOut(event) {
		let { handle } = event.data;
		handle.scale.set(1, 1);
	}

	/* -------------------------------------------- */

	/**
	 * When we start a drag event - create a preview copy of the Tile for re-positioning
	 * @param {PIXI.interaction.InteractionEvent} event   The PIXI mousedown event
	 * @private
	 */
	_onHandleMouseDown(event) {
		event.data.original = duplicate(this.data);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mousemove while dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The PIXI mousemove event
	 * @private
	 */
	_onHandleMouseMove(event) {
		const { destination, originalEvent } = event.data;
		this._updateDimensions(destination, {
			snap: false,
			constrain: !originalEvent.altKey,
		});
		this.refresh();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouseup after dragging a tile scale handler
	 * @param {PIXI.interaction.InteractionEvent} event   The PIXI mouseup event
	 * @private
	 */
	_onHandleMouseUp(event) {
		let { original, originalEvent, destination } = event.data;
		this._updateDimensions(destination, {
			snap: !originalEvent.shiftKey,
			constrain: !originalEvent.altKey,
		});
		const data = {
			width: this.data.width,
			height: this.data.height,
			rotation: this.data.rotation,
		};
		this.data = original;
		this.update(data);
	}
}

/**
 * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.
 * @extends  {PlaceableObject}
 *
 * @example
 * Token.create({
 *   name: "Token Name",
 *   x: 1000,
 *   y: 1000,
 *   displayName: 3,
 *   img: "path/to/token-artwork.png",
 *   width: 2,
 *   height: 2,
 *   scale: 1.2,
 *   elevation: 50,
 *   lockRotation: false,
 *   rotation: 30,
 *   effects: ["icons/stun.png"],
 *   overlayEffect: "icons/dead.png",
 *   vision: true,
 *   dimSight: 60,
 *   brightSight: 0,
 *   dimLight: 40,
 *   brightLight: 20,
 *   sightAngle: 60,
 *   hidden: false,
 *   actorId: "dfgkjt43jkvdfkj34t",
 *   actorLink: true,
 *   actorData: {},
 *   disposition: 1,
 *   displayBars: 3,
 *   bar1: {attribute: "attributes.hp"},
 *   bar2: {attribute: "attributes.sp"}
 * }
 */
class Token extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * A Ray which represents the Token's current movement path
		 * @type {Ray}
		 * @private
		 */
		this._movement = null;

		/**
		 * An Object which records the Token's prior velocity dx and dy
		 * This can be used to determine which direction a Token was previously moving
		 * @type {Object}
		 * @private
		 */
		this._velocity = {
			dx: null,
			dy: null,
			sx: null,
			sy: null,
		};

		/**
		 * The Token's most recent valid position
		 * @type {Object}
		 * @private
		 */
		this._validPosition = { x: this.data.x, y: this.data.y };

		/**
		 * Provide a temporary flag through which this Token can be overridden to bypass any movement animation
		 * @type {Boolean}
		 */
		this._noAnimate = false;

		/**
		 * Track the set of User entities which are currently targeting this Token
		 * @type {Set.<User>}
		 */
		this.targeted = new Set([]);

		/**
		 * An Actor entity constructed using this Token's data
		 * If actorLink is true, then the entity is the true Actor entity
		 * Otherwise, the Actor entity is a synthetic, constructed using the Token actorData
		 * @type {Actor}
		 */
		this.actor = Actor.fromToken(this);

		/**
		 * The Token's most recently computed line-of-sight polygon
		 * @type {PIXI.Polygon}
		 */
		this.los = null;

		/**
		 * The Token's most recently computed field-of-vision polygon
		 * @type {PIXI.Polygon}
		 */
		this.fov = null;
	}

	/* -------------------------------------------- */

	/** @override */
	static get layer() {
		return TokenLayer;
	}

	/* -------------------------------------------- */
	/*  Permission Attributes
  /* -------------------------------------------- */

	/**
	 * A Boolean flag for whether the current game User has permission to control this token
	 * @type {boolean}
	 */
	get owner() {
		if (game.user.isGM) return true;
		return this.actor ? this.actor.owner : false;
	}

	/* -------------------------------------------- */

	/**
	 * Does the current user have at least LIMITED permission to the Token
	 * @type {boolean}
	 */
	get canViewSheet() {
		return (
			game.user.isGM ||
			(this.actor && this.actor.hasPerm(game.user, 'LIMITED'))
		);
	}

	/* -------------------------------------------- */

	/**
	 * Is the HUD display active for this token?
	 * @return {boolean}
	 */
	get hasActiveHUD() {
		return this.layer.hud.object === this;
	}

	/* -------------------------------------------- */

	/**
	 * Convenience access to the token's nameplate string
	 * @type {string}
	 */
	get name() {
		return this.data.name;
	}

	/* -------------------------------------------- */

	/**
	 * Provide a singleton reference to the TileConfig sheet for this Tile instance
	 * @type {TokenConfig}
	 */
	get sheet() {
		if (!this._sheet) this._sheet = new TokenConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */
	/*  Rendering Attributes
  /* -------------------------------------------- */

	/**
	 * Translate the token's grid width into a pixel width based on the canvas size
	 * @type {number}
	 */
	get w() {
		return this.data.width * canvas.grid.w;
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's grid height into a pixel height based on the canvas size
	 * @type {number}
	 */
	get h() {
		return this.data.height * canvas.grid.h;
	}

	/* -------------------------------------------- */

	/**
	 * The Token's current central position
	 * @property x The central x-coordinate
	 * @property y The central y-coordinate
	 * @type {Object}
	 */
	get center() {
		return this.getCenter(this.data.x, this.data.y);
	}

	/* -------------------------------------------- */
	/*  State Attributes
  /* -------------------------------------------- */

	/**
	 * An indicator for whether or not this token is currently involved in the active combat encounter.
	 * @type {boolean}
	 */
	get inCombat() {
		if (!canvas.scene.active) return false;
		if (!game.combat) return false;
		let combatant = game.combat.getCombatantByToken(this.id);
		return combatant !== undefined;
	}

	/* -------------------------------------------- */

	/**
	 * An indicator for whether the Token is currently targeted by the active game User
	 * @type {boolean}
	 */
	get isTargeted() {
		return this.targeted.has(game.user);
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether the Token is visible to the calling user's perspective.
	 * If the user is a GM, all tokens are visible
	 * If the user is a player, owned tokens which are not hidden are visible
	 * Otherwise only tokens whose corner or center are within the vision polygon are visible.
	 *
	 * @type {boolean}
	 */
	get isVisible() {
		// If token vision is not required
		if (!canvas.sight.tokenVision) {
			if (this.data.hidden) return game.user.isGM;
			return true;
		}

		// Controlled tokens are always visible
		if (this._controlled) return true;

		// Hidden tokens are not visible for players
		if (this.data.hidden && !game.user.isGM) return false;

		// GM users when there are no controlled tokens can see everything
		if (game.user.isGM && !canvas.sight.tokens.vision.length) return true;

		// Get the set of points to test for a token
		const c = this.center;
		let d = canvas.dimensions.size / 4;
		const [x0, y0, x1, y1] = [
			this.data.x,
			this.data.y,
			this.data.x + this.w,
			this.data.y + this.h,
		];
		const points = [
			[c.x, c.y],
			[x0 + d, y0 + d],
			[x1 - d, y0 + d],
			[x0 + d, y1 - d],
			[x1 - d, y1 - d],
		];

		// First test that the token falls within a token line-of-sight
		let los = canvas.sight.los;
		let hasLOS = los.tokens.concat(los.lights).some(l => {
			return points.some(p => l.contains(...p));
		});

		// If the token falls in some line of sight, check if it also falls within a field-of-vision
		if (!hasLOS) return false;
		let fov = canvas.sight.fov;
		return fov.tokens.concat(fov.lights).some(f => {
			return points.some(p => f.contains(...p));
		});
	}

	/* -------------------------------------------- */
	/*  Lighting and Vision Attributes
  /* -------------------------------------------- */

	/**
	 * Test whether the Token has sight (or blindness) at any radius
	 * @type {boolean}
	 */
	get hasSight() {
		return this.data.vision;
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Token emits light (or darkness) at any radius
	 * @type {boolean}
	 */
	get emitsLight() {
		return ['dimLight', 'brightLight'].some(a => this.data[a] !== 0);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Token has a limited angle of vision or light emission which would require sight to update on Token rotation
	 * @type {boolean}
	 */
	get hasLimitedVisionAngle() {
		return (
			(this.hasSight && this.data.sightAngle !== 360) ||
			(this.emitsLight && this.data.lightAngle !== 360)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's sight distance in units into a radius in pixels.
	 * @return {number}     The sight radius in pixels
	 */
	get dimRadius() {
		let r =
			Math.abs(this.data.dimLight) > Math.abs(this.data.dimSight)
				? this.data.dimLight
				: this.data.dimSight;
		return this._getLightRadius(r);
	}

	/* -------------------------------------------- */

	/**
	 * The radius of dim light that the Token emits
	 * @return {number}
	 */
	get dimLightRadius() {
		let r =
			Math.abs(this.data.dimLight) > Math.abs(this.data.brightLight)
				? this.data.dimLight
				: this.data.brightLight;
		return this._getLightRadius(r);
	}

	/* -------------------------------------------- */

	/**
	 * Translate the token's bright light distance in units into a radius in pixels.
	 * @return {Number}       The bright radius in pixels
	 */
	get brightRadius() {
		let r =
			Math.abs(this.data.brightLight) > Math.abs(this.data.brightSight)
				? this.data.brightLight
				: this.data.brightSight;
		return this._getLightRadius(r);
	}

	/* -------------------------------------------- */

	/**
	 * The radius of bright light that the Token emits
	 * @return {number}
	 */
	get brightLightRadius() {
		return this._getLightRadius(this.data.brightLight);
	}

	/* -------------------------------------------- */
	/* Rendering
  /* -------------------------------------------- */

	/**
	 * Draw the token, returning a promise once the token's texture is loaded
	 * @return {Promise}
	 */
	async draw() {
		this.clear();
		if (this.hasActiveHUD) canvas.tokens.hud.clear();

		// Load token texture
		try {
			this.texture = await loadTexture(
				this.data.img || CONST.DEFAULT_TOKEN
			);
		} catch (err) {
			this.texture = null;
		}

		// Draw Token components
		this.border = this.addChild(new PIXI.Graphics());
		this.icon = this.addChild(await this._drawIcon());
		this.bars = this.addChild(this._drawBars());
		this.nameplate = this.addChild(this._drawNameplate());
		this.tooltip = this.addChild(new PIXI.Container());
		this.effects = this.addChild(new PIXI.Container());
		this.target = this.addChild(new PIXI.Graphics());

		// Define interactivity
		this.hitArea = new PIXI.Rectangle(0, 0, this.w, this.h);
		this.interactive = true;
		this.buttonMode = true;

		// Draw the initial position
		this.refresh();
		this.drawEffects();
		this.drawTooltip();
		this.drawBars();

		// Add interactivity if the Token has an ID
		if (this.id) {
			new HandleManager(
				this,
				this.layer,
				{
					mouseover: event => this._onMouseOver(event),
					mouseout: event => this._onMouseOut(event),
					mousedown: event => this._onMouseDown(event),
					mousemove: event => this._onMouseMove(event),
					mouseup: event => this._onMouseUp(event),
					doubleleft: event => this._onDoubleLeft(event),
					rightdown: event => this._onRightDown(event),
					doubleright: event => this._onDoubleRight(event),
					cancel: event => this._onDragCancel(event),
				},
				{
					canhover: true,
					canclick: event => this.canViewSheet,
					candrag: event => {
						if (!this._controlled) return false;
						let isRuler =
							ui.controls.isRuler || game.keyboard.isCtrl(event);
						if (isRuler) return false;
						let blockMove =
							this._movement || (game.paused && !game.user.isGM);
						return !blockMove;
					},
				}
			);
		}

		// Return a Promise resolving to the rendered token
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Sprite icon for the Token
	 * @return {Promise}
	 * @private
	 */
	async _drawIcon() {
		// Create Sprite using the loaded texture
		let icon = new PIXI.Sprite(this.texture);
		icon.anchor.set(0.5, 0.5);

		// Ensure playback state for video tokens
		if (
			getProperty(this.texture, 'baseTexture.resource.source.tagName') ===
			'VIDEO'
		) {
			source.loop = true;
			source.muted = true;
			game.video.play(source);
		}
		return icon;
	}

	/* -------------------------------------------- */

	/**
	 * Update display of the Token, pulling latest data and re-rendering the display of Token components
	 */
	refresh() {
		// Token position and visibility
		if (!this._movement) this.position.set(this.data.x, this.data.y);
		this.visible = game.user.isGM ? true : !this.data.hidden;

		// Refresh icon display
		let d = Math.round((this.w + this.h) / 2);
		this.icon.scale.x =
			((d * this.data.scale) / this.texture.width) *
			(this.data.mirrorX ? -1 : 1);
		this.icon.height = d * this.data.scale;
		this.icon.rotation = toRadians(
			this.data.lockRotation ? 0 : this.data.rotation
		);
		this.icon.position.set(this.w / 2, this.h / 2);
		this.icon.alpha = this.data.hidden ? 0.5 : 1.0;

		// Refresh Token border and target
		this._refreshBorder();
		this._refreshTarget();

		// Refresh nameplate and resource bars
		this.nameplate.visible = this._canViewMode(this.data.displayName);
		this.bars.visible = this._canViewMode(this.data.displayBars);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Token border, taking into consideration the grid type and border color
	 * @private
	 */
	_refreshBorder() {
		this.border.clear();
		const borderColor = this._getBorderColor();
		if (!borderColor) return;

		// Draw Hex border for size 1 tokens on a hex grid
		const { width, height } = this.data;
		const gt = CONST.GRID_TYPES;
		const hexTypes = [gt.HEXEVENQ, gt.HEXEVENR, gt.HEXODDQ, gt.HEXODDR];
		if (
			hexTypes.includes(canvas.grid.type) &&
			width === 1 &&
			height === 1
		) {
			const g = canvas.grid.grid;
			const polygon = [gt.HEXEVENR, gt.HEXODDR].includes(canvas.grid.type)
				? g.getPointyHexPolygon(-1, -1, this.w + 2, this.h + 2)
				: g.getFlatHexPolygon(-1, -1, this.w + 2, this.h + 2);
			this.border.lineStyle(4, 0x000000, 0.8).drawPolygon(polygon);
			this.border
				.lineStyle(2, borderColor || 0xff9829, 1.0)
				.drawPolygon(polygon);
		}

		// Otherwise Draw Square border
		else {
			this.border
				.lineStyle(4, 0x000000, 0.8)
				.drawRoundedRect(-1, -1, this.w + 2, this.h + 2, 3);
			this.border
				.lineStyle(2, borderColor || 0xff9829, 1.0)
				.drawRoundedRect(-1, -1, this.w + 2, this.h + 2, 3);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get the hex color that should be used to render the Token border
	 * @return {*}
	 * @private
	 */
	_getBorderColor() {
		if (this._controlled) return 0xff9829;
		// Controlled
		else if (this._hover) {
			let d = parseInt(this.data.disposition);
			if (!game.user.isGM && this.owner) return 0xff9829;
			// Owner
			else if (this.actor && this.actor.isPC) return 0x33bc4e;
			// Party Member
			else if (d === 1) return 0x43dfdf;
			// Friendly NPC
			else if (d === 0) return 0xf1d836;
			// Neutral NPC
			else return 0xe72124; // Hostile NPC
		} else return null;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the target indicators for the Token.
	 * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.
	 * @private
	 */
	_refreshTarget() {
		this.target.clear();
		if (!this.targeted.size) return;

		// Determine whether the current user has target and any other users
		const [others, user] = Array.from(this.targeted).partition(
			u => u === game.user
		);
		const userTarget = user.length;

		// For the current user, draw the target arrows
		if (userTarget) {
			let p = 4;
			let aw = 12;
			let h = this.h;
			let hh = h / 2;
			let w = this.w;
			let hw = w / 2;
			let ah = canvas.dimensions.size / 3;
			this.target
				.beginFill(0xff9829, 1.0)
				.lineStyle(1, 0x000000)
				.drawPolygon([-p, hh, -p - aw, hh - ah, -p - aw, hh + ah])
				.drawPolygon([
					w + p,
					hh,
					w + p + aw,
					hh - ah,
					w + p + aw,
					hh + ah,
				])
				.drawPolygon([hw, -p, hw - ah, -p - aw, hw + ah, -p - aw])
				.drawPolygon([
					hw,
					h + p,
					hw - ah,
					h + p + aw,
					hw + ah,
					h + p + aw,
				]);
		}

		// For other users, draw offset pips
		for (let [i, u] of others.entries()) {
			let color = colorStringToHex(u.data.color);
			this.target
				.beginFill(color, 1.0)
				.lineStyle(2, 0x0000000)
				.drawCircle(2 + i * 8, 0, 6);
		}
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to retrieve the underlying data behind one of the Token's attribute bars
	 * @param barName
	 * @return {Object}
	 */
	getBarAttribute(barName) {
		const attr = this.data[barName].attribute;
		if (!attr) return {};
		const data = this.actor
			? duplicate(getProperty(this.actor.data.data, attr) || {})
			: {};
		data.bar = barName;
		data.attribute = attr;
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Draw resource bars for the Token
	 * @private
	 */
	_drawBars() {
		const bars = new PIXI.Container();

		// Primary bar
		bars.bar1 = bars.addChild(new PIXI.Graphics());
		bars.bar1.position.set(0, this.h - Math.max(this.h / 16, 8));

		// Secondary bar
		bars.bar2 = bars.addChild(new PIXI.Graphics());
		bars.bar2.position.set(0, 0);
		return bars;
	}

	/* -------------------------------------------- */

	/**
	 * Refresh the display of Token attribute bars, rendering latest resource data
	 * @private
	 */
	drawBars() {
		if (
			!this.actor ||
			this.data.displayBars === CONST.TOKEN_DISPLAY_MODES.NONE
		)
			return;
		['bar1', 'bar2'].forEach((b, i) => {
			const config = this.data[b],
				bar = this.bars[b];

			// If there is no attribute present, hide the bar
			bar.visible = config.attribute;
			if (!config.attribute) return;

			// Pull the current data and draw the bar
			const data = this.getBarAttribute(b);
			config.value = data.value;
			config.max = data.max;
			this._drawBar(i, bar, config);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Draw a single resource bar, given provided data
	 * @param {Number} number       The Bar number
	 * @param {PIXI.Graphics} bar   The Bar container
	 * @param {Object} data         Resource data for this bar
	 * @private
	 */
	_drawBar(number, bar, data) {
		// Process bar data
		let val = Number(data.value),
			max = data.max,
			pct = Math.clamped(val, 0, max) / max,
			h = Math.max(this.h / 16, 8);

		// Draw the bar
		let color =
			number === 0
				? [1 - pct / 2, pct, 0]
				: [0.5 * pct, 0.7 * pct, 0.5 + pct / 2];
		bar.clear()
			.beginFill(0x000000, 0.5)
			.lineStyle(2, 0x000000, 0.9)
			.drawRoundedRect(0, 0, this.w, h, 3)
			.beginFill(PIXI.utils.rgb2hex(color), 0.8)
			.lineStyle(1, 0x000000, 0.8)
			.drawRoundedRect(1, 1, pct * (this.w - 2), h - 2, 2);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the token's nameplate as a text object
	 * @return {PIXI.Text}  The Text object for the Token nameplate
	 */
	_drawNameplate() {
		// Gate font size based on grid size
		let h = 24;
		if (canvas.dimensions.size >= 200) h = 36;
		else if (canvas.dimensions.size < 50) h = 18;

		// Create the nameplate text
		const name = new PIXI.Text(
			this.data.name,
			CONFIG.canvasTextStyle.clone()
		);

		// Anchor to the middle of the nameplate
		name.anchor.set(0.5, 0.5);

		// Adjust dimensions
		let bounds = name.getBounds(),
			r = bounds.width / bounds.height,
			maxWidth = this.w * 2.5,
			nrows = Math.ceil((h * r) / maxWidth);

		// Wrap for multiple rows
		if (h * r > maxWidth) {
			name.style.wordWrap = true;
			name.style.wordWrapWidth = (bounds.height / h) * maxWidth;
			bounds = name.getBounds();
			r = bounds.width / bounds.height;
		}

		// Downsize the name using the given scaling ratio
		name.height = h * nrows;
		name.width = h * nrows * r;

		// Set position at bottom of token
		name.position.set(this.w / 2, this.h + nrows * 12);
		return name;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a text tooltip for the token which can be used to display Elevation or a resource value
	 */
	drawTooltip() {
		this.tooltip.removeChildren().forEach(c => c.destroy());

		// Get the Tooltip text
		let tip = this._getTooltipText();
		if (!tip.length) return;

		// Create the tooltip text, anchored to the center of the container
		const text = this.tooltip.addChild(
			new PIXI.Text(tip, CONFIG.canvasTextStyle)
		);
		text.anchor.set(0.5, 0.5);

		// Adjust dimensions based on grid size
		let h = 20;
		if (canvas.dimensions.size >= 200) h = 24;
		else if (canvas.dimensions.size < 50) h = 16;
		let bounds = text.getLocalBounds(),
			r = bounds.width / bounds.height;
		text.height = h;
		text.width = h * r;

		// Add the tooltip at the top of the parent Token container
		this.tooltip.position.set(this.w / 2, -0.5 * h);
	}

	/* -------------------------------------------- */

	/**
	 * Return the text which should be displayed in a token's tooltip field
	 * @return {String}
	 * @private
	 */
	_getTooltipText() {
		let el = this.data.elevation;
		if (!Number.isFinite(el) || el === 0) return '';
		let units = canvas.scene.data.gridUnits;
		return el > 0 ? `+${el} ${units}` : `${el} ${units}`;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the active effects and overlay effect icons which are present upon the Token
	 */
	drawEffects() {
		this.effects.removeChildren().forEach(c => c.destroy());

		// Draw status effects
		if (this.data.effects.length > 0) {
			// Determine the grid sizing for each effect icon
			let w = Math.round(canvas.dimensions.size / 2 / 5) * 2;

			// Draw a background Graphics object
			let bg = this.effects
				.addChild(new PIXI.Graphics())
				.beginFill(0x000000, 0.4)
				.lineStyle(1.0, 0x000000);

			// Draw each effect icon
			this.data.effects.forEach((src, i) => {
				let tex = PIXI.Texture.from(src, { scale: 1.0 });
				let icon = this.effects.addChild(new PIXI.Sprite(tex));
				icon.width = icon.height = w;
				icon.x = Math.floor(i / 5) * w;
				icon.y = (i % 5) * w;
				bg.drawRoundedRect(icon.x + 1, icon.y + 1, w - 2, w - 2, 2);
				this.effects.addChild(icon);
			});
		}

		// Draw overlay effect
		if (this.data.overlayEffect) {
			let tex = PIXI.Texture.from(this.data.overlayEffect, {
				scale: 1.0,
			});
			let icon = new PIXI.Sprite(tex),
				size = Math.min(this.w * 0.6, this.h * 0.6);
			icon.width = icon.height = size;
			icon.position.set((this.w - size) / 2, (this.h - size) / 2);
			icon.alpha = 0.8;
			this.effects.addChild(icon);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Helper method to determine whether a token attribute is viewable under a certain mode
	 * @param {Number} mode   The mode from CONST.TOKEN_DISPLAY_MODES
	 * @return {Boolean}      Is the attribute viewable?
	 * @private
	 */
	_canViewMode(mode) {
		if (mode === CONST.TOKEN_DISPLAY_MODES.NONE) return false;
		else if (mode === CONST.TOKEN_DISPLAY_MODES.ALWAYS) return true;
		else if (mode === CONST.TOKEN_DISPLAY_MODES.CONTROL)
			return this._controlled;
		else if (mode === CONST.TOKEN_DISPLAY_MODES.HOVER) return this._hover;
		else if (mode === CONST.TOKEN_DISPLAY_MODES.OWNER_HOVER)
			return this.owner && this._hover;
		else if (mode === CONST.TOKEN_DISPLAY_MODES.OWNER) return this.owner;
		return false;
	}

	/* -------------------------------------------- */

	/**
	 * Animate Token movement along a certain path which is defined by a Ray object
	 * @param {Ray} ray   The path along which to animate Token movement
	 */
	async animateMovement(ray) {
		// Move distance is 10 spaces per second
		this._movement = ray;
		let speed = canvas.dimensions.size * 10,
			duration = (ray.distance * 1000) / speed;

		// Define attributes
		const attributes = [
			{ parent: this, attribute: 'x', to: ray.B.x },
			{ parent: this, attribute: 'y', to: ray.B.y },
		];

		// Trigger the animation function
		let animationName = `Token.${this.id}.animateMovement`;
		await CanvasAnimation.animateLinear(attributes, {
			name: animationName,
			context: this,
			duration: duration,
		});
		this._movement = null;
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Check for collision when attempting a move to a new position
	 * @param {Object} destination  An Object containing data for the attempted movement
	 * @param {Boolean} drag        Whether we are checking collision for a drag+drop movement
	 *
	 * @return {Boolean}            A true/false indicator for whether the attempted movement caused a collision
	 */
	checkCollision(destination, { drag = false } = {}) {
		// GameMaster players can drag anywhere
		if (game.user.isGM && drag) return false;

		// Create a Ray for the attempted move
		let origin = this.getCenter(...Object.values(this._validPosition));
		let ray = new Ray(duplicate(origin), duplicate(destination));

		// Shift the origin point by the prior velocity
		ray.A.x -= this._velocity.sx;
		ray.A.y -= this._velocity.sy;

		// Shift the destination point by the requested velocity
		ray.B.x -= Math.sign(ray.dx);
		ray.B.y -= Math.sign(ray.dy);

		// Check for a wall collision
		return canvas.walls.checkCollision(ray);
	}

	/* -------------------------------------------- */

	/**
	 * Compute the field-of-vision for an object, determining its effective line-of-sight and field-of-vision polygons
	 * @returns {Object}      An object containing the rays, LOS polygon, and FOV polygon for the light
	 */
	computeFOV() {
		const radius =
			Math.max(Math.abs(this.dimRadius), Math.abs(this.brightRadius)) +
			canvas.dimensions.size * 0.1;
		let [rays, los, fov] = canvas.sight.checkSight(this.center, radius, {
			angle: this.data.angle,
			cullMultiplier: 1.0,
			radialDensity: 6.0,
			rotation: this.data.rotation,
		});
		this.fov = fov;
		this.los = los;
		return { rays, los, fov };
	}

	/* -------------------------------------------- */

	/**
	 * Assume control over a PlaceableObject, flagging it as controlled and enabling downstream behaviors
	 * See PlaceableObject.control() for full details
	 * @param {Boolean} multiSelect       Is this object being selected as part of a group?
	 * @param {Boolean} releaseOthers     Release any other controlled objects first
	 * @param {Boolean} initializeSight   Reinitialize the sight layer
	 * @return {Boolean}                  A Boolean flag denoting whether or not control was successful.
	 */
	control({
		multiSelect = false,
		releaseOthers = true,
		initializeSight = true,
		initializeSound = true,
	} = {}) {
		_token = this;
		let initial = this._controlled;
		let controlled = super.control({ multiSelect, releaseOthers });
		if (controlled && !initial) {
			this.displayToFront();
			if (initializeSight) canvas.sight.initializeSight();
			canvas.sounds.update();
		}
		return controlled;
	}

	/* -------------------------------------------- */

	/**
	 * Release control over a PlaceableObject, removing it from the controlled set
	 * See PlaceableObject.release() for full details
	 * @param resetSight {Boolean}      Trigger a re-initialization of the sight layer, this may not be necessary
	 * @return {Boolean}                A Boolean flag confirming the object was released.
	 */
	release({ resetSight = true } = {}) {
		let initial = this._controlled;
		let released = super.release();
		if (initial && released) {
			if (resetSight) canvas.sight.initializeSight();
			if (game.user.isGM) canvas.sounds.update();
		}
		return released;
	}

	/* -------------------------------------------- */

	/**
	 * Get the center-point coordinate for a given grid position
	 * @param {Number} x    The grid x-coordinate that represents the top-left of the Token
	 * @param {Number} y    The grid y-coordinate that represents the top-left of the Token
	 * @return {Object}     The coordinate pair which represents the Token's center at position (x, y)
	 */
	getCenter(x, y) {
		return {
			x: x + this.w / 2,
			y: y + this.h / 2,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Set the token's position by comparing its center position vs the nearest grid vertex
	 * Return a Promise that resolves to the Token once the animation for the movement has been completed
	 * @param {Number} x        The x-coordinate of the token center
	 * @param {Number} y        The y-coordinate of the token center
	 * @return {Promise}        The Token after animation has completed
	 */
	async setPosition(x, y) {
		// Create a Ray for the requested movement
		let origin = this._movement ? this.position : this._validPosition,
			target = { x: x, y: y },
			isVisible = this.isVisible;

		// Create the movement ray
		let ray = new Ray(origin, target);

		// Update the new valid position
		this._validPosition = target;

		// Record the Token's new velocity
		this._velocity = this._updateVelocity(ray);

		// Update visibility for a non-controlled token which may have moved into the controlled tokens FOV
		this.visible = isVisible;

		// Conceal the HUD if it targets this Token
		if (this.hasActiveHUD) this.layer.hud.clear();

		// Begin animation towards the target position if the destination is visible
		if (this._noAnimate || !isVisible) this.position.set(x, y);
		else {
			let animRay = new Ray(this.position, ray.B);
			await this.animateMovement(animRay);
		}

		// If the movement took the token off-screen, re-center the view
		if (this._controlled && isVisible) {
			let pad = 50;
			let gp = this.getGlobalPosition();
			if (
				gp.x < pad ||
				gp.x > window.innerWidth - pad ||
				gp.y < pad ||
				gp.y > window.innerHeight - pad
			) {
				canvas.animatePan(this.center);
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Update the Token velocity auto-regressively, shifting increasing weight towards more recent movement
	 * Employ a magic constant chosen to minimize (effectively zero) the likelihood of trigonometric edge cases
	 * @param {Ray} ray     The proposed movement ray
	 * @return {Object}     An updated velocity with directional memory
	 * @private
	 */
	_updateVelocity(ray) {
		const v = this._velocity;
		const m = 0.89734721;
		return {
			dx: ray.dx,
			sx: ray.dx ? m * Math.sign(ray.dx) : 0.5 * m * Math.sign(v.sx),
			dy: ray.dy,
			sy: ray.dy ? m * Math.sign(ray.dy) : 0.5 * m * Math.sign(v.sy),
		};
	}

	/* -------------------------------------------- */

	/**
	 * Set this Token as an active target for the current game User
	 * @param {boolean} targeted        Is the Token now targeted?
	 * @param {User|null} user          Assign the token as a target for a specific User
	 * @param {boolean} releaseOthers   Release other active targets for the same player?
	 */
	setTarget(targeted = true, { user = null, releaseOthers = true } = {}) {
		user = user || game.user;

		// Release other targets
		if (user.targets.size && releaseOthers) {
			user.targets.forEach(t => {
				if (t !== this) t.setTarget(false, { releaseOthers: false });
			});
			user.targets.clear();
		}

		// Acquire target
		if (targeted) {
			user.targets.add(this);
			this.targeted.add(user);
		}

		// Release target
		else {
			user.targets.delete(this);
			this.targeted.delete(user);
		}

		// Refresh Token display
		this.refresh();

		// Refresh the Token HUD
		if (this.hasActiveHUD) this.layer.hud.render();
	}

	/* -------------------------------------------- */

	/**
	 * Add or remove the currently controlled Tokens from the active combat encounter
	 * @return {Promise}
	 */
	async toggleCombat() {
		// Ensure we are operating on an active Combat entity which applies to the current Scene
		if (!game.combat) {
			if (game.user.isGM)
				await Combat.create({ scene: canvas.scene._id, active: true });
			else return this;
		}
		if (game.combat.scene._id !== canvas.scene._id) return this;

		// Determine whether we are adding to, or removing from combat based on the target token
		let inCombat = this.inCombat;
		const tokens = this._controlled
			? canvas.tokens.controlled.filter(t => t.inCombat === inCombat)
			: [this];

		// Remove tokens from the Combat (GM Only)
		if (inCombat && game.user.isGM) {
			const tokenIds = new Set(tokens.map(t => t.id));
			const combatantIds = game.combat.combatants.reduce((ids, c) => {
				if (tokenIds.has(c.tokenId)) ids.push(c._id);
				return ids;
			}, []);
			await game.combat.deleteManyEmbeddedEntities(
				'Combatant',
				combatantIds
			);
		}

		// Add tokens to the Combat
		else {
			const createData = tokens.map(t => {
				return { tokenId: t.id, hidden: t.data.hidden };
			});
			await game.combat.createManyEmbeddedEntities(
				'Combatant',
				createData
			);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Toggle an active effect by it's texture path.
	 * Copy the existing Array in order to ensure the update method detects the data as changed.
	 *
	 * @param texture {String}  The texture file-path of the effect icon to toggle on the Token.
	 */
	async toggleEffect(texture) {
		let tfx = [...this.data.effects],
			idx = tfx.findIndex(e => e === texture);
		if (idx === -1) tfx.push(texture);
		else tfx.splice(idx, 1);
		await this.update(canvas.scene._id, { effects: tfx });
		this.drawEffects();
	}

	/* -------------------------------------------- */

	/**
	 * Set or remove the overlay texture for the Token by providing a new texture path
	 * @param {String} texture  The texture file-path of the effect to set as the Token overlay icon
	 * @return {Promise}
	 */
	async toggleOverlay(texture) {
		let effect = this.data.overlayEffect === texture ? null : texture;
		await this.update(canvas.scene._id, { overlayEffect: effect });
		this.drawEffects();
	}

	/* -------------------------------------------- */

	/**
	 * Toggle the visibility state of any Tokens in the currently selected set
	 * @return {Promise}
	 */
	async toggleVisibility() {
		let isHidden = this.data.hidden;
		const tokens = this._controlled ? canvas.tokens.controlled : [this];
		const updates = tokens.map(t => {
			return { _id: t.id, hidden: !isHidden };
		});
		return canvas.scene.updateManyEmbeddedEntities('Token', updates);
	}

	/* -------------------------------------------- */

	/**
	 * Return the token's sight origin, tailored for the direction of their movement velocity to break ties with walls
	 * @return {Object}
	 */
	getSightOrigin() {
		let m = this._movement;
		let p = this.center;
		if (m) {
			p = canvas.grid.getSnappedPosition(m.B.x, m.B.y);
			p = this.getCenter(p.x, p.y);
		}
		return {
			x: p.x - this._velocity.sx,
			y: p.y - this._velocity.sy,
		};
	}

	/* -------------------------------------------- */

	/**
	 * A generic transformation to turn a certain number of grid units into a radius in canvas pixels
	 * @param units {Number}  The radius in grid units
	 * @return {number}       The radius in canvas units
	 */
	_getLightRadius(units) {
		if (units === 0) return 0;
		return (
			(units / canvas.dimensions.distance) * canvas.dimensions.size +
			this.w / 2
		);
	}

	/* -------------------------------------------- */

	/**
	 * Perform an incremental token movement, shifting the token's position by some number of grid units.
	 * The offset parameters will move the token by that number of grid spaces in one or both directions.
	 *
	 * @param {Number} dx         The number of grid units to shift along the X-axis
	 * @param {Number} dy         The number of grid units to shift along the Y-axis
	 * @return {Promise}
	 */
	async shiftPosition(dx, dy) {
		let moveData = this._getShiftedPosition(dx, dy);
		return this.update(canvas.scene._id, moveData);
	}

	/* -------------------------------------------- */

	/**
	 * Obtain the shifted position for the token, if movement is allowed
	 * @param {Number} dx         The number of grid units to shift along the X-axis
	 * @param {Number} dy         The number of grid units to shift along the Y-axis
	 * @return {{x, y}|boolean}   False if the movement is not allowed, otherwise the target coordinates
	 * @private
	 */
	_getShiftedPosition(dx, dy) {
		let [x, y] = canvas.grid.grid.shiftPosition(
			this.data.x,
			this.data.y,
			dx,
			dy
		);
		let targetCenter = this.getCenter(x, y);
		let collide = this.checkCollision(targetCenter, { drag: false });
		return collide ? { x: this.data.x, y: this.data.y } : { x, y };
	}

	/* -------------------------------------------- */

	/**
	 * Extend the PlaceableObject.rotate method to prevent rotation if the Token is in the midst of a movement animation
	 */
	rotate(...args) {
		if (this._movement) return;
		super.rotate(...args);
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	async delete(...args) {
		await game.combats._onDeleteToken(this.scene.id, this.id);
		return super.delete(...args);
	}

	/* -------------------------------------------- */

	/** @override */
	async _onCreate() {
		const canSee =
			this.actor &&
			this.data.vision &&
			this.actor.hasPerm(game.user, 'OBSERVER');
		if (canSee || this.emitsLight) {
			canvas.addPendingOperation(
				`SightLayer.initialize`,
				canvas.sight.initialize,
				canvas.sight
			);
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		const keys = Object.keys(data);
		const changed = new Set(keys);

		// If Actor data link has changed, replace the Token actor
		if (['actorId', 'actorLink'].some(c => changed.has(c)))
			this.actor = Actor.fromToken(this);
		if (!this.data.actorLink && changed.has('actorData')) {
			this._onUpdateTokenActor(data.actorData);
		}

		// Handle direct Token updates
		const fullRedraw = ['img', 'name', 'width', 'height'].some(r =>
			changed.has(r)
		);
		const visiblityChange = changed.has('hidden');
		const positionChange = ['x', 'y'].some(c => changed.has(c));

		// Change in Token appearance
		if (fullRedraw) this.draw();
		else {
			if (positionChange) this.setPosition(this.data.x, this.data.y);
			if (['effects', 'overlayEffect'].some(k => changed.has(k)))
				this.drawEffects();
			if (changed.has('elevation')) this.drawTooltip();
			if (keys.some(k => k.startsWith('bar'))) this.drawBars();
			this.refresh();
		}

		// Change in Token visibility
		if (visiblityChange && !game.user.isGM) {
			if (this._controlled && data.hidden) this.release();
			else if (!data.hidden && !canvas.tokens.controlled.length)
				this.control();
		}

		// Process SightLayer changes
		const sl = canvas.sight;
		if (this.data.vision || changed.has('vision') || this.emitsLight) {
			const visionAttrs = [
				'vision',
				'dimSight',
				'brightSight',
				'sightAngle',
				'dimLight',
				'brightLight',
				'lightAngle',
			];
			const visionChange =
				(visiblityChange && this._controlled) ||
				visionAttrs.some(c => changed.has(c));
			if (visionChange)
				canvas.addPendingOperation(
					`SightLayer.initialize`,
					sl.initialize,
					sl
				);
			else if (
				positionChange ||
				visiblityChange ||
				(changed.has('rotation') && this.hasLimitedVisionAngle)
			) {
				canvas.addPendingOperation(
					`SightLayer.updateSight`,
					sl.updateSight,
					sl
				);
			}
		} else if (positionChange) {
			canvas.addPendingOperation(
				`SightLayer.restrictVisibility`,
				sl.restrictVisibility,
				sl
			);
		}

		// Process Sound changes
		if (positionChange) {
			canvas.addPendingOperation(
				`SoundLayer.update`,
				canvas.sounds.update,
				canvas.sounds
			);
		}

		// Process Combat Tracker changes
		if (this.inCombat) {
			if (changed.has('name')) {
				canvas.addPendingOperation(
					`Combat.setupTurns`,
					game.combat.setupTurns,
					game.combat
				);
			}
			if (['effects', 'name'].some(k => changed.has(k))) {
				canvas.addPendingOperation(
					`Combat.render`,
					game.combat.render,
					game.combat
				);
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete(sceneId) {
		this._movement = null;
		let hasActor = this.actor && this.actor.hasPerm(game.user, 'OBSERVER');
		let updateSight = (hasActor && this.data.vision) || this.emitsLight;
		if (updateSight)
			canvas.addPendingOperation(
				`SightLayer.initialize`,
				canvas.sight.initialize,
				canvas.sight
			);
		if (hasActor)
			canvas.addPendingOperation(
				`SightLayer.initialize`,
				canvas.sounds.initialize,
				canvas.sounds
			);
		super._onDelete(sceneId);
	}

	/* -------------------------------------------- */

	/**
	 * Handle updates to the Token's referenced Actor (either Entity or synthetic)
	 * @param {Object} updateData     The changes to Token actorData overrides which are incremental
	 * @private
	 */
	_onUpdateTokenActor(updateData) {
		// Reject any calls which were incorrectly placed to this method for tokens which are linked
		if (!this.actor || this.data.actorLink) return;

		// Update data for the synthetic Token
		mergeObject(this.actor.data, updateData);
		this.actor._onUpdate(updateData);

		// Update Token bar attributes
		this._onUpdateBarAttributes(updateData);

		// Update tracked Combat resources
		if (
			this.inCombat &&
			updateData.data &&
			hasProperty(updateData.data, game.combats.settings.resource)
		) {
			canvas.addPendingOperation(
				`CombatTracker.updateTrackedResources`,
				ui.combat.updateTrackedResources,
				ui.combat
			);
			canvas.addPendingOperation(
				`CombatTracker.render`,
				ui.combat.render,
				ui.combat
			);
		}

		// Render the active Token sheet
		this.actor.sheet.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle updates to this Token which originate from changes to the base Actor entity
	 * @param {Object} actorData     Updated data for the base Actor
	 * @param {Object} updateData    Changes to the base Actor which were incremental
	 * @private
	 */
	_onUpdateBaseActor(actorData, updateData) {
		if (!this.actor) return;

		// For Tokens which are unlinked, update the synthetic Actor
		if (!this.data.actorLink) {
			this.actor.data = mergeObject(actorData, this.data.actorData, {
				inplace: false,
			});
			this.actor.initialize();
		}

		// Update Token bar attributes
		this._onUpdateBarAttributes(updateData);

		// Update tracked Combat resources
		if (
			this.inCombat &&
			updateData.data &&
			hasProperty(updateData.data, game.combats.settings.resource)
		) {
			ui.combat.updateTrackedResources();
			ui.combat.render();
		}

		// Render the active Token sheet
		this.actor.sheet.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle the possible re-drawing of Token attribute bars depending on whether the tracked attribute changed
	 * @param {Object} updateData     An object of changed data
	 * @private
	 */
	_onUpdateBarAttributes(updateData) {
		const update = ['bar1', 'bar2'].some(b => {
			let bar = this.data[b];
			return (
				bar.attribute &&
				hasProperty(updateData, 'data.' + bar.attribute)
			);
		});
		if (update) this.drawBars();
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	_onMouseOver(event) {
		super._onMouseOver(event);
		if (this.inCombat) {
			$(`li.combatant[data-token-id="${this.id}"]`).addClass('hover');
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseOut(event) {
		super._onMouseOut(event);
		if (this.inCombat) {
			$(`li.combatant[data-token-id="${this.id}"]`).removeClass('hover');
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseDown(event) {
		const tool = game.activeTool;
		const oe = event.data.originalEvent;

		// Add or remove targets
		if (tool === 'target') {
			this.setTarget(!this.isTargeted, { releaseOthers: !oe.shiftKey });
		}

		// Add or remove control
		else {
			if (oe.shiftKey && this._controlled) return this.release();
			this.layer.hud.clear();
			this.control({ releaseOthers: !oe.shiftKey });
		}

		// Dispatch Ruler measurements
		let isRuler = tool === 'ruler' || oe.ctrlKey || oe.metaKey;
		if (isRuler) return canvas.controls.ruler._onMouseDown(event);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDoubleLeft(event) {
		if (!this.actor || !this.canViewSheet) return;
		const sheet = this.actor.sheet;
		sheet.token = this;
		sheet.render(true);
		sheet.maximize();
	}

	/* -------------------------------------------- */

	/** @override */
	_onDoubleRight(event) {
		if (this.owner) this.sheet.render(true);
		else
			this.setTarget(!this.targeted.has(game.user), {
				releaseOthers: !event.data.originalEvent.shiftKey,
			});
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseUp(event) {
		let { handleState, origin, destination, originalEvent } = event.data;
		if (handleState === 0) return;

		// Get Token movement data
		let padX = this.center.x - origin.x,
			padY = this.center.y - origin.y;

		// Treat the destination location as the target center, subject to the same padding
		let target = {
			x: destination.x + padX - this.w / 2,
			y: destination.y + padY - this.h / 2,
		};

		// Snap to grid unless shift is pressed
		if (!originalEvent.shiftKey)
			target = canvas.grid.getSnappedPosition(target.x, target.y, 1);

		// Check collision center-to-center
		let targetCenter = this.getCenter(target.x, target.y);
		let collide = this.checkCollision(targetCenter, { drag: true });
		if (collide) {
			ui.notifications.error('You cannot move through walls!');
			return this._onDragCancel(event);
		}

		// Update token movement
		this.update(canvas.scene._id, target).then(p =>
			this._onDragCancel(event)
		);
	}
}

/**
 * A "secret" global to help debug attributes of the currently controlled Token.
 * This is only for debugging, and may be removed in the future, so it's not safe to use.
 * @type {Token}
 * @private
 */
let _token = null;
/**
 * A Wall is an implementation of PlaceableObject which represents a physical or visual barrier within the Scene.
 * Walls are used to restrict Token movement or visibility as well as to define the areas of effect for ambient lights
 * and sounds.
 * @extends {PlaceableObject}
 *
 * @example
 * Wall.create({
 *  c = [100, 200, 400, 600],
 *  move: CONST.WALL_MOVEMENT_TYPES.NORMAL,
 *  sense: CONST.WALL_SENSE_TYPES.NORMAL,
 *  dir: CONST.WALL_DIRECTIONS.BOTH,
 *  door: CONST.WALL_DOOR_TYPES.DOOR,
 *  ds: CONST.WALL_DOOR_STATES.CLOSED
 * });
 *
 * @see {@link WallsLayer}
 * @see {@link WallConfig}
 */
class Wall extends PlaceableObject {
	constructor(...args) {
		super(...args);

		/**
		 * An reference the Door Control icon associated with this Wall, if any
		 * @type {DoorControl|null}
		 * @private
		 */
		this.doorControl = null;
	}

	/* -------------------------------------------- */
	/*  Properties                                  */
	/* -------------------------------------------- */

	/** @override */
	static get layer() {
		return WallsLayer;
	}

	/* -------------------------------------------- */

	/** @override */
	get sheet() {
		if (!this._sheet) this._sheet = new WallConfig(this);
		return this._sheet;
	}

	/* -------------------------------------------- */

	/**
	 * A convenience reference to the coordinates Array for the Wall endpoints, [x0,y0,x1,y1].
	 * @type {Array.<number>}
	 */
	get coords() {
		return this.data.c;
	}

	/* -------------------------------------------- */

	/**
	 * Return the coordinates [x,y] at the midpoint of the wall segment
	 * @return {Array.<number>}
	 */
	get midpoint() {
		return [
			(this.coords[0] + this.coords[2]) / 2,
			(this.coords[1] + this.coords[3]) / 2,
		];
	}

	/* -------------------------------------------- */

	/** @override */
	get center() {
		const [x, y] = this.midpoint;
		return { x, y };
	}

	/* -------------------------------------------- */

	/**
	 * Get the direction of effect for a directional Wall
	 * @return {number|null}   The angle of wall effect
	 */
	get direction() {
		let d = this.data.dir;
		if (!d) return null;
		let c = this.coords;
		let angle = Math.atan2(c[3] - c[1], c[2] - c[0]);
		if (d === CONST.WALL_DIRECTIONS.LEFT) return angle + Math.PI / 2;
		else return angle - Math.PI / 2;
	}

	/* -------------------------------------------- */
	/*  Methods                                     */
	/* -------------------------------------------- */

	/**
	 * This helper converts the wall segment to a Ray
	 * @return {Ray}    The wall in Ray representation
	 */
	toRay() {
		return Ray.fromArrays(this.coords.slice(0, 2), this.coords.slice(2));
	}

	/* -------------------------------------------- */

	/** @override */
	draw() {
		this.clear();

		// Draw wall components
		if (this.data.dir)
			this.directionIcon = this.addChild(this._drawDirection());
		this.line = this.addChild(new PIXI.Graphics());
		this.endpoints = this.addChild(new PIXI.Graphics());

		// Draw current wall
		this.refresh();

		// Add wall interactivity if the placeable has an ID
		if (this.id) {
			this.endpoints.interactive = true;

			// Handle manager for endpoint control
			new HandleManager(
				this.endpoints,
				this.layer,
				{
					mouseover: event => this._onMouseOver(event),
					mouseout: event => this._onMouseOut(event),
					mousedown: event => this._onMouseDown(event),
					mousemove: event => this._onMouseMove(event),
					mouseup: event => this._onMouseUp(event),
					doubleleft: event => this._onDoubleLeft(event),
					cancel: event => this._onDragCancel(event),
				},
				{
					canhover: true,
					canclick: event => {
						if (event.data.handleState > 0) return true;
						if (
							event.data.originalEvent.ctrlKey ||
							event.data.originalEvent.metaKey
						)
							return false;
						return game.user.isGM;
					},
					candrag: game.user.isGM,
				}
			);

			// Line interactivity
			this.line.interactive = true;
			this.line.on('mouseover', this._onMouseOverLine, this);
		}
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw a directional prompt icon for one-way walls to illustrate their direction of effect.
	 * @private
	 * @return {PIXI.Sprite}    The drawn icon
	 */
	_drawDirection() {
		if (this.directionIcon) this.removeChild(this.directionIcon);
		let d = this.data.dir;
		if (!d) return;

		// Create the icon
		const icon = new PIXI.Sprite.from('icons/svg/wall-direction.svg');
		icon.width = icon.height = 32;

		// Rotate the icon
		let iconAngle = -Math.PI / 2;
		let angle = this.direction;
		icon.anchor.set(0.5, 0.5);
		icon.rotation = iconAngle + angle;
		return icon;
	}

	/* -------------------------------------------- */

	/** @override */
	refresh() {
		const p = this.coords;
		const mp = [(p[0] + p[2]) / 2, (p[1] + p[3]) / 2];
		const hr = this._hover ? 6 : 4;
		const wc = this._getWallColor();

		// Draw background
		this.line
			.clear()
			.lineStyle(6.0, 0x000000, 1.0)
			.moveTo(p[0], p[1])
			.lineTo(p[2], p[3]);
		this.endpoints
			.clear()
			.beginFill(0x000000, 1.0)
			.drawCircle(p[0], p[1], hr + 2)
			.drawCircle(p[2], p[3], hr + 2);

		// Draw foreground
		this.line.lineStyle(2.0, wc, 1.0).lineTo(p[0], p[1]);
		this.endpoints
			.beginFill(wc, 1.0)
			.drawCircle(p[0], p[1], hr)
			.drawCircle(p[2], p[3], hr);

		// Tint direction icon
		if (this.directionIcon) {
			this.directionIcon.position.set(...mp);
			this.directionIcon.tint = wc;
		}

		// Update line hit area
		this.line.hitArea = new PIXI.Polygon(
			p[0] - 2,
			p[1] - 2,
			p[2] - 2,
			p[3] - 2,
			p[2] + 2,
			p[3] + 2,
			p[0] + 2,
			p[1] + 2
		);
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Given the properties of the wall - decide upon a color to render the wall for display on the WallsLayer
	 * @private
	 */
	_getWallColor() {
		// Invisible Walls
		if (this.data.sense === CONST.WALL_SENSE_TYPES.NONE) return 0x77e7e8;
		// Terrain Walls
		else if (this.data.sense === CONST.WALL_SENSE_TYPES.LIMITED)
			return 0x81b90c;
		// Ethereal Walls
		else if (this.data.move === CONST.WALL_SENSE_TYPES.NONE)
			return 0xca81ff;
		// Doors
		else if (this.data.door === CONST.WALL_DOOR_TYPES.DOOR) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if (ds === CONST.WALL_DOOR_STATES.CLOSED) return 0x6666ee;
			else if (ds === CONST.WALL_DOOR_STATES.OPEN) return 0x66cc66;
			else if (ds === CONST.WALL_DOOR_STATES.LOCKED) return 0xee4444;
		}

		// Secret Doors
		else if (this.data.door === CONST.WALL_DOOR_TYPES.SECRET) {
			let ds = this.data.ds || CONST.WALL_DOOR_STATES.CLOSED;
			if (ds === CONST.WALL_DOOR_STATES.CLOSED) return 0xa612d4;
			else if (ds === CONST.WALL_DOOR_STATES.OPEN) return 0x7c1a9b;
			else if (ds === CONST.WALL_DOOR_STATES.LOCKED) return 0xee4444;
		}

		// Standard Walls
		else return 0xffffbb;
	}

	/* -------------------------------------------- */

	/**
	 * Assume control of a Wall segment, replacing or adding it to the existing control set
	 *
	 * @param {Object}  options           Optional parameters which customize how control of the Wall is acquired
	 * @param {Boolean} options.chain     Add all contiguous segments to the controlled set
	 * @returns {Boolean}   A flag denoting whether the control operation was successful
	 */
	control({ chain = false } = {}) {
		// Flag controlled status
		this._controlled = true;
		this.layer._controlled[this.id] = this;

		// Add chained walls
		if (chain) {
			const links = this.getLinkedSegments();
			for (let l of links.walls) {
				l._controlled = true;
				this.layer._controlled[l.id] = l;
			}
		}

		// Draw control highlights
		this.layer.highlightControlledSegments();
		return true;
	}

	/* -------------------------------------------- */

	/** @override */
	release() {
		let released = super.release();
		this.layer.highlightControlledSegments();
		return released;
	}

	/* -------------------------------------------- */

	/** @override */
	destroy(options) {
		if (this.data.door && this.doorControl)
			this.doorControl.destroy({ children: true });
		super.destroy(options);
	}

	/* -------------------------------------------- */

	/**
	 * Test whether the Wall direction lies between two provided angles
	 * This test is used for collision and vision checks against one-directional walls
	 * @param lower
	 * @param upper
	 * @return {boolean}
	 */
	isDirectionBetweenAngles(lower, upper) {
		let d = this.direction;
		if (d < lower) {
			while (d < lower) d += 2 * Math.PI;
		} else if (d > upper) {
			while (d > upper) d -= 2 * Math.PI;
		}
		return d > lower && d < upper;
	}

	/* -------------------------------------------- */

	/**
	 * Get an Array of Wall objects which are linked by a common coordinate
	 * @returns {Object}    An object reporting ids and endpoints of the linked segments
	 */
	getLinkedSegments() {
		const test = new Set();
		const done = new Set();
		const ids = new Set();
		const objects = [];

		// Helper function to add wall points to the set
		const _addPoints = w => {
			let p0 = w.coords.slice(0, 2).join('.');
			if (!done.has(p0)) test.add(p0);
			let p1 = w.coords.slice(2).join('.');
			if (!done.has(p1)) test.add(p1);
		};

		// Helper function to identify other walls which share a point
		const _getWalls = p => {
			return canvas.walls.placeables.filter(w => {
				if (ids.has(w.id)) return false;
				let p0 = w.coords.slice(0, 2).join('.');
				let p1 = w.coords.slice(2).join('.');
				return p === p0 || p === p1;
			});
		};

		// Seed the initial search with this wall's points
		_addPoints(this);

		// Begin recursively searching
		while (test.size > 0) {
			const testIds = new Array(...test);
			for (let p of testIds) {
				let walls = _getWalls(p);
				walls.forEach(w => {
					_addPoints(w);
					if (!ids.has(w.id)) objects.push(w);
					ids.add(w.id);
				});
				test.delete(p);
				done.add(p);
			}
		}

		// Return the wall IDs and their endpoints
		return {
			ids: new Array(...ids),
			walls: objects,
			endpoints: new Array(...done).map(p => p.split('.').map(Number)),
		};
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/** @override */
	_onCreate() {
		canvas.addPendingOperation(
			'WallsLayer.initialize',
			this.layer.initialize,
			this.layer
		);
		canvas.addPendingOperation(
			'SightLayer.initialize',
			canvas.sight.initialize,
			canvas.sight
		);
		canvas.addPendingOperation(
			'LightingLayer.initialize',
			canvas.lighting.initialize,
			canvas.lighting
		);
		canvas.addPendingOperation(
			'SoundsLayer.initialize',
			canvas.sounds.initialize,
			canvas.sounds
		);
		if (this.data.door > 0) {
			canvas.addPendingOperation(
				'ControlsLayer.drawDoors',
				canvas.controls.drawDoors,
				canvas.controls
			);
		}
		this.layer._cloneType = duplicate(this.data);
	}

	/* -------------------------------------------- */

	/** @override */
	_onUpdate(data) {
		if (data.hasOwnProperty('dir')) this.draw();
		else this.refresh();

		// Trigger downstream operations
		canvas.addPendingOperation(
			'WallsLayer.initialize',
			this.layer.initialize,
			this.layer
		);
		canvas.addPendingOperation(
			'SightLayer.initialize',
			canvas.sight.initialize,
			canvas.sight
		);
		canvas.addPendingOperation(
			'LightingLayer.initialize',
			canvas.lighting.initialize,
			canvas.lighting
		);
		canvas.addPendingOperation(
			'SoundsLayer.initialize',
			canvas.sounds.initialize,
			canvas.sounds
		);
		if (this.data.door > 0) {
			canvas.addPendingOperation(
				'ControlsLayer.drawDoors',
				canvas.controls.drawDoors,
				canvas.controls
			);
		}
		if (this._controlled) {
			canvas.addPendingOperation(
				'WallsLayer.highlightControlledSegments',
				this.layer.highlightControlledSegments,
				this.layer
			);
		}
		this.layer._cloneType = duplicate(this.data);
	}

	/* -------------------------------------------- */

	/** @override */
	_onDelete() {
		this.release();
		canvas.addPendingOperation(
			'WallsLayer.initialize',
			this.layer.initialize,
			this.layer
		);
		canvas.addPendingOperation(
			'SightLayer.initialize',
			canvas.sight.initialize,
			canvas.sight
		);
		canvas.addPendingOperation(
			'LightingLayer.initialize',
			canvas.lighting.initialize,
			canvas.lighting
		);
		canvas.addPendingOperation(
			'SoundsLayer.initialize',
			canvas.sounds.initialize,
			canvas.sounds
		);
		if (this.data.door > 0) {
			canvas.addPendingOperation(
				'ControlsLayer.drawDoors',
				canvas.controls.drawDoors,
				canvas.controls
			);
		}
		if (this._controlled) {
			canvas.addPendingOperation(
				'WallsLayer.highlightControlledSegments',
				this.layer.highlightControlledSegments,
				this.layer
			);
		}
	}

	/* -------------------------------------------- */
	/*  Canvas Event Listeners                      */
	/* -------------------------------------------- */

	/** @override */
	_onDoubleLeft(event) {
		const sheet = this.sheet;
		const wallIds = Object.keys(this.layer._controlled).map(Number);
		sheet.options.editMany = wallIds.length > 1;
		sheet.options.editTargets = wallIds;
		this.sheet.render(true);
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseOver(event) {
		this.displayToFront();
		super._onMouseOver(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-hover events on the line segment itself, pulling the Wall to the front of the container stack
	 * @private
	 */
	_onMouseOverLine(event) {
		event.stopPropagation();
		if (event.data.dragState || event.data.createState) return;
		this.displayToFront();
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseDown(event) {
		let { origin, createState, originalEvent } = event.data;

		// Add or release walls from the controlled set
		let controlled = this._controlled;
		if (controlled) {
			if (originalEvent.shiftKey) this.release();
		} else {
			if (!originalEvent.shiftKey) this.layer.releaseAll();
			this.control({ chain: originalEvent.altKey });
		}

		// We may be concluding a layer creation workflow by ending on an existing wall endpoint
		if (createState > 0) return this.layer._onMouseDown(event);

		// Determine the wall coordinates
		let dLeft = Math.hypot(
				origin.x - this.coords[0],
				origin.y - this.coords[1]
			),
			dRight = Math.hypot(
				origin.x - this.coords[2],
				origin.y - this.coords[3]
			);

		// Set event data
		event.data.fixedPoint = dRight < dLeft ? 0 : 1;
		event.data.fixed =
			dRight < dLeft ? this.coords.slice(0, 2) : this.coords.slice(2, 4);
		event.data.wall = this;
	}

	/* -------------------------------------------- */

	/** @override */
	_onMouseMove(event) {
		let { handleState, origin, clone, fixed } = event.data,
			dest = event.data.getLocalPosition(this.layer),
			dx = dest.x - origin.x,
			dy = dest.y - origin.y;

		// Create the clone container
		if (
			handleState === 0 &&
			Math.hypot(dx, dy) >=
				canvas.dimensions.size / this.layer.gridPrecision
		) {
			event.data.handleState = handleState = 1;

			// Create a preview wall
			clone = this.clone().draw();
			this.layer.preview.addChild(clone);
			event.data.clone = clone;
			clone.alpha = 0.75;
			this.alpha = 0;

			// Temporarily remove the wall from the controlled set
			if (this._controlled) {
				event.data.wasControlled = true;
				this.release();
			}
		}

		// Update the clone position
		if (handleState > 0) {
			event.data.dest = dest;
			clone.data.c = fixed.concat([dest.x, dest.y]);
			clone.refresh();
		}
	}

	/* -------------------------------------------- */

	/** @override */
	async _onMouseUp(event) {
		let {
			wall,
			destination,
			fixed,
			fixedPoint,
			handleState,
			wasControlled,
		} = event.data;
		if (handleState === 0) return;

		// Update destination
		let dest = this.layer._getWallEndpointCoordinates(event, destination);
		let coords = fixedPoint === 0 ? fixed.concat(dest) : dest.concat(fixed);

		// If we have collapsed the wall - delete it, otherwise update
		if (coords[0] === coords[2] && coords[1] === coords[3])
			await wall.delete();
		else {
			await wall.update({ c: coords });
			if (wasControlled) this.control();
		}
		this._onDragCancel(event);

		// If we are holding CTRL - chain the drag completion into creating a new wall segment
		let oe = event.data.originalEvent;
		if (oe.ctrlKey || oe.metaKey) {
			event.data.chainStart = coords.slice(2, 4);
			this.layer._onMouseDown(event);
		}
	}
}

/**
 * A game settings configuration application
 * This form renders the settings defined via the game.settings.register API which have config = true
 *
 * @extends {FormApplication}
 */
class SettingsConfig extends FormApplication {
	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			title: game.i18n.localize('SETTINGS.Title'),
			id: 'client-settings',
			template: 'templates/sidebar/apps/settings-config.html',
			width: 600,
			height: 'auto',
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		// Sort settings into Core, System, and Module tabs
		const settings = Object.values(this.object).reduce(
			(obj, setting) => {
				if (!setting.config) return obj;

				// Update setting data
				let s = duplicate(setting);
				s.value = game.settings.get(s.module, s.key);
				s.type =
					setting.type instanceof Function
						? setting.type.name
						: 'String';
				s.isCheckbox = setting.type === Boolean;
				s.isSelect = s.choices !== undefined;
				s.editable = game.user.isGM || s.scope === 'client';

				// Core and System settings
				if (s.module === 'core') obj.core.push(s);
				else if (s.module === game.system.id) obj.system.push(s);
				// Module settings
				else {
					let mod = game.modules.find(m => m.id === s.module);
					if (!mod) return obj;
					let mn = mod.data.name;
					obj.modules[mn] = obj.modules[mn] || {
						module: mod,
						settings: [],
					};
					obj.modules[mn].settings.push(s);
				}
				return obj;
			},
			{ core: [], system: [], modules: {} }
		);

		// Sort Module headings
		settings.modules = Object.keys(settings.modules)
			.sort((a, b) => a - b)
			.map(k => settings.modules[k]);

		// Return data
		return {
			user: game.user,
			core: settings.core,
			system: settings.system,
			systemTitle: game.system.data.title,
			modules: settings.modules,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Activate Tab Navigation
		new Tabs(html.find('.tabs'), {
			initial: this._tab || 'core',
			callback: clicked => (this._tab = clicked.data('tab')),
			container: html,
		});

		// Reset Default Values
		html.find('button[name="reset"]').click(
			this._onResetDefaults.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle button click to reset default settings
	 * @param event {Event}   The initial button click event
	 * @private
	 */
	_onResetDefaults(event) {
		event.preventDefault();
		const button = event.target;
		const form = button.form;
		for (let [k, v] of Object.entries(game.settings.settings)) {
			if (v.config) {
				let input = form[k];
				if (input.type === 'checkbox') input.checked = v.default;
				else if (input) input.value = v.default;
			}
		}
	}

	/* -------------------------------------------- */

	/** @override */
	_updateObject(event, formData) {
		for (let [k, v] of Object.entries(formData)) {
			let s = game.settings.settings[k],
				current = game.settings.get(s.module, s.key);
			if (v !== current) game.settings.set(s.module, s.key, v);
		}
	}
}

/**
 * Keyboard Controls Reference Sheet
 * @type {Application}
 */
class ControlsReference extends Application {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.title = game.i18n.localize('CONTROLS.Title');
		options.id = 'controls-reference';
		options.template = 'templates/sidebar/apps/controls-reference.html';
		options.width = 600;
		return options;
	}
}

/**
 * Game Invitation Links Reference
 * @extends {Application}
 */
class InvitationLinks extends Application {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'invitation-links',
			template: 'templates/sidebar/apps/invitation-links.html',
			title: game.i18n.localize('INVITATIONS.Title'),
			width: 400,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		return game.data.addresses;
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		html.find('.invite-link').click(ev => {
			ev.preventDefault();
			ev.target.select();
			document.execCommand('copy');
			ui.notifications.info(game.i18n.localize('INVITATIONS.Copied'));
		});
	}
}

/**
 * The Module Management Application
 *
 * This application provides a view of which modules are available to be used and allows for configuration of the
 * set of modules which are active within the World.
 *
 * @type {Application}
 */
class ModuleManagement extends FormApplication {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.title = game.i18n.localize('MODMANAGE.Title');
		options.id = 'module-management';
		options.template = 'templates/sidebar/apps/module-management.html';
		options.popOut = true;
		options.editable = game.user.isGM;
		options.width = 600;
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Obtain module metadata and merge it with game settings which track current module visibility
	 * @return {Object}   The data provided to the template when rendering the form
	 */
	getData() {
		// Get the available modules
		const modules = game.modules.map(m => m.data),
			settings = game.settings.get(
				'core',
				this.constructor.CONFIG_SETTING
			);

		// Flag the current module state
		for (let mod of modules) {
			mod.active = settings[mod.name] === true;
			mod.hasPacks = mod.packs.length > 0;
			mod.hasScripts = mod.scripts.length > 0;
			mod.hasStyles = mod.styles.length > 0;
			mod.systemOnly =
				mod.systems && mod.systems.indexOf(game.system.id) !== -1;
			mod.systemTag = game.system.id;
		}

		// Return data to the template
		return {
			user: game.user,
			modules: modules,
		};
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/**
	 * This method is called upon form submission after form data is validated
	 * @param event {Event}       The initial triggering submission event
	 * @param formData {Object}   The object of validated form data with which to update the object
	 * @private
	 */
	_updateObject(event, formData) {
		const settings = game.settings.get(
			'core',
			this.constructor.CONFIG_SETTING
		);
		game.settings
			.set(
				'core',
				this.constructor.CONFIG_SETTING,
				mergeObject(settings, formData)
			)
			.then(() => {
				window.location.reload();
			});
	}
}

ModuleManagement.CONFIG_SETTING = 'moduleConfiguration';
/**
 * A directory list of :class:`Actor` entities in the Sidebar
 * @type {SidebarDirectory}
 */
class ActorDirectory extends SidebarDirectory {
	static get entity() {
		return 'Actor';
	}

	static get collection() {
		return game.actors;
	}

	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Actor Directory HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// Everything below is a GM-only option
		if (!game.user.isGM) return;

		// Drag a token to the canvas
		html.find('li.actor').each((i, li) => {
			li.setAttribute('draggable', true);
			li.addEventListener(
				'dragstart',
				ev => this._onDragStart(ev),
				false
			);
		});
	}

	/* -------------------------------------------- */

	getData() {
		const data = super.getData();
		data.folderPartial = 'templates/sidebar/folder-partial.html';
		data.entityPartial = 'templates/sidebar/actor-partial.html';
		return data;
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * Extend the default set of options provided by SidebarDirectory._getEntryContextOptions
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: 'SIDEBAR.CharArt',
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data('entityId'));
					return actor.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const actor = game.actors.get(li.data('entityId'));
					new ImagePopout(actor.data.img, {
						title: actor.name,
						shareable: true,
						entity: { type: 'Actor', id: actor.id },
					}).render(true);
				},
			},
			{
				name: 'SIDEBAR.TokenArt',
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const actor = game.actors.get(li.data('entityId'));
					return ![null, undefined, CONST.DEFAULT_TOKEN].includes(
						actor.data.token.img
					);
				},
				callback: li => {
					const actor = game.actors.get(li.data('entityId'));
					new ImagePopout(actor.data.token.img, {
						title: actor.name,
						shareable: true,
						entity: { type: 'Actor', id: actor.id },
					}).render(true);
				},
			},
		].concat(options);
	}
}

/**
 * The Chat Log application
 * @param {Boolean} options.stream      Render just the chat log for stream view
 * @type {SidebarTab}
 */
class ChatLog extends SidebarTab {
	constructor(options) {
		super(options);

		// Internal flags
		this._setup = 0;
		this._sentMessages = [];
		this._sentMessageIndex = -1;
		this._lastMessageTime = 0;

		// Update timestamps every 15 seconds
		setInterval(this.updateTimestamps, 1000 * 15);

		// Register game setting
		game.settings.register('core', 'rollMode', {
			name: 'Default Roll Type',
			hint:
				'Configure the default rolling behavior for automated dice rolls',
			scope: 'client',
			config: false,
			default: 'roll',
			type: String,
			choices: CONFIG.rollModes,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by this Application
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'chat';
		options.template = 'templates/sidebar/chat-log.html';
		options.title = game.i18n.localize('CHAT.Title');
		options.scrollContainer = null;
		return options;
	}

	/* -------------------------------------------- */
	/*  Application Rendering                       */
	/* -------------------------------------------- */

	/**
	 * Prepare the data used to render the ChatLog application
	 * @return {Object}
	 */
	getData() {
		return {
			user: game.user,
			rollMode: game.settings.get('core', 'rollMode'),
			rollModes: CONFIG.rollModes,
			isStream: !!this.options.stream,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Extend the inner rendering function to post all chat message when the container is re-rendered
	 * @return {Promise.<void>}
	 * @private
	 */
	async _render(...args) {
		await super._render(...args);
		this.postAll();
		this._setup = 1;
	}

	/* -------------------------------------------- */

	renderPopout(original) {
		throw 'ChatLog does not support pop-out mode';
	}

	/* -------------------------------------------- */
	/*  Chat Sidebar Methods                        */
	/* -------------------------------------------- */

	/**
	 * Delete a single message from the chat log
	 * @param {String} messageId    The ChatMessage entity to remove from the log
	 */
	deleteMessage(messageId) {
		let li = this.element.find(`.message[data-message-id="${messageId}"]`);
		if (li.length) li.slideUp(100, () => li.remove());
	}

	/* -------------------------------------------- */

	/**
	 * Parse a chat string to identify the chat command (if any) which was used
	 * @param {String} message    The message to match
	 * @return {Array}            The identified command and regex match
	 */
	static parse(message) {
		// Dice roll regex
		let formula = '([^#]*)'; // Capture any string not starting with '#'
		formula += '(?:(?:#\\s?)(.*))?'; // Capture any remaining flavor text
		const roll = '^(\\/r(?:oll)? )'; // Regular rolls, support /r or /roll
		const gm = '^(\\/gmr(?:oll)? )'; // GM rolls, support /gmr or /gmroll
		const br = '^(\\/b(?:lind)?r(?:oll)? )'; // Blind rolls, support /br or /blindroll
		const sr = '^(\\/s(?:elf)?r(?:oll)? )'; // Self rolls, support /sr or /sroll
		const any = '([^]*)'; // Any character, including new lines

		// Define regex patterns
		const patterns = {
			roll: new RegExp(roll + formula, 'i'),
			gmroll: new RegExp(gm + formula, 'i'),
			blindroll: new RegExp(br + formula, 'i'),
			selfroll: new RegExp(sr + formula, 'i'),
			ic: new RegExp('^(/ic )' + any, 'i'),
			ooc: new RegExp('^(/ooc )' + any, 'i'),
			emote: new RegExp('^(/em(?:ote)? )' + any, 'i'),
			whisper: new RegExp(
				/^(@|\/w(?:hisper)?\s{1})(\[(?:[^\]]+)\]|(?:[^\s]+))\s+([^]*)/,
				'i'
			),
			none: new RegExp('()' + any, 'i'),
		};

		// Iterate over patterns, finding the first match
		let c, rgx, match;
		for ([c, rgx] of Object.entries(patterns)) {
			match = message.match(rgx);
			if (match) return [c, match];
		}
		return [null, null];
	}

	/* -------------------------------------------- */

	/**
	 * Post a single chat message to the log
	 * @param {ChatMessage} message   A ChatMessage entity instance to post to the log
	 * @param {Boolean} [notify]      Trigger a notification which shows the log as having a new unread message
	 * @return {Promise}              A Promise which resolves once the message is posted
	 */
	async postOne(message, notify = false) {
		if (!message.visible) return;
		return message.render().then(html => {
			this.element.find('#chat-log').append(html);
			this.scrollBottom();
			if (notify) this.notify(message);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Scroll the chat log to the bottom
	 * @private
	 */
	scrollBottom() {
		let log = this.element.find('#chat-log');
		log.scrollTop(log[0].scrollHeight);
	}

	/* -------------------------------------------- */

	/**
	 * Update the content of a previously posted message after its data has been replaced
	 * @param {ChatMessage} message   The ChatMessage instance to update
	 * @param {Boolean} notify        Trigger a notification which shows the log as having a new unread message
	 */
	updateMessage(message, notify = false) {
		let li = this.element.find(`.message[data-message-id="${message.id}"]`);
		if (li.length) message.render().then(html => li.replaceWith(html));
		if (notify) this.notify(message);
	}

	/* -------------------------------------------- */

	/**
	 * If there are any pending messages in the chat log, post them
	 * @return {Promise}    A Promise which resolves once all messages are posted
	 */
	async postAll() {
		this.element.find('#chat-log').html('');
		await getTemplate('templates/sidebar/chat-message.html');
		for (let message of game.messages.entities) {
			await this.postOne(message, false).catch(err => {
				console.error(
					`Chat message ${message._id} failed to render.\n${err})`
				);
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Trigger a notification that alerts the user visually and audibly that a new chat log message has been posted
	 */
	notify(message) {
		this._lastMessageTime = new Date();
		if (this._setup === 0) return;

		// Display the chat notification icon and remove it 3 seconds later
		let icon = $('#chat-notification');
		if (icon.is(':hidden')) icon.fadeIn(100);
		setTimeout(() => {
			if (
				new Date() - this._lastMessageTime > 3000 &&
				icon.is(':visible')
			)
				icon.fadeOut(100);
		}, 3001);

		// Play a notification sound effect
		if (message.data.sound) AudioHelper.play({ src: message.data.sound });
	}

	/* -------------------------------------------- */

	/**
	 * Delete all messages from the DOM, optionally emitting a signal back to the server to propagate deletion
	 */
	deleteAll() {
		$('#chat-log')
			.children()
			.each(
				function() {
					$(this).slideUp();
				},
				() => log.html('')
			);
	}

	/* -------------------------------------------- */

	updateTimestamps() {
		let stamps = game.messages.entities.reduce((acc, val) => {
			acc[val._id] = val.data.timestamp;
			return acc;
		}, {});
		$('#chat-log')
			.children()
			.each((i, li) => {
				let id = li.getAttribute('data-message-id'),
					stamp = stamps[id];
				if (!stamp) return;
				li.querySelector('.message-timestamp').textContent = timeSince(
					stamp
				);
			});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
  /* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the ChatLog application
	 * @param html {jQuery|HTMLElement}
	 */
	activateListeners(html) {
		// Chat message entry
		html.find('#chat-message').keydown(this._onChatKeyDown.bind(this));

		// Expand dice roll tooltips
		html.on('click', '.dice-roll', this._onDiceRollClick.bind(this));

		// Modify Roll Type
		html.find('select[name="rollMode"]').change(
			this._onChangeRollMode.bind(this)
		);

		// Single Message Delete
		html.on('click', 'a.message-delete', this._onDeleteMessage.bind(this));

		// Flush log
		html.find('a.chat-flush').click(this._onFlushLog.bind(this));

		// Export log
		html.find('a.export-log').click(this._onExportLog.bind(this));

		// Chat Entry context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data object of chat message data depending on the type of message being posted
	 * @param {String} message      The original string of the message content
	 * @return {Promise.<Object>}   A Promise resolving to the prepared chat data object
	 * @private
	 */
	async processMessage(message) {
		// Parse the message to determine the matching handler
		let [command, match] = this.constructor.parse(message);
		if (!match) throw new Error('Unmatched chat command');

		// Set up basic chat data
		const chatData = {
			user: game.user._id,
			speaker: ChatMessage.getSpeaker(),
		};
		const createOptions = {};

		// Allow for handling of the entered message to be intercepted by a hook
		if (Hooks.call('chatMessage', this, message, chatData) === false)
			return chatData;

		// Process message data based on the identified command type
		if (command === 'none') command = chatData.speaker.token ? 'ic' : 'ooc';
		switch (command) {
			case 'roll':
			case 'gmroll':
			case 'blindroll':
			case 'selfroll':
				this._processDiceCommand(
					command,
					match,
					chatData,
					createOptions
				);
				break;
			case 'whisper':
				this._processWhisperCommand(
					command,
					match,
					chatData,
					createOptions
				);
				break;
			case 'ic':
			case 'emote':
			case 'ooc':
				this._processChatCommand(
					command,
					match,
					chatData,
					createOptions
				);
				break;
		}

		// Create the message using provided data and options
		return ChatMessage.create(chatData, createOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a dice-roll command
	 * @param {String} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processDiceCommand(command, match, chatData, createOptions) {
		// Roll content and flavor text
		let [formula, flavor] = match.slice(2, 4);
		mergeObject(chatData, {
			content: formula,
			flavor: flavor || null,
			type: CONST.CHAT_MESSAGE_TYPES.ROLL,
		});

		// Convert the chat content into a Roll
		try {
			chatData.roll = new Roll(formula, Roll.getActorData()).roll();
		} catch (err) {
			throw new Error(`Unable to parse the roll expression: ${formula}.`);
		}

		// Record additional roll data
		chatData.sound = CONFIG.sounds.dice;
		if (['gmroll', 'blindroll'].includes(command))
			chatData.whisper = ChatMessage.getWhisperIDs('GM');
		if (command === 'selfroll') chatData.whisper = [game.user._id];
		if (command === 'blindroll') chatData.blind = true;
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a chat whisper command
	 * @param {String} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processWhisperCommand(command, match, chatData, createOptions) {
		chatData.type = CONST.CHAT_MESSAGE_TYPES.WHISPER;
		delete chatData.speaker;
		let [names, message] = match.slice(2, 4);

		// Get recipient IDs
		names = names.replace(/[\[\]]/g, '');
		if (!names) return;
		let ids = names
			.split(',')
			.map(m => m.trim())
			.reduce((a, n) => a.concat(ChatMessage.getWhisperIDs(n)), []);
		if (ids.length) chatData.whisper = Array.from(new Set(ids));
		else throw new Error('No target users exist for this whisper.');

		// Update chat data
		chatData.content = message;
		chatData.sound = CONFIG.sounds.notification;
	}

	/* -------------------------------------------- */

	/**
	 * Process messages which are posted using a chat whisper command
	 * @param {String} command          The chat command type
	 * @param {RegExpMatchArray} match  The matched RegExp expressions
	 * @param {Object} chatData         The initial chat data
	 * @param {Object} createOptions    Options used to create the message
	 * @private
	 */
	_processChatCommand(command, match, chatData, createOptions) {
		if (
			['ic', 'emote'].includes(command) &&
			!(chatData.speaker.actor || chatData.speaker.token)
		) {
			throw new Error(
				'You cannot chat in-character without an identified speaker'
			);
		}
		chatData.content = match[2];

		// Augment chat data
		if (command === 'ic') {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.IC;
			createOptions.chatBubble = true;
		} else if (command === 'emote') {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.EMOTE;
			chatData.content = `${chatData.speaker.alias} ${chatData.content}`;
			createOptions.chatBubble = true;
		} else {
			chatData.type = CONST.CHAT_MESSAGE_TYPES.OOC;
			delete chatData.speaker;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Add a sent message to an array of remembered messages to be re-sent if the user pages up with the up arrow key
	 * @param message {String}
	 * @private
	 */
	_remember(message) {
		if (this._sentMessages.length === 5) this._sentMessages.splice(4, 1);
		this._sentMessages.unshift(message);
		this._sentMessageIndex = -1;
	}

	/* -------------------------------------------- */

	/**
	 * Recall a previously sent message by incrementing up (1) or down (-1) through the sent messages array
	 * @param increment {Number}    The direction to recall
	 * @return {String}             The recalled message, or null
	 * @private
	 */
	_recall(increment) {
		if (this._sentMessages.length > 0) {
			this._sentMessageIndex = Math.min(
				this._sentMessages.length - 1,
				this._sentMessageIndex + increment
			);
			return this._sentMessages[this._sentMessageIndex];
		}
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * Compendium sidebar Context Menu creation
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		// Entry Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(
			`get${this.constructor.name}EntryContext`,
			html,
			entryOptions
		);
		if (entryOptions) new ContextMenu(html, '.message', entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the ChatLog entry context options
	 * @return {Array}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [];
	}

	/* -------------------------------------------- */

	/**
	 * Handle keydown events in the chat entry textarea
	 * @param {Event} event
	 * @private
	 */
	_onChatKeyDown(event) {
		// UP/DOWN ARROW -> Recall Previous Messages
		if ([KEYS.UP, KEYS.DOWN].includes(event.keyCode)) {
			event.preventDefault();
			let textarea = event.currentTarget,
				message = this._recall(event.keyCode === KEYS.UP ? 1 : -1);
			if (message) textarea.value = message;
		}

		// ENTER -> Send Message
		else if (event.keyCode === KEYS.ENTER && !event.shiftKey) {
			event.preventDefault();
			let textarea = event.currentTarget,
				message = textarea.value;
			if (!message) return;

			// Prepare chat message data and handle result
			this.processMessage(message)
				.then(() => {
					textarea.value = '';
					this._remember(message);
				})
				.catch(error => {
					ui.notifications.error(error);
					throw error;
				});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle setting the preferred roll mode
	 * @param {Event} event
	 * @private
	 */
	_onChangeRollMode(event) {
		event.preventDefault();
		game.settings.set('core', 'rollMode', event.target.value);
	}

	/* -------------------------------------------- */

	/**
	 * Handle clicking of dice tooltip buttons
	 * @param {Event} event
	 * @private
	 */
	_onDiceRollClick(event) {
		event.preventDefault();
		let roll = $(event.currentTarget),
			tip = roll.find('.dice-tooltip');
		if (!tip.is(':visible')) tip.slideDown(200);
		else tip.slideUp(200);
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to export the chat log
	 * @param {Event} event
	 * @private
	 */
	_onExportLog(event) {
		event.preventDefault();
		game.messages.export();
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events to flush the chat log
	 * @param {Event} event
	 * @private
	 */
	_onFlushLog(event) {
		event.preventDefault();
		game.messages.flush();
	}

	/* -------------------------------------------- */

	/**
	 * Handle single message deletion workflow
	 * @param {Event} event
	 * @private
	 */
	_onDeleteMessage(event) {
		event.preventDefault();
		const li = $(event.currentTarget).parents('.message');
		const message = Messages.instance.get(li.data('messageId'));
		return message.delete();
	}
}

/* -------------------------------------------- */

CONFIG.rollModes = {
	roll: 'CHAT.RollPublic',
	gmroll: 'CHAT.RollPrivate',
	blindroll: 'CHAT.RollBlind',
	selfroll: 'CHAT.RollSelf',
};

/**
 * The combat and turn order tracker tab
 * @type {SidebarTab}
 */
class CombatTracker extends SidebarTab {
	constructor(options) {
		super(options);
		game.combats.apps.push(this);

		/**
		 * Record a reference to the currently highlighted Token
		 * @type {Token|null}
		 * @private
		 */
		this._highlighted = null;

		/**
		 * Cache the values of additional tracked resources for each Token in Combat
		 * @type {Object}
		 */
		this.trackedResources = this.updateTrackedResources();
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'combat';
		options.template = 'templates/sidebar/combat-tracker.html';
		options.title = 'Combat Tracker';
		return options;
	}

	/* -------------------------------------------- */
	/*  Methods
	/* -------------------------------------------- */

	/**
	 * Update the value of tracked resources which are reported for each combatant
	 * @return {Object}
	 */
	updateTrackedResources() {
		const combat = game.combat;
		if (!combat) return (this.trackedResources = {});
		const resources = [combat.settings.resource]; // For future tracking of multiple resources
		this.trackedResources = game.combat.turns.reduce((obj, t) => {
			const token = new Token(t.token);
			let obs = t.actor && t.actor.hasPerm(game.user, 'OBSERVER');
			obj[token.id] = resources.reduce((res, r) => {
				res[r] =
					obs && t.actor
						? getProperty(token.actor.data.data, r)
						: null;
				return res;
			}, {});
			return obj;
		}, {});

		// Synchronize updates with the pop-out tracker
		if (this._popout) this._popout.trackedResources = this.trackedResources;
		return this.trackedResources;
	}

	/* -------------------------------------------- */

	/**
	 * Scroll the combat log container to ensure the current Combatant turn is centered vertically
	 */
	scrollToTurn() {
		const combat = game.combat;
		let active = this.element.find('.active')[0];
		if (!active) return;
		let container = active.parentElement;
		const nViewable = Math.floor(
			container.offsetHeight / active.offsetHeight
		);
		container.scrollTop =
			combat.turn * active.offsetHeight -
			(nViewable / 2) * active.offsetHeight;
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(force, options) {
		await super._render(force, options);
		if (options.resetScroll || this._scrollTop === null)
			this.scrollToTurn();
	}

	/* -------------------------------------------- */

	/** @override */
	getData() {
		let activeScene = game.scenes.active;

		// Get combat encounters for the scene
		const combats = activeScene
			? game.combats.entities.filter(
					c => c.data.scene === activeScene._id
			  )
			: [];
		const activeIdx = combats.findIndex(c => c.data.active);
		const hasCombat = activeIdx !== -1;
		const settings = game.settings.get('core', Combat.CONFIG_SETTING);

		// Prepare rendering data
		const data = {
			user: game.user,
			combats: combats,
			currentIndex: activeIdx + 1,
			previousId: activeIdx > 0 ? combats[activeIdx - 1]._id : '',
			nextId:
				activeIdx < combats.length - 1
					? combats[activeIdx + 1]._id
					: '',
			combatCount: combats.length,
			hasCombat: hasCombat,
			started: this.started,
			settings: settings,
		};

		if (!hasCombat) {
			return mergeObject(data, {
				turns: [],
				control: false,
			});
		}

		// Add active combat data
		const combat = combats[activeIdx];
		if (!combat.turns) combat.turns = combat.setupTurns();
		const combatant = combat.combatant;

		// Does the player have current control?
		let hasControl =
			combatant &&
			combatant.players &&
			combatant.players.includes(game.user);

		// Update data for combatant turns
		const turns = combat.turns
			.map((t, i) => {
				// Name and Image
				t.name = t.token.name || t.actor.name;
				t.img = t.defeated
					? 'icons/svg/skull.svg'
					: t.token.img || t.actor.img;

				// Turn order and initiative
				t.active = i === combat.turn;
				t.initiative = isNaN(parseFloat(t.initiative))
					? null
					: Number(t.initiative).toFixed(CONFIG.initiative.decimals);
				t.hasRolled = t.initiative !== null;

				// Styling rules
				t.css = [
					t.active ? 'active' : '',
					t.hidden ? 'hidden' : '',
					t.defeated ? 'defeated' : '',
				]
					.join(' ')
					.trim();

				// Tracked resources
				t.resource = this.trackedResources[t.tokenId][
					settings.resource
				];
				return t;
			})
			.filter(t => t.visible);

		// Merge update data for rendering
		return mergeObject(data, {
			combat: combat,
			round: combat.data.round,
			turn: combat.data.turn,
			turns: turns,
			control: hasControl,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);
		let names = html.find('.token-name');

		// Create new Combat encounter
		html.find('.combat-create').click(ev => this._onCombatCreate(ev));

		// Display Combat settings
		html.find('.combat-settings').click(ev => {
			ev.preventDefault();
			new CombatTrackerConfig().render(true);
		});

		// Cycle the current Combat encounter
		html.find('.combat-cycle').click(ev => this._onCombatCycle(ev));

		// Combat control
		html.find('.combat-control').click(ev => this._onCombatControl(ev));

		// Combatant control
		html.find('.combatant-control').click(ev =>
			this._onCombatantControl(ev)
		);

		// Hover on Combatant
		names.hover(
			this._onCombatantHover.bind(this),
			this._onCombatantHoverOut.bind(this)
		);

		// Click on Combatant
		names.click(this._onCombatantMouseDown.bind(this));

		// Context on right-click
		if (game.user.isGM) this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Handle new Combat creation request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCreate(event) {
		event.preventDefault();
		let scene = game.scenes.active;
		if (!scene) return;
		let cbt = await Combat.create({ scene: scene._id });
		await cbt.activate();
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combat deletion request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatDelete(event) {
		event.preventDefault();
		let btn = event.currentTarget;
		if (btn.hasAttribute('disabled')) return;
		let cbt = game.combats.get(btn.getAttribute('data-combat-id'));
		await cbt.delete();
		if (!game.combats.active) {
			let first = game.combats.combats.shift();
			if (first) await first.activate();
		}
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combat cycle request
	 * @param {Event} event
	 * @private
	 */
	async _onCombatCycle(event) {
		event.preventDefault();
		let btn = event.currentTarget,
			combatId = btn.getAttribute('data-combat-id');
		if (!combatId) return;
		await game.combats.get(combatId).activate();
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle click events on Combat control buttons
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatControl(event) {
		event.preventDefault();
		const ctrl = event.currentTarget;
		if (ctrl.getAttribute('disabled')) return;
		else ctrl.setAttribute('disabled', true);
		const fn = game.combat[ctrl.dataset.control];
		if (fn) await fn.bind(game.combat)();
		ctrl.removeAttribute('disabled');
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Combatant control toggle
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	async _onCombatantControl(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const li = btn.closest('.combatant');
		const c = game.combat.getCombatant(li.dataset.combatantId);

		// Switch control action
		switch (btn.dataset.control) {
			// Toggle combatant visibility
			case 'toggleHidden':
				await game.combat.updateCombatant({
					_id: c._id,
					hidden: !c.hidden,
				});
				break;

			// Toggle combatant defeated flag
			case 'toggleDefeated':
				let isDefeated = !c.defeated;
				await game.combat.updateCombatant({
					_id: c._id,
					defeated: isDefeated,
				});
				const token = canvas.tokens.get(c.tokenId);
				if (token) {
					if (isDefeated && !token.data.overlayEffect)
						token.toggleOverlay(CONFIG.controlIcons.defeated);
					else if (
						!isDefeated &&
						token.data.overlayEffect ===
							CONFIG.controlIcons.defeated
					)
						token.toggleOverlay(null);
				}
				break;

			// Roll combatant initiative
			case 'rollInitiative':
				await game.combat.rollInitiative([c._id]);
				break;
		}

		// Render tracker updates
		this.render();
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-down event on a combatant name in the tracker
	 * @private
	 * @param {Event} event   The originating mousedown event
	 */
	_onCombatantMouseDown(event) {
		event.preventDefault();
		if (!canvas.scene.data.active) return;
		const li = event.currentTarget.parentElement;
		const token = canvas.tokens.get(li.dataset.tokenId);
		token.control();
		canvas.tokens.cycleTokens(1, true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-hover events on a combatant in the tracker
	 * @private
	 */
	_onCombatantHover(event) {
		event.preventDefault();
		if (!canvas.scene.data.active) return;
		const li = event.currentTarget.parentElement;
		const token = canvas.tokens.get(li.dataset.tokenId);
		if (token && token.isVisible) {
			if (!token._controlled) token._onMouseOver(event);
			this._highlighted = token;
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle mouse-unhover events for a combatant in the tracker
	 * @private
	 */
	_onCombatantHoverOut(event) {
		event.preventDefault();
		if (!canvas.scene.data.active) return;
		if (this._highlighted) this._highlighted._onMouseOut(event);
		this._highlighted = null;
	}

	/* -------------------------------------------- */

	/**
	 * Default folder context actions
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(
			`get${this.constructor.name}EntryContext`,
			html,
			entryOptions
		);
		if (entryOptions)
			new ContextMenu(html, '.directory-item', entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: 'Modify',
				icon: '<i class="fas fa-edit"></i>',
				callback: li => this._showModifyCombatantInitiativeContext(li),
			},
			{
				name: 'Reroll',
				icon: '<i class="fas fa-dice-d20"></i>',
				callback: li =>
					game.combat.rollInitiative(li.data('combatant-id')),
			},
			{
				name: 'Remove',
				icon: '<i class="fas fa-skull"></i>',
				callback: li =>
					game.combat.deleteCombatant(li.data('combatant-id')),
			},
		];
	}

	/* -------------------------------------------- */

	/**
	 * Display a dialog which prompts the user to enter a new initiative value for a Combatant
	 * @param {jQuery} li
	 * @private
	 */
	_showModifyCombatantInitiativeContext(li) {
		const combatant = game.combat.getCombatant(li.data('combatant-id'));
		new Dialog(
			{
				title: `Modify ${combatant.name} Initiative`,
				content: `<div class="form-group">
                  <label>Initiative Value</label>
                  <input name="initiative" value="${combatant.initiative ||
						''}" placeholder="Value"/>
                </div>`,
				buttons: {
					set: {
						icon: '<i class="fas fa-dice-d20"></i>',
						label: 'Modify Roll',
						callback: html => {
							let init = parseFloat(
								html.find('input[name="initiative"]').val()
							);
							game.combat.setInitiative(
								combatant._id,
								Math.round(init * 100) / 100
							);
						},
					},
					cancel: {
						icon: '<i class="fas fa-times"></i>',
						label: 'Cancel',
					},
				},
				default: 'set',
			},
			{
				top: Math.min(li[0].offsetTop, window.innerHeight - 350),
				left: window.innerWidth - 720,
				width: 400,
			}
		).render(true);
	}
}

/**
 * A compendium of knowledge arcane and mystical!
 * @type {SidebarTab}
 */
class CompendiumDirectory extends SidebarTab {
	/**
	 * Assign the default options which are supported by this Application
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'compendium';
		options.template = 'templates/sidebar/compendium.html';
		options.title = 'Compendium Packs';
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data used to render the CompendiumList application
	 * @return {Object}
	 */
	getData() {
		// Filter packs for visibility
		let packs = game.packs.filter(p => game.user.isGM || p.public);

		// Sort packs by Entity type
		const packData = packs
			.sort((a, b) => a.entity.localeCompare(b.entity))
			.reduce((obj, pack) => {
				let ent = pack.entity;
				if (!obj.hasOwnProperty(ent))
					obj[ent] = {
						label: ent,
						packs: [],
					};
				obj[ent].packs.push(pack);
				return obj;
			}, {});

		// Sort packs within type
		for (let [e, p] of Object.entries(packData)) {
			p.packs = p.packs.sort((a, b) => a.title.localeCompare(b.title));
		}

		// Return data to the sidebar
		return {
			user: game.user,
			packs: packData,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Compendium tab
	 * Do not extend the parent functionality, instead override it entirely
	 */
	activateListeners(html) {
		// Click to open
		html.find('.compendium-pack').click(ev => {
			let li = $(ev.currentTarget),
				pack = game.packs.find(
					p => p.collection === li.attr('data-pack')
				);
			if (li.attr('data-open') === '1') pack.close();
			else {
				li.attr('data-open', '1');
				li.find('i.folder')
					.removeClass('fa-folder')
					.addClass('fa-folder-open');
				pack.render(true);
			}
		});

		// Options below are GM only
		if (!game.user.isGM) return;

		// Create Compendium
		html.find('.create-compendium').click(
			this._onCreateCompendium.bind(this)
		);

		// Compendium context menu
		this._contextMenu(html);
	}

	/* -------------------------------------------- */

	/**
	 * Compendium sidebar Context Menu creation
	 * @param html {jQuery}
	 * @private
	 */
	_contextMenu(html) {
		// Entry Context
		const entryOptions = this._getEntryContextOptions();
		Hooks.call(
			`get${this.constructor.name}EntryContext`,
			html,
			entryOptions
		);
		if (entryOptions)
			new ContextMenu(html, '.compendium-pack', entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get the sidebar directory entry context options
	 * @return {Object}   The sidebar entry context options
	 * @private
	 */
	_getEntryContextOptions() {
		return [
			{
				name: 'COMPENDIUM.MarkPublic',
				icon: '<i class="fas fa-eye"></i>',
				condition: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					return !pack.public;
				},
				callback: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					let visible = game.settings.get(
						'core',
						'compendiumVisibility'
					);
					visible[pack.collection] = true;
					game.settings.set('core', 'compendiumVisibility', visible);
				},
			},
			{
				name: 'COMPENDIUM.MarkPrivate',
				icon: '<i class="fas fa-eye-slash"></i>',
				condition: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					return pack.public;
				},
				callback: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					let visible = game.settings.get(
						'core',
						'compendiumVisibility'
					);
					visible[pack.collection] = false;
					game.settings.set('core', 'compendiumVisibility', visible);
				},
			},
			{
				name: 'COMPENDIUM.Delete',
				icon: '<i class="fas fa-trash"></i>',
				condition: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					return pack.metadata.package === 'world';
				},
				callback: li => {
					let pack = game.packs.find(
						p => p.collection === li.attr('data-pack')
					);
					this._onDeleteCompendium(pack);
				},
			},
		];
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Compendium Pack creation request
	 * @param event
	 * @private
	 */
	async _onCreateCompendium(event) {
		event.preventDefault();
		const html = await renderTemplate(
			'templates/sidebar/compendium-create.html',
			{
				entityTypes: CONST.COMPENDIUM_ENTITY_TYPES,
			}
		);
		new Dialog({
			title: 'Create New Compendium',
			content: html,
			buttons: {
				create: {
					icon: '<i class="fas fa-check"></i>',
					label: 'Create Compendium',
					callback: dlg => {
						const form = dlg.find('#compendium-create'),
							data = validateForm(form[0]);
						Compendium.create(data).then(pack => {
							this.render();
						});
					},
				},
			},
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle a Compendium Pack deletion request
	 * @param {Object} pack   The pack object requested for deletion
	 * @private
	 */
	_onDeleteCompendium(pack) {
		new Dialog({
			title: `Delete Compendium: ${pack.metadata.label}`,
			content:
				'<h2>Are you sure?</h2><p>This Compendium Pack will be permanently deleted and cannot be recovered.</p>',
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: 'Delete',
					callback: () => pack.delete(),
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: 'Cancel',
				},
			},
			default: 'no',
		}).render(true);
	}
}

/* -------------------------------------------- */

/**
 * A directory list of :class:`Item` entities in the Sidebar
 * @type {SidebarDirectory}
 */
class ItemDirectory extends SidebarDirectory {
	static get entity() {
		return 'Item';
	}

	static get collection() {
		return game.items;
	}

	/* -------------------------------------------- */

	/**
	 * Activate event listeners triggered within the Item directory HTML
	 */
	activateListeners(html) {
		super.activateListeners(html);

		// All users may drag items from the directory
		html.find('li.item').each((i, li) => {
			li.setAttribute('draggable', true);
			li.addEventListener(
				'dragstart',
				ev => this._onDragStart(ev),
				false
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * Extend the default set of options provided by SidebarDirectory._getEntryContextOptions
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return [
			{
				name: 'ITEM.ViewArt',
				icon: '<i class="fas fa-image"></i>',
				condition: li => {
					const item = game.items.get(li.data('entityId'));
					return item.data.img !== CONST.DEFAULT_TOKEN;
				},
				callback: li => {
					const item = game.items.get(li.data('entityId'));
					new ImagePopout(item.data.img, {
						title: item.name,
						shareable: true,
						entity: { type: 'Item', id: item.id },
					}).render(true);
				},
			},
		].concat(options);
	}
}

/**
 * A directory list of JournalEntry entities in the Sidebar
 * @type {SidebarDirectory}
 */
class JournalDirectory extends SidebarDirectory {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'journal';
		options.template = 'templates/sidebar/journal-directory.html';
		return options;
	}

	/* -------------------------------------------- */

	static get entity() {
		return 'JournalEntry';
	}

	/* -------------------------------------------- */

	static get collection() {
		return game.journal;
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * Extend the default set of options provided by SidebarDirectory._getEntryContextOptions
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		const options = super._getEntryContextOptions();
		return options.concat([
			{
				name: 'SIDEBAR.JumpPin',
				icon: '<i class="fas fa-crosshairs"></i>',
				condition: li => {
					const entry = game.journal.get(li.data('entity-id'));
					return !!entry.sceneNote;
				},
				callback: li => {
					const entry = game.journal.get(li.data('entity-id'));
					entry.panToNote();
				},
			},
		]);
	}
}

/**
 * A directory list of Macro entities. Unlike other directories, this app is only rendered in pop-out mode.
 * @extends {SidebarDirectory}
 *
 * @see {@link Macros}        The Collection of Macro Entities
 * @see {@link Macro}         The Macro Entity
 * @see {@link MacroConfig}   The Macro Configuration Sheet
 */
class MacroDirectory extends SidebarDirectory {
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			id: 'macros',
			template: 'templates/sidebar/macro-directory.html',
			canDrag: true,
			height: 680,
		});
	}

	/* -------------------------------------------- */

	/** @override */
	static get entity() {
		return 'Macro';
	}

	/* -------------------------------------------- */

	/** @override */
	static get collection() {
		return game.macros;
	}

	/* -------------------------------------------- */

	/** @override */
	async _render(...args) {
		if (this._popout) return this._popout.render();
		await Application.prototype._render.call(this, ...args);
		return this;
	}

	/* -------------------------------------------- */

	/** @override */
	async _onCreate(event) {
		event.preventDefault();
		const macro = await Macro.create(
			{ name: 'New Macro', type: 'chat', scope: 'global' },
			{ temporary: true }
		);
		macro.sheet.render(true);
	}
}

/**
 * A directory listing of audio playlists
 * @extends {SidebarDirectory}
 */
class PlaylistDirectory extends SidebarDirectory {
	constructor(options) {
		super(options);

		/**
		 * Track the playlist IDs which are currently expanded in their display
		 * @type {Set}
		 */
		this._expanded = new Set(this.playing.map(p => p._id));
	}

	/* -------------------------------------------- */

	/** @override */
	static get defaultOptions() {
		return mergeObject(super.defaultOptions, {
			dragItemSelector: '.playlist-name',
			renderUpdateKeys: ['name', 'playing', 'mode'],
		});
	}

	/* -------------------------------------------- */

	/** @override */
	static get entity() {
		return 'Playlist';
	}

	/* -------------------------------------------- */

	/** @override */
	static get collection() {
		return game.playlists;
	}

	/* -------------------------------------------- */

	/**
	 * Return an Array of the Playlist entities which are currently playing
	 * @return {Array}
	 */
	get playing() {
		return this.entities.filter(
			p => p.data.playing || p.data.sounds.some(s => s.playing)
		);
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Prepare the data used to render the AudioList application
	 * @return {Object}
	 */
	getData() {
		// Reduce the set of playlists to only ones that are visible
		let isGM = game.user.isGM;
		let visible = game.playlists.entities.filter(
			p => isGM || p.sounds.some(s => s.playing)
		);
		let playlists = visible.map(p => duplicate(p.data));

		// Configure display for each playlist
		for (let p of playlists) {
			p.modeIcon = this._getModeIcon(p.mode);
			p.modeTooltip = this._getModeTooltip(p.mode);
			p.disabled = p.mode === CONST.PLAYLIST_MODES.DISABLED;
			p.controlCSS = isGM && !p.disabled ? '' : 'disabled';
			p.expanded = this._expanded.has(p._id);

			// Reduce the visible sounds to those currently playing
			p.sounds = p.sounds
				.filter(s => s.playing || isGM)
				.map(s => {
					s.lvolume = AudioHelper.volumeToInput(s.volume);
					s.controlCSS = isGM ? '' : 'disabled';
					return s;
				});
		}

		// Return Playlist data for rendering
		return {
			user: game.user,
			isGM: isGM,
			entities: playlists,
			playlistModifier: AudioHelper.volumeToInput(
				game.settings.get('core', 'globalPlaylistVolume')
			),
			ambientModifier: AudioHelper.volumeToInput(
				game.settings.get('core', 'globalAmbientVolume')
			),
			interfaceModifier: AudioHelper.volumeToInput(
				game.settings.get('core', 'globalInterfaceVolume')
			),
		};
	}

	/* -------------------------------------------- */

	/**
	 * Given a constant playback mode, provide the FontAwesome icon used to display it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeIcon(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: '<i class="fas fa-ban"></i>',
			[CONST.PLAYLIST_MODES.SEQUENTIAL]:
				'<i class="far fa-arrow-alt-circle-right"></i>',
			[CONST.PLAYLIST_MODES.SHUFFLE]: '<i class="fas fa-random"></i>',
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]:
				'<i class="fas fa-compress-arrows-alt"></i>',
		}[mode];
	}

	/* -------------------------------------------- */

	/**
	 * Given a constant playback mode, provide the string tooltip used to describe it
	 * @param {number} mode
	 * @return {string}
	 * @private
	 */
	_getModeTooltip(mode) {
		return {
			[CONST.PLAYLIST_MODES.DISABLED]: game.i18n.localize(
				'PLAYLIST.ModeDisabled'
			),
			[CONST.PLAYLIST_MODES.SEQUENTIAL]: game.i18n.localize(
				'PLAYLIST.ModeSequential'
			),
			[CONST.PLAYLIST_MODES.SHUFFLE]: game.i18n.localize(
				'PLAYLIST.ModeShuffle'
			),
			[CONST.PLAYLIST_MODES.SIMULTANEOUS]: game.i18n.localize(
				'PLAYLIST.ModeSimultaneous'
			),
		}[mode];
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers                */
	/* -------------------------------------------- */

	/** @override */
	activateListeners(html) {
		super.activateListeners(html);

		// Global volume sliders
		html.find('.global-volume').change(event =>
			this._onGlobalVolume(event)
		);

		// Control Track Volume
		html.find('.sound-volume').change(event => this._onSoundVolume(event));

		// Collapse/Expand Playlist
		html.find('.playlist-name').click(event =>
			this._onPlaylistCollapse(event)
		);

		// All options below require a GM user
		if (!game.user.isGM) return;

		// Playlist Control Events
		html.on('click', 'a.sound-control', event => {
			event.preventDefault();
			let btn = event.currentTarget,
				action = btn.dataset.action;
			if (!action || btn.classList.contains('disabled')) return;

			// Delegate to Playlist and Sound control handlers
			switch (action) {
				case 'playlist-add':
					this._onPlaylistAddTrack(event);
					break;
				case 'playlist-delete':
					this._onPlaylistDelete(event);
					break;
				case 'playlist-edit':
					this._onPlaylistEdit(event);
					break;
				case 'playlist-mode':
					this._onPlaylistToggleMode(event);
					break;
				case 'playlist-play':
				case 'playlist-stop':
					this._onPlaylistPlay(event, action === 'playlist-play');
					break;
				case 'sound-delete':
					this._onSoundDelete(event);
					break;
				case 'sound-edit':
					this._onSoundEdit(event);
					break;
				case 'sound-play':
				case 'sound-stop':
					this._onSoundPlay(event, action === 'sound-play');
					break;
				case 'sound-repeat':
					this._onSoundToggleMode(event);
					break;
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle global volume change for the playlist sidebar
	 * @private
	 */
	_onGlobalVolume(event) {
		event.preventDefault();
		let slider = event.currentTarget,
			volume = AudioHelper.inputToVolume(slider.value);
		game.settings.set('core', slider.name, volume);
	}

	/* -------------------------------------------- */

	/**
	 * Handle new Playlist creation request
	 * TODO: I should replace this with a real ApplicationForm subclass
	 * @private
	 */
	_onCreate(event) {
		event.preventDefault();
		renderTemplate('templates/playlist/create-playlist.html', {}).then(
			dlg => {
				new Dialog({
					title: `Create New Playlist`,
					content: dlg,
					buttons: {
						create: {
							icon: '<i class="fas fa-check"></i>',
							label: 'Create Playlist',
							callback: dlg => {
								const form = dlg.find('#playlist-create'),
									data = validateForm(form[0]);
								Playlist.create(data);
							},
						},
					},
				}).render(true);
			}
		);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist collapse toggle
	 * @private
	 */
	_onPlaylistCollapse(event) {
		event.preventDefault();
		let li = $(event.currentTarget).parents('.playlist'),
			expanded = this._expanded.has(li[0].dataset.entityId);
		this._collapse(li, expanded);
	}

	/* -------------------------------------------- */

	/**
	 * Helper method to render the expansion or collapse of playlists
	 * @param {HTMLElement} li
	 * @param {boolean} collapse
	 * @param {number} speed
	 * @private
	 */
	_collapse(li, collapse, speed = 250) {
		li = $(li);
		let playlistId = li[0].dataset.entityId,
			ol = li.children('.playlist-sounds'),
			icon = li.find('.playlist-name i.fa');

		// Collapse the Playlist
		if (collapse) {
			ol.slideUp(speed, () => {
				li.addClass('collapsed');
				icon.removeClass('fa-angle-down').addClass('fa-angle-up');
				this._expanded.delete(playlistId);
			});
		}

		// Expand the Playlist
		else {
			ol.slideDown(speed, () => {
				li.removeClass('collapsed');
				icon.removeClass('fa-angle-up').addClass('fa-angle-down');
				this._expanded.add(playlistId);
			});
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist edit action
	 * @private
	 */
	_onPlaylistEdit(event) {
		let li = $(event.currentTarget).parents('.playlist'),
			playlist = game.playlists.get(li[0].dataset.entityId),
			config = new PlaylistConfig(playlist);
		this._collapse(li, false);
		config.render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist deletion requests
	 * Confirm the deletion with a yes/no dialog prompt
	 * @private
	 */
	_onPlaylistDelete(event) {
		let playlistId = $(event.currentTarget)
				.parents('.playlist')
				.attr('data-entity-id'),
			playlist = game.playlists.get(playlistId);
		new Dialog({
			title: `Delete ${playlist.name}`,
			content:
				'<h3>Are you sure?</h3><p>This Playlist and its Tracks will be deleted.</p>',
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: 'Delete',
					callback: () => {
						playlist.stopAll();
						playlist.delete();
					},
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: 'Cancel',
				},
			},
			default: 'yes',
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist track addition request
	 * @private
	 */
	_onPlaylistAddTrack(event) {
		const li = $(event.currentTarget).parents('.playlist');
		const playlist = game.playlists.get(li.data('entityId'));
		this._collapse(li, false);
		new PlaylistSoundConfig(
			playlist,
			{},
			{ top: li[0].offsetTop - 30, left: window.innerWidth - 670 }
		).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist playback state changes
	 * @private
	 */
	_onPlaylistPlay(event, playing) {
		// Get the target playlist
		const playlistId = event.currentTarget.closest('.playlist').dataset
			.entityId;
		const playlist = game.playlists.get(playlistId);

		// Play or stop the playlist
		if (playing) {
			this._expanded.add(playlistId);
			playlist.playAll();
		} else {
			this._expanded.delete(playlistId);
			playlist.stopAll();
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle cycling the playback mode for a Playlist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onPlaylistToggleMode(event) {
		const li = event.currentTarget.closest('.playlist');
		const playlist = game.playlists.get(li.dataset.entityId);
		playlist.cycleMode();
	}

	/* -------------------------------------------- */

	/**
	 * Handle editing a Sound within a PLaylist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundEdit(event) {
		const li = event.currentTarget.closest('.sound');
		const ol = li.closest('.playlist');
		const playlist = game.playlists.get(ol.dataset.entityId);
		const sound = playlist.getEmbeddedEntity(
			'PlaylistSound',
			li.dataset.soundId
		);
		new PlaylistSoundConfig(playlist, sound, {
			top: li.offsetTop - 30,
			left: window.innerWidth - 670,
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Modify the playback state of a Sound within a Playlist
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundPlay(event, playing) {
		const li = event.currentTarget.closest('.sound');
		const ol = li.closest('.playlist');
		const playlist = game.playlists.get(ol.dataset.entityId);
		playlist.updateEmbeddedEntity('PlaylistSound', {
			_id: li.dataset.soundId,
			playing: playing,
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle volume adjustments to sounds within a Playlist
	 * @param {Event} event   The initial change event
	 * @private
	 */
	_onSoundVolume(event) {
		event.preventDefault();
		const slider = event.currentTarget;
		const li = slider.closest('.sound');
		const ol = li.closest('.playlist');
		const playlist = game.playlists.get(ol.dataset.entityId);

		// Only push the update if the user is a GM
		const volume = AudioHelper.inputToVolume(slider.value);
		if (game.user.isGM)
			playlist.updateEmbeddedEntity('PlaylistSound', {
				_id: li.dataset.soundId,
				volume: volume,
			});
		// Otherwise simply apply a local override
		else {
			let sound = playlist.audio[li.dataset.soundId];
			if (!sound.howl) return;
			sound.howl.volume(volume, sound._id);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle changes to the sound playback mode
	 * @param {Event} event   The initial click event
	 * @private
	 */
	_onSoundToggleMode(event) {
		event.preventDefault();
		const btn = event.currentTarget;
		const playlistId = btn.closest('.playlist').dataset.entityId;
		const soundId = btn.closest('.sound').dataset.soundId;
		const playlist = game.playlists.get(playlistId);
		playlist.updateEmbeddedEntity('PlaylistSound', {
			_id: soundId,
			repeat: btn.classList.contains('inactive'),
		});
	}

	/* -------------------------------------------- */

	/**
	 * Handle Playlist track deletion request
	 * @private
	 */
	_onSoundDelete(event) {
		const li = event.currentTarget.closest('.sound');
		const ol = li.closest('.playlist');
		const playlist = game.playlists.get(ol.dataset.entityId);
		const sound = playlist.getEmbeddedEntity(
			'PlaylistSound',
			li.dataset.soundId
		);

		// Render a confirmation dialog
		new Dialog({
			title: `Delete Sound: ${sound.name}`,
			content: `<p class="notes">This Sound will be deleted from ${playlist.name}.</p>`,
			buttons: {
				yes: {
					icon: '<i class="fas fa-trash"></i>',
					label: 'Delete',
					callback: () =>
						playlist.deleteEmbeddedEntity(
							'PlaylistSound',
							sound._id
						),
				},
				no: {
					icon: '<i class="fas fa-times"></i>',
					label: 'Cancel',
				},
			},
			default: 'yes',
		}).render(true);
	}

	/* -------------------------------------------- */

	/**
	 * Handle right click context-menu options on a Playlist or a Sound
	 * @private
	 */
	_contextMenu(html) {
		const entryOptions = this._getSoundContextOptions();
		Hooks.call(
			`get${this.constructor.name}SoundContext`,
			html,
			entryOptions
		);
		new ContextMenu(html, '.playlist .sound', entryOptions);
	}

	/* -------------------------------------------- */

	/**
	 * Get context menu options for individual sound effects
	 * @return {Object}   The context options for each sound
	 * @private
	 */
	_getSoundContextOptions() {
		return [
			{
				name: 'PLAYLIST.SoundPreload',
				icon: '<i class="fas fa-download"></i>',
				callback: h => {
					const soundId = h.data('sound-id');
					const playlist = game.playlists.get(
						h.parents('.playlist').data('entity-id')
					);
					const sound = playlist.getEmbeddedEntity(
						'PlaylistSound',
						soundId
					);
					game.audio.preload(sound);
				},
			},
		];
	}
}
/**
 * A directory listing of active game scenes
 * @type {SidebarDirectory}
 */
class SceneDirectory extends SidebarDirectory {
	static get entity() {
		return 'Scene';
	}

	/* -------------------------------------------- */

	static get collection() {
		return game.scenes;
	}

	/* -------------------------------------------- */

	/**
	 * Override the logic used to create a new Scene
	 * Ensure that newly created scenes begin as Active if no other scene is currently activated
	 * @param event
	 * @private
	 */
	_onCreate(event) {
		let noneActive = !game.scenes.active;
		return Scene.create({
			name: 'New Scene',
			active: noneActive,
			navigation: true,
		}).then(scene => {
			if (noneActive) canvas.draw();
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the set of ContextMenu options which should be used for Folders in a SidebarDirectory
	 * Extend the default set of options provided by SidebarDirectory._getEntryContextOptions
	 * @return {Array}   The Array of context options passed to the ContextMenu instance
	 * @private
	 */
	_getEntryContextOptions() {
		let options = super._getEntryContextOptions();
		options = [
			{
				name: 'SIDEBAR.SceneConfig',
				icon: '<i class="fas fa-cogs"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data('entityId'));
					scene.sheet.render(true);
				},
			},
			{
				name: 'SIDEBAR.SceneNotes',
				icon: '<i class="fas fa-scroll"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data('entityId'));
					scene.notes.render(true);
				},
			},
			{
				name: 'SIDEBAR.SceneActivate',
				icon: '<i class="fas fa-bullseye"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data('entityId'));
					scene.activate();
				},
			},
			{
				name: 'SIDEBAR.SceneNav',
				icon: '<i class="fas fa-compass"></i>',
				callback: li => {
					const scene = game.scenes.get(li.data('entityId'));
					scene.update({
						active: false,
						navigation: !scene.data.navigation,
					});
				},
			},
		].concat(options);

		// Remove the permissions entry
		let idx = options.findIndex(o => o.name === 'SIDEBAR.Permissions');
		options.splice(idx, 1);
		return options;
	}
}

/**
 * A sidebar tab for providing help messages and settings configurations
 * @type {SidebarTab}
 */
class Settings extends SidebarTab {
	/**
	 * Assign the default options which are supported by this Application
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'settings';
		options.template = 'templates/sidebar/settings.html';
		options.title = 'Settings';
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Prepare the data used to render the Settings application
	 * @return {Object}
	 */
	getData() {
		return {
			user: game.user,
			system: game.system,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Activate HTML listeners which apply to the Settings sidebar tab
	 * @param html
	 */
	activateListeners(html) {
		html.find('button[data-action]').click(
			this._onSettingsButton.bind(this)
		);
	}

	/* -------------------------------------------- */

	/**
	 * Delegate different actions for different settings buttons
	 * @param event
	 * @private
	 */
	_onSettingsButton(event) {
		event.preventDefault();
		let button = event.target;
		switch (button.dataset.action) {
			case 'configure':
				game.settings.sheet.render(true);
				break;
			case 'av':
				game.webrtc.config.render(true);
				break;
			case 'modules':
				new ModuleManagement().render(true);
				break;
			case 'players':
				return (window.location.href = ROUTE_PREFIX + '/players');
			case 'setup':
				return game.shutDown();
			case 'controls':
				new ControlsReference().render(true);
				break;
			case 'docs':
				new Documentation('http://foundryvtt.com', {
					title: 'Foundry VTT Documentation',
				}).render(true);
				break;
			case 'wiki':
				new Documentation('https://foundry-vtt-community.github.io/', {
					title: 'Foundry VTT Community Wiki',
				}).render(true);
				break;
			case 'invitations':
				new InvitationLinks().render(true);
				break;
			case 'logout':
				return (window.location.href = ROUTE_PREFIX + '/join');
		}
	}
}

/* -------------------------------------------- */

/**
 * A simple window application which shows the built documentation pages within an iframe
 * @type {Application}
 */
class Documentation extends Application {
	constructor(url = 'http://foundryvtt.com', options) {
		super(options);
		this.url = url;
	}

	/* -------------------------------------------- */

	/**
	 * Assign the default options which are supported by this Application
	 */
	static get defaultOptions() {
		const options = super.defaultOptions;

		// Default positioning
		let h = window.innerHeight * 0.9,
			w = Math.min(window.innerWidth * 0.9, 1200);
		options.height = h;
		options.width = w;
		options.top = (window.innerHeight - h) / 2;
		options.left = (window.innerWidth - w) / 2;
		options.id = 'documentation';
		options.template = 'templates/apps/documentation.html';
		return options;
	}

	/* -------------------------------------------- */

	getData() {
		return {
			src: this.url,
		};
	}

	/* -------------------------------------------- */

	close() {
		this.element.find('#docs').remove();
		super.close();
	}
}

/* -------------------------------------------- */

/**
 * A directory list of RollTable entities in the Sidebar
 * @type {SidebarDirectory}
 */
class RollTableDirectory extends SidebarDirectory {
	static get defaultOptions() {
		const options = super.defaultOptions;
		options.id = 'tables';
		options.template = 'templates/sidebar/roll-table-directory.html';
		options.title = 'Rollable Tables Directory';
		return options;
	}

	/* -------------------------------------------- */

	/**
	 * Reference named Entity class which this directory lists
	 * @return {String}
	 */
	static get entity() {
		return 'RollTable';
	}

	/* -------------------------------------------- */

	/**
	 * Reference the Collection of Entity instances which this directory lists
	 * @return {RollTables}
	 */
	static get collection() {
		return game.tables;
	}
}

/**
 * A single Mouse Cursor
 * @type {PIXI.Container}
 */
class Cursor extends PIXI.Container {
	constructor(user) {
		super();
		this.target = { x: 0, y: 0 };
		this.draw(user);

		// Register and add animation
		canvas.app.ticker.add(this._animate, this);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the user's cursor as a small dot with their user name attached as text
	 */
	draw(user) {
		// Cursor dot
		let d = this.addChild(new PIXI.Graphics()),
			color = user.data.color.replace('#', '0x') || 0x42f4e2;
		d.beginFill(color, 0.35)
			.lineStyle(1, 0x000000, 0.5)
			.drawCircle(0, 0, 6);

		// Player name
		let n = this.addChild(
			new PIXI.Text(
				user.name,
				new PIXI.TextStyle({
					fontFamily: 'Signika',
					fontSize: 14,
					fill: '#DDDDDD',
					stroke: '#000000',
					strokeThickness: 1,
					dropShadow: true,
					dropShadowColor: '#000000',
					dropShadowBlur: 4,
					dropShadowAngle: 0,
					dropShadowDistance: 0,
					align: 'center',
				})
			)
		);
		n.x -= n.width / 2;
		n.y += 10;
	}

	/* -------------------------------------------- */

	/**
	 * Move an existing cursor to a new position smoothly along the animation loop
	 */
	_animate() {
		let dy = this.target.y - this.y,
			dx = this.target.x - this.x;
		if (Math.abs(dx) + Math.abs(dy) < 10) return;
		this.x += dx / 10;
		this.y += dy / 10;
	}

	/* -------------------------------------------- */

	/**
	 * Remove the cursor update from the animation loop and destroy the container.
	 * @param options {Object}      Additional options passed to the parent ``PIXI.Container.destroy()`` method
	 */
	destroy(options) {
		canvas.app.ticker.remove(this._animate, this);
		super.destroy(options);
	}
}

/**
 * An icon representing a Door Control
 * @type {PIXI.Container}
 */
class DoorControl extends PIXI.Container {
	constructor(wall) {
		super();
		this.wall = wall;
		this.wall.doorControl = this;
	}

	/* -------------------------------------------- */

	draw() {
		for (let i = 0; i < this.children.length; i++)
			this.children[i].destroy();

		// Background
		let bg = new PIXI.Graphics();
		bg.beginFill(0x000000, 0.1)
			.drawRoundedRect(-2, -2, 44, 44, 5)
			.endFill();
		this.bg = this.addChild(bg);

		// Border
		this.border = this.addChild(new PIXI.Graphics());
		this.border
			.lineStyle(1, 0xff5500, 0.8)
			.drawRoundedRect(-2, -2, 44, 44, 5)
			.endFill();
		this.border.visible = false;

		// Icon
		this.drawIcon();

		// Add control interactivity
		this.interactive = true;
		this.interactiveChildren = false;
		this.hitArea = new PIXI.Rectangle(-2, -2, 44, 44);

		// Set position
		this.reposition();
		this.alpha = 1.0;

		// Activate listeners
		this.on('mouseover', this._onMouseOver)
			.on('mouseout', this._onMouseOut)
			.on('mousedown', this._onMouseDown)
			.on('rightdown', this._onRightDown);
	}

	/* -------------------------------------------- */

	drawIcon() {
		if (this.icon) this.icon.destroy();
		let tex = new PIXI.Texture.from(this.texture);
		this.icon = this.addChild(new PIXI.Sprite(tex));
		this.icon.width = this.icon.height = 40;
		this.icon.alpha = 0.5;
	}

	/* -------------------------------------------- */

	reposition() {
		let pos = this.wall.midpoint.map(p => p - 20);
		this.position.set(...pos);
	}

	/* -------------------------------------------- */

	/**
	 * Get the icon texture to use for the Door Control icon based on the door state
	 * @type {string}
	 */
	get texture() {
		let s = this.wall.data.ds,
			ds = CONST.WALL_DOOR_STATES;
		if (!game.user.isGM && s === ds.LOCKED) s = ds.CLOSED;
		return {
			[ds.LOCKED]: 'icons/svg/padlock.svg',
			[ds.CLOSED]: 'icons/svg/door-steel.svg',
			[ds.OPEN]: 'icons/svg/door-exit.svg',
		}[s || ds.CLOSED];
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether the DoorControl is visible to the calling user's perspective.
	 * @type {Boolean}
	 */
	get isVisible() {
		// Under some circumstances, controls are always visible
		if (game.user.isGM && !canvas.sight.tokens.vision.length) return true;

		// Check that there is are LOS polygons to test
		let los = canvas.sight.los;
		if (canvas.sight && (los.tokens.length || los.lights.length)) {
			let fov = canvas.sight.fov;
			let [x, y] = this.wall.midpoint;

			// Iterate over positional offsets
			let offsets = [
				[0, 0],
				[-2, -2],
				[2, -2],
				[2, 2],
				[-2, 2],
			];
			return offsets.some(o => {
				let p = { x: x + o[0], y: y + o[1] };

				// The point must fall within a LOS polygon
				let hasLOS = los.tokens.some(
					v =>
						v.contains(p.x, p.y) ||
						los.lights.some(v => v.contains(p.x, p.y))
				);
				if (!hasLOS) return false;
				// The center must also fall within some FOV
				else
					return (
						fov.tokens.some(v => v.contains(p.x, p.y)) ||
						fov.lights.some(v => v.contains(p.x, p.y))
					);
			});
		}
	}

	/* -------------------------------------------- */

	_onMouseOver(ev) {
		ev.stopPropagation();
		let canControl =
				game.user.isGM || game.settings.get('core', 'playerDoors'),
			blockPaused = game.paused && !game.user.isGM;
		if (!canControl || blockPaused) return false;
		this.border.visible = true;
		this.icon.alpha = 1.0;
		canvas.walls._hover = this.wall;
	}

	/* -------------------------------------------- */

	_onMouseOut(ev) {
		ev.stopPropagation();
		if (game.paused && !game.user.isGM) return false;
		this.border.visible = false;
		this.icon.alpha = 0.5;
		canvas.walls._hover = null;
	}

	/* -------------------------------------------- */

	/**
	 * Handle left mouse down events on the door control icon.
	 * This should only toggle between the OPEN and CLOSED states.
	 * @param event
	 * @private
	 */
	_onMouseDown(event) {
		event.stopPropagation();
		let state = this.wall.data.ds,
			states = CONST.WALL_DOOR_STATES;

		// Determine whether the player can control the door at this time
		let canControl =
				game.user.isGM || game.settings.get('core', 'playerDoors'),
			blockPaused = game.paused && !game.user.isGM;
		if (!canControl || blockPaused) return false;

		// Play an audio cue for locked doors
		if (state === states.LOCKED) {
			AudioHelper.play({ src: CONFIG.sounds.lock });
			return false;
		}

		// Toggle between OPEN and CLOSED states
		state = state === states.CLOSED ? states.OPEN : states.CLOSED;
		this.wall.update(canvas.scene._id, { ds: state });
	}

	/* -------------------------------------------- */

	/**
	 * Handle right mouse down events on the door control icon
	 * This should toggle whether the door is LOCKED or CLOSED
	 * @param event
	 * @private
	 */
	_onRightDown(event) {
		event.stopPropagation();
		if (!game.user.isGM) return;
		let state = this.wall.data.ds,
			states = CONST.WALL_DOOR_STATES;
		if (state === states.OPEN) return;
		state = state === states.LOCKED ? states.CLOSED : states.LOCKED;
		this.wall.update(canvas.scene._id, { ds: state });
	}
}

/**
 * A CanvasLayer for displaying UI controls which are overlayed on top of other layers.
 *
 * We track three types of events:
 * 1) Cursor movement
 * 2) Ruler measurement
 * 3) Map pings
 */
class ControlsLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * Cursor position indicators
		 * @type {PIXI.Container}
		 */
		this.cursors = null;

		/**
		 * A mapping of user IDs to Cursor instances for quick access
		 * @type {Object}
		 */
		this._cursors = {};

		/**
		 * Door control icons
		 */
		this.doors = null;

		/**
		 * Status effect icons
		 */
		this.effects = null;

		/**
		 * Ruler tools, one per connected user
		 * @type {PIXI.Container}
		 */
		this.rulers = null;

		/**
		 * A convenience mapping of user IDs to Ruler instances for quick access
		 * @type {Object}
		 */
		this._rulers = {};

		/**
		 * Canvas selection rectangle
		 * @type {PIXI.Graphics}
		 */
		this.select = null;

		// Get the current cursor setting
		this._showCursors = game.settings.get('core', 'showCursors');
	}

	/* -------------------------------------------- */
	/*  Properties and Public Methods               */
	/* -------------------------------------------- */

	/**
	 * A convenience accessor to the Ruler for the active game user
	 * @type {Ruler}
	 */
	get ruler() {
		return this.getRulerForUser(game.user._id);
	}

	/* -------------------------------------------- */

	/**
	 * Get the Ruler display for a specific User ID
	 * @param {string} userId
	 * @return {Ruler|null}
	 */
	getRulerForUser(userId) {
		return this._rulers[userId] || null;
	}

	/* -------------------------------------------- */
	/*  Rendering                                   */
	/* -------------------------------------------- */

	/**
	 * Draw current cursor UI elements
	 */
	draw() {
		this.removeChildren().forEach(c => c.destroy({ children: true }));
		this.drawCursors();
		this.drawDoors();
		this.drawRulers();
		this.select = this.addChild(new PIXI.Graphics());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Draw the cursors container
	 */
	drawCursors() {
		if (this.cursors) {
			this.cursors.destroy({ children: true });
			this.cursors = null;
		}
		if (!this._showCursors) return;
		const cursors = new PIXI.Container();
		for (let u of game.users.entities.filter(
			u => u.active && u._id !== game.user._id
		)) {
			cursors.addChild(this.drawCursor(u));
		}
		this.cursors = this.addChild(cursors);
	}

	/* -------------------------------------------- */

	/**
	 * Draw the Door controls container
	 */
	drawDoors() {
		// Create the container
		if (this.doors) {
			this.doors.destroy({ children: true });
			this.doors = null;
		}
		const doors = new PIXI.Container();

		// Get the walls which are doors
		const walls = canvas.walls.doors.filter(
			d => game.user.isGM || d.data.door === CONST.WALL_DOOR_TYPES.DOOR
		);
		walls.forEach(d => {
			let dc = doors.addChild(new DoorControl(d));
			dc.visible = false; // Start door controls as initially not visible and reveal them later
			dc.draw();
		});
		this.doors = this.addChild(doors);

		// Toggle visibility for the set of door control icons
		this.doors.visible = !canvas.walls._active;
	}

	/* -------------------------------------------- */

	/**
	 * Draw Ruler tools
	 */
	drawRulers() {
		this.rulers = this.addChild(new PIXI.Container());
		for (let u of game.users.entities) {
			let ruler = new Ruler(u);
			this._rulers[u._id] = this.rulers.addChild(ruler);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Draw the select rectangle given an event originated within the base canvas layer
	 * @param {Object} coords   The rectangle coordinates of the form {x, y, width, height}
	 */
	drawSelect({ x, y, width, height }) {
		const s = this.select.clear();
		s.lineStyle(3, 0xff9829, 0.9).drawRect(x, y, width, height);
	}

	/* -------------------------------------------- */

	deactivate() {
		super.deactivate();
		this.interactiveChildren = true;
	}

	/* -------------------------------------------- */
	/*  Socket Listeners and Handlers               */
	/* -------------------------------------------- */

	/**
	 * Listen for new cursor data sent from the server.
	 * Cursor data sent by the server is pre-validated, so no further checks are required here.
	 *
	 * @param socket {Socket}       The open socket client.
	 */
	static socketListeners(socket) {
		socket.on('cursor', (userId, cursorData) => {
			// Get the user
			let user = game.users.get(userId);

			// Update cursor position
			if (cursorData.hasOwnProperty('position')) {
				canvas.controls.updateCursor(user, cursorData.position);
			}

			// Update Ruler measurement
			if (cursorData.hasOwnProperty('ruler')) {
				canvas.controls.updateRuler(user, cursorData.ruler);
			}

			// Update Token targets
			if (cursorData.hasOwnProperty('targets')) {
				const current = Array.from(user.targets);
				if (cursorData.targets.equals(current.map(t => t.id))) return;

				// Update in the current scene
				if (user.data.scene === canvas.scene._id) {
					const toRemove = current.filter(
						t => !cursorData.targets.includes(t.id)
					);
					const toAdd = cursorData.targets
						.filter(t => !toRemove.includes(t))
						.map(id => canvas.tokens.get(id));
					toRemove.forEach(t =>
						t.setTarget(false, { user, releaseOthers: false })
					);
					toAdd.forEach(t =>
						t.setTarget(true, { user, releaseOthers: false })
					);
				}

				// Otherwise remove any current Token targets
				else
					current.forEach(t =>
						t.setTarget(false, { user, releaseOthers: false })
					);
			}
		});
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
  /* -------------------------------------------- */

	/**
	 * Event handler forwarded by ``Canvas._onMouseMove``
	 * @param {PIXI.interaction.InteractionEvent} event
	 */
	_onMoveCursor(event, position) {
		// Construct cursor data
		const cursorData = {
			position: position,
			ruler: this.ruler._state > 0 ? this.ruler.toJSON() : null,
			targets: Array.from(game.user.targets).map(t => t.id),
		};

		// Emit the cursor update event
		game.socket.emit('cursor', game.user._id, cursorData);
	}

	/* -------------------------------------------- */

	/**
	 * Handle changing of the display cursors game setting
	 * @private
	 */
	_onChangeCursorSetting(enabled) {
		this._showCursors = enabled;
		this.drawCursors();
	}

	/* -------------------------------------------- */
	/*  Methods
  /* -------------------------------------------- */

	/**
	 * Create and draw the Cursor object for a given User
	 * @param user {User}   The User entity for whom to draw the cursor Container
	 */
	drawCursor(user) {
		let c = this._cursors[user._id];
		if (c) {
			c.destroy({ children: true });
			delete this._cursors[user._id];
		}
		c = new Cursor(user);
		this._cursors[user._id] = c;
		return c;
	}

	/* -------------------------------------------- */

	/**
	 * Update the cursor when the user moves to a new position
	 */
	updateCursor(user, position) {
		if (!this._showCursors) return;
		if (user === game.user) return;

		// Get Cursor element
		let cursor = this._cursors[user._id];
		cursor = cursor || this.cursors.addChild(this.drawCursor(user));

		// Ignore inactive cursors
		if (position === null || user.data.scene !== canvas.scene._id) {
			if (cursor) cursor.visible = false;
			return;
		}

		// Show the cursor in its currently tracked position
		cursor.visible = true;
		cursor.target = { x: position.x || 0, y: position.y || 0 };
	}

	/* -------------------------------------------- */

	/**
	 * Update display of an active Ruler object for a user given provided data
	 * @param {User} user
	 * @param {Object} rulerData
	 */
	updateRuler(user, rulerData) {
		let ruler = this.getRulerForUser(user.id);
		if (!ruler) return;
		if (rulerData === null) ruler.clear();
		else ruler.update(rulerData);
	}
}

/**
 * The Ruler - used to measure distances and trigger movements
 * @param {User}  The User for whom to construct the Ruler instance
 * @type {PIXI.Container}
 */
class Ruler extends PIXI.Container {
	constructor(user, { color = null } = {}) {
		super();
		user = user || game.user;

		/**
		 * Record the User which this Ruler references
		 * @type {User}
		 */
		this.user = user;

		/**
		 * The ruler name - used to differentiate between players
		 * @type {String}
		 */
		this.name = `Ruler.${user._id}`;

		/**
		 * The ruler color - by default the color of the active user
		 * @type {number|null}
		 */
		this.color =
			color || colorStringToHex(this.user.data.color) || 0x42f4e2;

		/**
		 * This Array tracks individual waypoints along the ruler's measured path.
		 * The first waypoint is always the origin of the route.
		 * @type {Array.<PIXI.Point>}
		 */
		this.waypoints = [];

		/**
		 * The current destination point at the end of the measurement
		 * @type {PIXI.Point}
		 */
		this.destination = null;

		/**
		 * The Ruler element is a Graphics instance which draws the line and points of the measured path
		 * @type {PIXI.Graphics}
		 */
		this.ruler = this.addChild(new PIXI.Graphics());

		/**
		 * The Labels element is a Container of Text elements which label the measured path
		 * @type {PIXI.Container}
		 */
		this.labels = this.addChild(new PIXI.Container());

		/**
		 * Track the current measurement state
		 * @type {Number}
		 */
		this._state = 0;

		// Create a grid HighlightLayer for this Ruler
		canvas.grid.addHighlightLayer(this.name);
	}

	/* -------------------------------------------- */

	/**
	 * Is the Ruler being actively used to measure distance?
	 * @return {Boolean}
	 */
	get active() {
		return this.waypoints.length > 0;
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two points and render the ruler UI to illustrate it
	 * @param destination {PIXI.Point}  The destination point to which to measure
	 */
	measure(destination, { gridSpaces = true } = {}) {
		const dest = new PIXI.Point(
				...canvas.grid.getCenter(destination.x, destination.y)
			),
			waypoints = this.waypoints.concat([dest]),
			r = this.ruler;
		this.destination = dest;

		// Get grid highlight layer
		const hlt = canvas.grid.highlightLayers[this.name];
		hlt.clear();
		r.clear();

		// Track some measurement data
		let isMulti = waypoints.length > 2;
		let totalDistance = 0;

		// Iterate over waypoints
		for (let [i, dest] of waypoints.slice(1).entries()) {
			let origin = waypoints[i],
				label = this.labels.children[i];

			// Compute distance between the two points and bail out if we have not measured far enough yet
			let ray = new Ray(origin, dest);
			if (ray.distance < 0.2 * canvas.grid.size) {
				if (label) label.visible = false;
				continue;
			}

			// Compute additional Ray data
			let distance =
				Math.round(
					canvas.grid.measureDistance(ray.A, ray.B, { gridSpaces }) *
						100
				) / 100;
			totalDistance += distance;

			// Draw line segment
			r.lineStyle(6, 0x000000, 0.5)
				.moveTo(origin.x, origin.y)
				.lineTo(dest.x, dest.y)
				.lineStyle(4, this.color, 0.25)
				.moveTo(origin.x, origin.y)
				.lineTo(dest.x, dest.y);

			// Draw the distance label just after the endpoint of the segment
			if (label) {
				let isLast = i === waypoints.length - 2;
				label.text = this._getSegmentLabel(
					ray,
					distance,
					totalDistance,
					isMulti && isLast
				);
				label.alpha = isLast ? 1.0 : 0.5;
				label.visible = true;
				let labelPosition = ray.project(
					(ray.distance + 50) / ray.distance
				);
				label.position.set(labelPosition.x, labelPosition.y);
			}

			// Highlight grid positions
			this._highlightMeasurement(ray);
		}

		// Draw endpoints
		for (let point of waypoints) {
			r.lineStyle(2, 0x000000, 0.5)
				.beginFill(this.color, 0.25)
				.drawCircle(point.x, point.y, 8);
		}
	}

	/* -------------------------------------------- */

	/**
	 * Get the text label for a segment of the measured path
	 * @param {Ray} ray
	 * @param {number} segmentDistance
	 * @param {number} totalDistance
	 * @param {boolean} isTotal
	 * @return {string}
	 * @private
	 */
	_getSegmentLabel(ray, segmentDistance, totalDistance, isTotal) {
		const units = canvas.scene.data.gridUnits;
		let label = `${segmentDistance} ${units}`;
		if (isTotal) {
			label += ` [${Math.round(totalDistance * 100) / 100} ${units}]`;
		}
		return label;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight the measurement required to complete the move in the minimum number of discrete spaces
	 * @param {Ray} ray
	 * @private
	 */
	_highlightMeasurement(ray) {
		let nMax = Math.max(
				Math.floor(
					ray.distance /
						(1.41 * Math.min(canvas.grid.w, canvas.grid.h))
				),
				1
			),
			tMax = Array.fromRange(nMax + 1).map(t => t / nMax);

		// Track prior position
		let prior = null;

		// Iterate over ray portions
		for (let [i, t] of tMax.entries()) {
			let { x, y } = ray.project(t);

			// Get grid position
			let [x0, y0] = i === 0 ? [null, null] : prior;
			let [x1, y1] = canvas.grid.grid.getGridPositionFromPixels(x, y);
			if (x0 === x1 && y0 === y1) continue;

			// Highlight the grid position
			let [xg, yg] = canvas.grid.grid.getPixelsFromGridPosition(x1, y1);
			canvas.grid.highlightPosition(this.name, {
				x: xg,
				y: yg,
				color: this.color,
			});

			// Skip the first one
			prior = [x1, y1];
			if (i === 0) continue;

			// If the positions are not neighbors, also highlight their halfway point
			if (!canvas.grid.isNeighbor(x0, y0, x1, y1)) {
				let th = tMax[i - 1] + 0.5 / nMax;
				let { x, y } = ray.project(th);
				let [x1h, y1h] = canvas.grid.grid.getGridPositionFromPixels(
					x,
					y
				);
				let [xgh, ygh] = canvas.grid.grid.getPixelsFromGridPosition(
					x1h,
					y1h
				);
				canvas.grid.highlightPosition(this.name, {
					x: xgh,
					y: ygh,
					color: this.color,
				});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler
	 *
	 * @return {Boolean}    An indicator for whether a token was successfully moved or not. If True the event should be
	 *                      prevented from propagating further, if False it should move on to other handlers.
	 */
	async moveToken() {
		let wasPaused = game.paused;
		if (wasPaused && !game.user.isGM) return false;
		if (!this.visible || !this.destination) return false;
		const token = this._getMovementToken();
		if (!token) return;

		// Get the movement rays and check collision along each Ray
		const rays = this._getRaysFromWaypoints(
			this.waypoints,
			this.destination
		);
		let hasCollision = rays.some(r => canvas.walls.checkCollision(r));
		if (hasCollision) {
			ui.notifications.error(
				'This movement path collides with at least one wall!'
			);
			return;
		}

		// Execute the movement path
		this._state = 0;
		token._noAnimate = true;
		for (let r of rays) {
			if (!wasPaused && game.paused) break;
			let path = Ray.fromArrays(
				canvas.grid.getTopLeft(r.A.x, r.A.y),
				canvas.grid.getTopLeft(r.B.x, r.B.y)
			);
			await token.update(canvas.scene.id, path.B);
			token.position.set(path.A.x, path.A.y);
			await token.animateMovement(path);
		}
		token._noAnimate = false;

		// Once all animations are complete we can clear the ruler
		this.clear();
		game.socket.emit('cursor', game.user._id, { ruler: null });
	}

	/* -------------------------------------------- */

	/**
	 * A helper method to return an Array of Ray objects constructed from the waypoints of the measurement
	 * @param {Array} waypoints           An Array of waypoint {x, y} Objects
	 * @param {Object} destination        An optional destination point to append to the existing waypoints
	 * @return {Array.<Ray>}              An Array of Ray objects which represent the segemnts of the waypoint path
	 * @private
	 */
	_getRaysFromWaypoints(waypoints, destination) {
		if (destination) waypoints = waypoints.concat([destination]);
		return waypoints.slice(1).map((wp, i) => {
			return new Ray(waypoints[i], wp);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler
	 * @return {Token}
	 * @private
	 */
	_getMovementToken() {
		let [x0, y0] = Object.values(this.waypoints[0]);
		const tokens = new Set(canvas.tokens.controlled);
		if (!tokens.size && game.user.character) {
			const charTokens = game.user.character.getActiveTokens();
			if (charTokens.length) tokens.add(...charTokens);
		}
		if (!tokens.size) return null;
		return Array.from(tokens).find(t => {
			let pos = new PIXI.Rectangle(t.x, t.y, t.w, t.h);
			return pos.contains(x0, y0);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Clear display of the current Ruler
	 */
	clear() {
		this._state = 0;
		this.waypoints = [];
		this.ruler.clear();
		this.labels.removeChildren().forEach(c => c.destroy());
		canvas.grid.clearHighlightLayer(this.name);
	}

	/* -------------------------------------------- */
	/*  Event Listeners and Handlers
  /* -------------------------------------------- */

	/**
	 * General handler for mouse-down events which should affect the Ruler in some way
	 * This event delegates to more specialized handlers depending on where we are in the measurement workflow
	 * @param event
	 * @private
	 */
	_onMouseDown(event) {
		const oe = event.data.originalEvent;
		const isCtrl = oe.ctrlKey || oe.metaKey;
		if (this._state === 2 && isCtrl) this._onAddWaypoint(event);
		else this._onStartMeasurement(event);
	}

	/* -------------------------------------------- */

	/**
	 * General handler for mouse-move events which affect Ruler measurement
	 * This event delegates to more specialized handlers depending on where we are in the measurement workflow
	 * @param event
	 * @private
	 */
	_onMouseMove(event) {
		// Extract event data
		const mt = event._measureTime || 0;
		const { origin, destination, originalEvent } = event.data;

		// Check measurement distance
		let dx = destination.x - origin.x,
			dy = destination.y - origin.y;
		if (Math.hypot(dy, dx) >= canvas.dimensions.size / 2) {
			// Hide any existing Token HUD
			canvas.hud.token.clear();
			delete event.data.hudState;

			// Draw measurement updates
			if (Date.now() - mt > 50) {
				this.measure(destination, {
					gridSpaces: !originalEvent.shiftKey,
				});
				event._measureTime = Date.now();
				this._state = 2;
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Handle the beginning of a new Ruler measurement event
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onStartMeasurement(event) {
		this.clear();
		this._state = 1;
		this._onAddWaypoint(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the addition of a new waypoint in the Ruler measurement path
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onAddWaypoint(event) {
		let cursor = event.data.getLocalPosition(canvas.grid),
			waypoint = new PIXI.Point(
				...canvas.grid.getCenter(cursor.x, cursor.y)
			);
		this.waypoints.push(waypoint);
		this.labels.addChild(new PIXI.Text('', CONFIG.canvasTextStyle));
	}

	/* -------------------------------------------- */

	/**
	 * Handle the removal of a waypoint in the Ruler measurement path
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onCancelWaypoint(event) {
		if (this.waypoints.length > 1) {
			this.waypoints.pop();
			this.labels.removeChild(this.labels.children.pop());
			this.measure(event.data.getLocalPosition(canvas.grid), {
				gridSpaces: !event.data.originalEvent.shiftKey,
			});
		} else this._onEndMeasurement(event);
	}

	/* -------------------------------------------- */

	/**
	 * Handle the conclusion of a Ruler measurement workflow
	 * @param {PIXI.interaction.InteractionEvent} event
	 * @private
	 */
	_onEndMeasurement(event) {
		this.clear();
		game.socket.emit('cursor', game.user._id, { ruler: null });
	}

	/* -------------------------------------------- */
	/*  Saving and Loading
  /* -------------------------------------------- */

	toJSON() {
		return {
			class: 'Ruler',
			name: `Ruler.${game.user._id}`,
			waypoints: this.waypoints,
			destination: this.destination,
			_state: this._state,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Update a Ruler instance using data provided through the cursor activity socket
	 * @param {Object} data   Ruler data with which to update the display
	 */
	update(data) {
		if (data.class !== 'Ruler')
			throw new Error(
				'Unable to recreate Ruler instance from provided data'
			);

		// Populate data
		this.waypoints = data.waypoints;
		this.destination = data.destination;
		this._state = data._state;

		// Ensure labels are created
		for (
			let i = 0;
			i < this.waypoints.length - this.labels.children.length;
			i++
		) {
			this.labels.addChild(new PIXI.Text('', CONFIG.canvasTextStyle));
		}

		// Measure current distance
		if (data.destination) this.measure(data.destination);
	}
}

/**
 * I don't know what this will do yet
 */
class SpecialEffect {
	constructor(parent, options) {
		this.parent = parent;
		this.options = mergeObject(this.constructor.effectOptions, options, {
			insertKeys: false,
		});
		this.emitters = this.getParticleEmitters();

		/**
		 * Use this flag as a way to pass a stop signal into the animation frame
		 * @type {Boolean}
		 */
		this._stop = null;
	}

	/* -------------------------------------------- */

	static get label() {
		return 'Special Effect';
	}

	/* -------------------------------------------- */

	static get effectOptions() {
		return {
			density: {
				label: 'Particle Density',
				type: this.OPTION_TYPES.RANGE,
				value: 0.5,
				min: 0.1,
				max: 5,
				step: 0.1,
			},
		};
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [];
	}

	/* -------------------------------------------- */

	play(duration) {
		this._stop = null;
		for (let e of this.emitters) {
			this._startEmitter(e);
		}
	}

	/* -------------------------------------------- */

	stop() {
		this._stop = true;
		for (let e of this.emitters) {
			e.emit = false;
			e.cleanup();
		}
	}

	/* -------------------------------------------- */

	_startEmitter(emitter) {
		// Calculate the current time
		let elapsed = Date.now();

		// Update function every frame
		let update = () => {
			// Maybe stop
			if (this._stop) return;

			// Update the next frame
			requestAnimationFrame(update);

			// Track the number of elapsed seconds since the previous frame update
			let now = Date.now();
			emitter.update((now - elapsed) * 0.001);
			elapsed = now;
		};

		// Start emitting
		emitter.emit = true;
		update();
	}
}

SpecialEffect.OPTION_TYPES = {
	VALUE: 1,
	CHECKBOX: 2,
	RANGE: 3,
	SELECT: 4,
};

SpecialEffect.DEFAULT_CONFIG = {
	maxSpeed: 0,
	noRotation: false,
	blendMode: 'normal',
	emitterLifetime: -1,
	pos: {
		x: 0,
		y: 0,
	},
	spawnType: 'rect',
};
/**
 * A special full-screen weather effect which uses one Emitters to render gently falling autumn leaves
 * @type {SpecialEffect}
 */
class AutumnLeavesWeatherEffect extends SpecialEffect {
	static get label() {
		return 'Autumn Leaves';
	}

	/* -------------------------------------------- */

	static get effectOptions() {
		const options = super.effectOptions;
		options.density.min = 0.05;
		options.density.value = 0.25;
		options.density.max = 1;
		options.density.step = 0.05;
		return options;
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [this._getLeafEmitter(this.parent)];
	}

	/* -------------------------------------------- */

	_getLeafEmitter(parent) {
		const d = canvas.dimensions;
		const p =
			(d.width / d.size) *
			(d.height / d.size) *
			this.options.density.value;
		const config = mergeObject(
			this.constructor.LEAF_CONFIG,
			{
				spawnRect: {
					x: d.paddingX,
					y: d.paddingY,
					w: d.sceneWidth,
					h: d.sceneHeight,
				},
				maxParticles: p,
				frequency: this.constructor.LEAF_CONFIG.lifetime.min / p,
			},
			{ inplace: false }
		);
		const sprites = Array.fromRange(6).map(
			n => `ui/particles/leaf${n + 1}.png`
		);
		return new PIXI.particles.Emitter(parent, sprites, config);
	}
}

// Configure the Rain particle
AutumnLeavesWeatherEffect.LEAF_CONFIG = mergeObject(
	SpecialEffect.DEFAULT_CONFIG,
	{
		alpha: {
			start: 0.9,
			end: 0.5,
		},
		scale: {
			start: 0.2,
			end: 0.4,
			minimumScaleMultiplier: 0.5,
		},
		speed: {
			start: 20,
			end: 60,
			minimumSpeedMultiplier: 0.6,
		},
		startRotation: {
			min: 0,
			max: 365,
		},
		rotation: 180,
		rotationSpeed: {
			min: 100,
			max: 200,
		},
		lifetime: {
			min: 10,
			max: 10,
		},
	},
	{ inplace: false }
);
CONFIG.weatherEffects.autumn = AutumnLeavesWeatherEffect;

/**
 * A special full-screen weather effect which uses two Emitters to render drops and splashes
 * @type {SpecialEffect}
 */
class RainWeatherEffect extends SpecialEffect {
	static get label() {
		return 'Rain';
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [
			this._getRainEmitter(this.parent),
			this._getSplashEmitter(this.parent),
		];
	}

	/* -------------------------------------------- */

	_getRainEmitter(parent) {
		const d = canvas.dimensions;
		const p =
			(d.width / d.size) *
			(d.height / d.size) *
			this.options.density.value;
		const config = mergeObject(
			this.constructor.RAIN_CONFIG,
			{
				spawnRect: {
					x: -0.05 * d.width,
					y: -0.1 * d.height,
					w: d.width,
					h: 0.8 * d.height,
				},
				maxParticles: p,
				frequency: 1 / p,
			},
			{ inplace: false }
		);
		return new PIXI.particles.Emitter(
			parent,
			['ui/particles/rain.png'],
			config
		);
	}

	/* -------------------------------------------- */

	_getSplashEmitter(parent) {
		const d = canvas.dimensions;
		const p =
			(d.width / d.size) *
			(d.height / d.size) *
			this.options.density.value;
		const config = mergeObject(
			this.constructor.SPLASH_CONFIG,
			{
				spawnRect: {
					x: 0,
					y: 0.25 * d.height,
					w: d.width,
					h: 0.75 * d.height,
				},
				maxParticles: 0.5 * p,
				frequency: 2 / p,
			},
			{ inplace: false }
		);
		return new PIXI.particles.Emitter(
			parent,
			['ui/particles/drop.png'],
			config
		);
	}
}

// Configure the Rain particle
RainWeatherEffect.RAIN_CONFIG = mergeObject(
	SpecialEffect.DEFAULT_CONFIG,
	{
		alpha: {
			start: 0.7,
			end: 0.1,
		},
		scale: {
			start: 1.0,
			end: 1.0,
			minimumScaleMultiplier: 0.8,
		},
		speed: {
			start: 3500,
			end: 3500,
			minimumSpeedMultiplier: 0.8,
		},
		startRotation: {
			min: 75,
			max: 75,
		},
		rotation: 90,
		rotationSpeed: {
			min: 0,
			max: 0,
		},
		lifetime: {
			min: 0.5,
			max: 0.5,
		},
	},
	{ inplace: false }
);

// Configure the Splash particle
RainWeatherEffect.SPLASH_CONFIG = mergeObject(
	SpecialEffect.DEFAULT_CONFIG,
	{
		alpha: {
			start: 1,
			end: 1,
		},
		scale: {
			start: 0.6,
			end: 0.6,
			minimumScaleMultiplier: 0.8,
		},
		speed: {
			start: 0,
			end: 0,
		},
		startRotation: {
			min: -90,
			max: -90,
		},
		noRotation: true,
		lifetime: {
			min: 0.5,
			max: 0.5,
		},
	},
	{ inplace: false }
);
CONFIG.weatherEffects.rain = RainWeatherEffect;

/**
 * A special full-screen weather effect which uses one Emitters to render snowflakes
 * @type {SpecialEffect}
 */
class SnowWeatherEffect extends SpecialEffect {
	static get label() {
		return 'Snow';
	}

	/* -------------------------------------------- */

	getParticleEmitters() {
		return [this._getSnowEmitter(this.parent)];
	}

	/* -------------------------------------------- */

	_getSnowEmitter(parent) {
		const d = canvas.dimensions;
		const p =
			(d.width / d.size) *
			(d.height / d.size) *
			this.options.density.value;
		const config = mergeObject(
			this.constructor.SNOW_CONFIG,
			{
				spawnRect: {
					x: 0,
					y: -0.1 * d.height,
					w: d.width,
					h: d.height,
				},
				maxParticles: p,
				frequency: 1 / p,
			},
			{ inplace: false }
		);
		return new PIXI.particles.Emitter(
			parent,
			['ui/particles/snow.png'],
			config
		);
	}
}

// Configure the Rain particle
SnowWeatherEffect.SNOW_CONFIG = mergeObject(
	SpecialEffect.DEFAULT_CONFIG,
	{
		alpha: {
			start: 0.9,
			end: 0.5,
		},
		scale: {
			start: 0.2,
			end: 0.4,
			minimumScaleMultiplier: 0.5,
		},
		speed: {
			start: 190,
			end: 210,
			minimumSpeedMultiplier: 0.6,
		},
		startRotation: {
			min: 50,
			max: 75,
		},
		rotation: 90,
		rotationSpeed: {
			min: 0,
			max: 200,
		},
		lifetime: {
			min: 4,
			max: 4,
		},
	},
	{ inplace: false }
);
CONFIG.weatherEffects.snow = SnowWeatherEffect;

/**
 * The base grid class.
 * This double-dips to implement the "gridless" option
 */
class BaseGrid extends PIXI.Container {
	constructor(options) {
		super();
		this.options = options;

		/**
		 * Grid Unit Width
		 */
		this.w = canvas.dimensions.size;

		/**
		 * Grid Unit Height
		 */
		this.h = canvas.dimensions.size;

		/**
		 * Highlight active grid spaces
		 * @type {Object}
		 */
		this.highlight = this.addChild(new PIXI.Container());
	}

	/* -------------------------------------------- */

	draw() {
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Highlight a grid position for a certain coordinates
	 * No highlighting behavior is supported for Gridless types
	 */
	highlightGridPosition(layer, options) {
		return false;
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
  /* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		const s = canvas.dimensions.size;
		return [x, y].map(c => Math.round(c - s / 2));
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		return [x, y];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * Under a "gridless" system, every pixel position is a valid snapping position
	 *
	 * @param {Number} x          The exact target location x
	 * @param {Number} y          The exact target location y
	 * @param {Number} interval   An interval of grid spaces at which to snap, default is 1
	 *
	 * @return {{x, y}}           An object containing the coordinates of the snapped location
	 */
	getSnappedPosition(x, y, interval = 1) {
		return { x: Math.round(x), y: Math.round(y) };
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of pixel coordinates, return the grid position as an Array
	 * @param {Number} x    The x-coordinate pixel position
	 * @param {Number} y    The y-coordinate pixel position
	 * @return {{x,y}}      An array representing the position in grid units
	 */
	getGridPositionFromPixels(x, y) {
		return [x, y].map(Math.round);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of grid coordiantes, return the pixel position as an Array
	 * @param {Number} x    The x-coordinate grid position
	 * @param {Number} y    The y-coordinate grid position
	 * @return {{x,y}}      An array representing the position in pixels
	 */
	getPixelsFromGridPosition(x, y) {
		return [x, y].map(Math.round);
	}

	/* -------------------------------------------- */

	/**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {Number} x    The starting x-coordinate in pixels
	 * @param {Number} y    The starting y-coordinate in pixels
	 * @param {Number} dx   The number of grid positions to shift horizontally
	 * @param {Number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let s = canvas.dimensions.size;
		return [x + dx * s, y + dy * s];
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two pixel coordinates
	 * @param {Object} p0           The origin coordinate {x, y}
	 * @param {Object} p1           The destination coordinate {x, y}
	 * @param {boolean} gridSpaces  Enforce grid distance (if true) vs. direct point-to-point (if false)
	 * @return {number}             The distance between p1 and p0
	 */
	measureDistance(p0, p1, { gridSpaces = true } = {}) {
		let dx = p1.x - p0.x,
			dy = p1.y - p0.y,
			dist = Math.hypot(dx, dy);
		return (dist / canvas.dimensions.size) * canvas.dimensions.distance;
	}

	/* -------------------------------------------- */

	/**
	 * Get the grid row and column positions which are neighbors of a certain position
	 * @param {Number} row  The grid row coordinate against which to test for neighbors
	 * @param {Number} col  The grid column coordinate against which to test for neighbors
	 * @return {Array}      An array of grid positions which are neighbors of the row and column
	 */
	getNeighbors(row, col) {
		return [];
	}
}
/**
 * Construct a hexagonal grid
 * @type {BaseGrid}
 */
class HexagonalGrid extends BaseGrid {
	constructor(options) {
		super(options);
		this.columns = !!this.options.columns;
		this.even = !!this.options.even;

		// Grid width and height
		let s = canvas.dimensions.size;
		if (this.columns) {
			this.w = s;
			this.h = Math.round(Math.sqrt(3) * 0.5 * s);
		} else {
			this.w = Math.round(Math.sqrt(3) * 0.5 * s);
			this.h = s;
		}
	}

	/**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get pointy-top polygon coordinates
	 * @type {Array}
	 */
	static get pointyHexPoints() {
		return [
			[0, 0.25],
			[0.5, 0],
			[1, 0.25],
			[1, 0.75],
			[0.5, 1],
			[0, 0.75],
			[0, 0.25],
		];
	}

	/* -------------------------------------------- */

	/**
	 * A matrix of x and y offsets which is multiplied by the width/height vector to get flat-top polygon coordinates
	 * @type {Array}
	 */
	static get flatHexPoints() {
		return [
			[0, 0.5],
			[0.25, 0],
			[0.75, 0],
			[1, 0.5],
			[0.75, 1],
			[0.25, 1],
			[0, 0.5],
		];
	}

	/* -------------------------------------------- */
	/*  Grid Rendering
  /* -------------------------------------------- */

	draw() {
		if (this.alpha === 0) return this;

		// Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;

		// Draw grid polygons
		this.addChild(this._drawGrid());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Get the points which form a flat-topped hex polygon starting at {x,y} with width and height of {w,h}
	 * @param {number} x    The top-left x-coordinate for the hexagon frame
	 * @param {number} y    The top-left y-coordinate for the hexagon frame
	 * @param {number} w    The hexagon width
	 * @param {number} h    The hexagon height
	 * @return {Array}
	 */
	getFlatHexPolygon(x, y, w, h) {
		const points = this.constructor.flatHexPoints;
		return points.reduce((arr, p) => {
			return arr.concat([x + w * p[0], y + h * p[1]]);
		}, []);
	}

	/* -------------------------------------------- */

	/**
	 * Get the points which form a pointy-topped hex polygon starting at {x,y} with width and height of {w,h}
	 * @param {number} x    The top-left x-coordinate for the hexagon frame
	 * @param {number} y    The top-left y-coordinate for the hexagon frame
	 * @param {number} w    The hexagon width
	 * @param {number} h    The hexagon height
	 * @return {Array}
	 */
	getPointyHexPolygon(x, y, w, h) {
		const points = this.constructor.pointyHexPoints;
		return points.reduce((arr, p) => {
			return arr.concat([x + w * p[0], y + h * p[1]]);
		}, []);
	}

	/* -------------------------------------------- */

	_drawGrid() {
		let { color, alpha, columns } = this.options;
		let ncols = Math.floor(canvas.dimensions.width / this.w),
			nrows = Math.ceil(canvas.dimensions.height / this.h);

		// Draw Grid graphic
		let grid = new PIXI.Graphics();
		grid.lineStyle(1, color, alpha);

		// Draw hex rows
		if (columns) this._drawColumns(grid, nrows, ncols);
		else this._drawRows(grid, nrows, ncols);

		// TODO - Temporary PIXI v5 hack for graphics batching overflow (https://github.com/pixijs/pixi.js/issues/6047)
		grid.geometry.updateBatches();
		grid.geometry._indexBuffer.update(
			new Uint32Array(grid.geometry.indices)
		);
		return grid;
	}

	/* -------------------------------------------- */

	_drawRows(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		nrows /= 0.75;
		for (let r = 0; r < nrows; r++) {
			let sx = r % 2 === shift ? 0 : -0.5;
			let y0 = r * this.h * 0.75;
			for (let c = 0; c < ncols; c++) {
				let x0 = (c + sx) * this.w;
				grid.drawPolygon(
					this.getPointyHexPolygon(x0, y0, this.w, this.h)
				);
			}
		}
	}

	/* -------------------------------------------- */

	_drawColumns(grid, nrows, ncols) {
		let shift = this.even ? 0 : 1;
		ncols /= 0.75;
		for (let c = 0; c < ncols; c++) {
			let sy = c % 2 === shift ? 0 : -0.5;
			let x0 = c * this.w * 0.75;
			for (let r = 0; r < nrows; r++) {
				let y0 = (r + sy) * this.h;
				grid.drawPolygon(
					this.getFlatHexPolygon(x0, y0, this.w, this.h)
				);
			}
		}
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
  /* -------------------------------------------- */

	/**
	 * Given a pair of pixel coordinates, return the grid position as an Array
	 * @param {Number} x    The x-coordinate pixel position
	 * @param {Number} y    The y-coordinate pixel position
	 * @return {Array}      An array representing the position in grid units, [row,col]
	 */
	getGridPositionFromPixels(x, y) {
		let row, col;
		if (this.options.columns) {
			col = Math.floor(x / (this.w * 0.75));
			let isEven = (col + 1) % 2 === 0;
			y += this.options.even === isEven ? this.h / 2 : 0;
			row = Math.floor(y / this.h);
		} else {
			row = Math.floor(y / (this.h * 0.75));
			let isEven = (row + 1) % 2 === 0;
			x += this.options.even === isEven ? this.w / 2 : 0;
			col = Math.floor(x / this.w);
		}
		return [row, col];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of grid coordinates, return the pixel position as an Array
	 * @param {Number} row    The row coordinate grid position
	 * @param {Number} col    The column coordinate grid position
	 * @return {Array}        An array representing the position in pixels, [x,y]
	 */
	getPixelsFromGridPosition(row, col) {
		let x, y;
		if (this.options.columns) {
			x = col * (this.w * 0.75);
			y = row * this.h;
			let isEven = (col + 1) % 2 === 0;
			if (this.options.even === isEven) y -= this.h / 2;
		} else {
			y = row * (this.h * 0.75);
			x = col * this.w;
			let isEven = (row + 1) % 2 === 0;
			if (this.options.even === isEven) x -= this.w / 2;
		}
		return [x, y];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		let [row, col] = this.getGridPositionFromPixels(x, y);
		return this.getPixelsFromGridPosition(row, col);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		let [x0, y0] = this.getTopLeft(x, y);
		return [x0 + this.w / 2, y0 + this.h / 2];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * Under a "gridless" system, every pixel position is a valid snapping position
	 *
	 * @param {Number} x          The exact target location x
	 * @param {Number} y          The exact target location y
	 * @param {Number} interval   An interval of grid spaces at which to snap, default is 1
	 *
	 * @return {{x, y}}           An object containing the coordinates of the snapped location
	 */
	getSnappedPosition(x, y, interval = 1) {
		// Get the top-left coordinate based on centralizing the drop point
		let ox = this.w / 2 - 1;
		let oy = this.h / 2 - 1;
		let [x0, y0] = this.getTopLeft(x + ox, y + oy);

		// For exact snapping, return here
		if (interval === 1) return { x: x0, y: y0 };

		// Round the difference to a certain level of precision
		let ix = this.w / interval;
		let dx = Math.round((x - x0) / ix) * ix;
		let iy = this.h / interval;
		let dy = Math.round((y - y0) / iy) * iy;
		return { x: x0 + dx, y: y0 + dy };
	}

	/* -------------------------------------------- */

	/**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {Number} x    The starting x-coordinate in pixels
	 * @param {Number} y    The starting y-coordinate in pixels
	 * @param {Number} dx   The number of grid positions to shift horizontally
	 * @param {Number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);

		// Adjust diagonal moves for offset
		let isDiagonal = dx !== 0 && dy !== 0;
		if (isDiagonal) {
			// Column orientation
			if (this.options.columns) {
				let isEven = ((col + 1) % 2 === 0) === this.options.even;
				if (isEven && dy > 0) dy--;
				else if (!isEven && dy < 0) dy++;
			}

			// Row orientation
			else {
				let isEven = ((row + 1) % 2 === 0) === this.options.even;
				if (isEven && dx > 0) dx--;
				else if (!isEven && dx < 0) dx++;
			}
		}
		return canvas.grid.grid.getPixelsFromGridPosition(row + dy, col + dx);
	}

	/* -------------------------------------------- */
	/*  Grid Highlighting
  /* -------------------------------------------- */

	/**
	 * Highlight a grid position for a certain coordinates
	 * @param {GridHighlight} layer The highlight layer to use
	 * @param {Number} x            The x-coordinate of the highlighted position
	 * @param {Number} y            The y-coordinate of the highlighted position
	 * @param {Number} color        The hex fill color of the highlight
	 * @param {Number} border       The hex border color of the highlight
	 * @param {Number} alpha        The opacity of the highlight
	 */
	highlightGridPosition(
		layer,
		{ x, y, color = 0x33bbff, border = null, alpha = 0.25 } = {}
	) {
		if (!layer.highlight(x, y)) return;

		// Draw the highlight
		const points = this.options.columns
			? this.constructor.flatHexPoints
			: this.constructor.pointyHexPoints;
		const coords = points.reduce((arr, p) => {
			arr.push(x + p[0] * this.w);
			arr.push(y + p[1] * this.h);
			return arr;
		}, []);
		layer.beginFill(color, alpha);
		if (border) layer.lineStyle(2, border, Math.min(alpha * 1.5, 1.0));
		layer.drawPolygon(new PIXI.Polygon(coords));
	}

	/* -------------------------------------------- */

	/**
	 * Get the grid row and column positions which are neighbors of a certain position
	 * @param {Number} row  The grid row coordinate against which to test for neighbors
	 * @param {Number} col  The grid column coordinate against which to test for neighbors
	 * @return {Array}      An array of grid positions which are neighbors of the row and column
	 */
	getNeighbors(row, col) {
		let offsets;

		// Column orientation
		if (this.options.columns) {
			let shift = ((col + 1) % 2 === 0) === this.options.even;
			if (shift)
				offsets = [
					[-1, -1],
					[-1, 0],
					[-1, 1],
					[0, 1],
					[1, 0],
					[0, -1],
				];
			else
				offsets = [
					[0, -1],
					[-1, 0],
					[0, 1],
					[1, 1],
					[1, 0],
					[1, -1],
				];
		}

		// Row orientation
		else {
			let shift = ((row + 1) % 2 === 0) === this.options.even;
			if (shift)
				offsets = [
					[0, -1],
					[-1, -1],
					[-1, 0],
					[0, 1],
					[1, 0],
					[1, -1],
				];
			else
				offsets = [
					[0, -1],
					[-1, 0],
					[-1, 1],
					[0, 1],
					[1, 1],
					[1, 0],
				];
		}
		return offsets.map(o => [row + o[0], col + o[1]]);
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two pixel coordinates
	 * See BaseGrid.measureDistance for more details
	 */
	measureDistance(p0, p1, { gridSpaces = true } = {}) {
		if (!gridSpaces) return super.measureDistance(p0, p1, { gridSpaces });
		let [r0, c0] = this.getGridPositionFromPixels(p0.x, p0.y),
			[r1, c1] = this.getGridPositionFromPixels(p1.x, p1.y);

		// Use cube conversion to measure distance
		let hex0 = this._offsetToCube(r0, c0),
			hex1 = this._offsetToCube(r1, c1),
			distance = this._cubeDistance(hex0, hex1);
		return distance * canvas.dimensions.distance;
	}

	/* -------------------------------------------- */
	/*  Helper Functions
  /* -------------------------------------------- */

	/**
	 * Convert a standard "offset" coordinate of (row, col) into a "cube" coordinate (q, r, s)
	 * See https://www.redblobgames.com/grids/hexagons/ for reference
	 * Source code available https://www.redblobgames.com/grids/hexagons/codegen/output/lib-functions.js
	 * @param {Number} row
	 * @param {Number} col
	 * @private
	 */
	_offsetToCube(row, col) {
		let offset = this.options.even ? 1 : -1;

		// Column orientation
		if (this.options.columns) {
			let q = col,
				r = row - (col + offset * (col & 1)) / 2,
				s = 0 - q - r;
			return { q: q, r: r, s: s };
		}

		// Row orientation
		else {
			let r = row,
				q = col - (row + offset * (row & 1)) / 2,
				s = 0 - q - r;
			return { q: q, r: r, s: s };
		}
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance in hexagons between two cube coordinates
	 * @private
	 */
	_cubeDistance(a, b) {
		let diff = { q: a.q - b.q, r: a.r - b.r, s: a.s - b.s };
		return (Math.abs(diff.q) + Math.abs(diff.r) + Math.abs(diff.s)) / 2;
	}
}

/**
 * A special Graphics class which handles Grid layer highlighting
 * @type {PIXI.Graphics}
 */
class GridHighlight extends PIXI.Graphics {
	constructor(name, ...args) {
		super(...args);

		/**
		 * Track the Grid Highlight name
		 * @type {String}
		 */
		this.name = name;

		/**
		 * Track distinct positions which have already been highlighted
		 * @type {Set}
		 */
		this.positions = new Set();
	}

	/* -------------------------------------------- */

	/**
	 * Record a position that is highlighted and return whether or not it should be rendered
	 * @param {Number} x    The x-coordinate to highlight
	 * @param {Number} y    The y-coordinate to highlight
	 * @return {Boolean}    Whether or not to draw the highlight for this location
	 */
	highlight(x, y) {
		let key = `${x}.${y}`;
		if (this.positions.has(key)) return false;
		this.positions.add(key);
		return true;
	}

	/* -------------------------------------------- */

	/**
	 * Extend the Graphics clear logic to also reset the highlighted positions
	 * @param args
	 */
	clear(...args) {
		super.clear(...args);
		this.positions = new Set();
	}

	/* -------------------------------------------- */

	/**
	 * Extend how this Graphics container is destroyed to also remove parent layer references
	 * @param args
	 */
	destroy(...args) {
		delete canvas.grid.highlightLayers[this.name];
		super.destroy(...args);
	}
}

/**
 * A CanvasLayer responsible for drawing a square grid
 */
class GridLayer extends CanvasLayer {
	constructor() {
		super();

		/**
		 * The Grid container
		 * @type {PIXI.Container}
		 */
		this.grid = null;

		/**
		 * The Grid Highlight container
		 * @type {PIXI.Container}
		 */
		this.highlight = null;

		/**
		 * Map named highlight layers
		 * @type {{GridHighlight}}
		 */
		this.highlightLayers = {};
	}

	/* -------------------------------------------- */

	/**
	 * The grid type rendered in this Scene
	 * @type {String}
	 */
	get type() {
		return canvas.scene.data.gridType;
	}

	/**
	 * A convenient reference to the pixel grid size used throughout this layer
	 * @type {Number}
	 */
	get size() {
		return canvas.dimensions.size;
	}

	/**
	 * Get grid unit width
	 */
	get w() {
		return this.grid.w;
	}

	/**
	 * Get grid unit height
	 */
	get h() {
		return this.grid.h;
	}

	/* -------------------------------------------- */

	/**
	 * Draw square grid lines
	 */
	draw() {
		super.draw();

		// Get grid data
		const gt = this.type;

		// Grid configuration
		let grid;
		let gridOptions = {
			dimensions: canvas.dimensions,
			color: canvas.scene.data.gridColor.replace('#', '0x') || '0x000000',
			alpha: canvas.scene.data.gridAlpha,
			columns: [
				CONST.GRID_TYPES.HEXODDQ,
				CONST.GRID_TYPES.HEXEVENQ,
			].includes(gt),
			even: [
				CONST.GRID_TYPES.HEXEVENR,
				CONST.GRID_TYPES.HEXEVENQ,
			].includes(gt),
		};

		// Gridless
		if (gt === CONST.GRID_TYPES.GRIDLESS) grid = new BaseGrid(gridOptions);
		// Square grid
		else if (gt === CONST.GRID_TYPES.SQUARE)
			grid = new SquareGrid(gridOptions);
		// Hexagonal grid
		else grid = new HexagonalGrid(gridOptions);

		// Draw the highlight layer
		this.highlight = this.addChild(new PIXI.Container());

		// Draw the grid
		this.grid = this.addChild(grid.draw());
		return this;
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * @param {Number} x          The exact target location x
	 * @param {Number} y          The exact target location y
	 * @param {Number} interval   An interval of grid spaces at which to snap, default is 1.
	 */
	getSnappedPosition(x, y, interval) {
		return this.grid.getSnappedPosition(x, y, interval);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		return this.grid.getTopLeft(x, y);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		return this.grid.getCenter(x, y);
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two pixel coordinates
	 * @param {Array} args    All args are forwarded to the Grid implementation measureDistance function
	 */
	measureDistance(...args) {
		return this.grid.measureDistance(...args);
	}

	/* -------------------------------------------- */
	/*  Grid Highlighting Methods
  /* -------------------------------------------- */

	/**
	 * Define a new Highlight graphic
	 * @param name
	 */
	addHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if (!layer || layer._destroyed) {
			this.highlightLayers[name] = this.highlight.addChild(
				new GridHighlight(name)
			);
		}
		return this.highlightLayers[name];
	}

	/* -------------------------------------------- */

	/**
	 * Clear a specific Highlight graphic
	 * @param name
	 */
	clearHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		if (layer) layer.clear();
	}

	/* -------------------------------------------- */

	/**
	 * Destroy a specific Highlight graphic
	 * @param name
	 */
	destroyHighlightLayer(name) {
		const layer = this.highlightLayers[name];
		this.highlight.removeChild(layer);
		layer.destroy();
	}

	/* -------------------------------------------- */

	getHighlightLayer(name) {
		return this.highlightLayers[name];
	}

	/* -------------------------------------------- */

	highlightPosition(name, options) {
		const layer = this.highlightLayers[name];
		if (!layer) return false;
		this.grid.highlightGridPosition(layer, options);
	}

	/* -------------------------------------------- */

	/**
	 * Test if a specific row and column position is a neighboring location to another row and column coordinate
	 */
	isNeighbor(r0, c0, r1, c1) {
		let neighbors = this.grid.getNeighbors(r0, c0);
		return neighbors.some(n => n[0] === r1 && n[1] === c1);
	}
}

/**
 * Construct a square grid container
 * @type {BaseGrid}
 */
class SquareGrid extends BaseGrid {
	/**
	 * Draw Square Grid lines
	 */
	draw() {
		let { color, alpha } = this.options;
		if (alpha === 0) return this;

		// Set dimensions
		let d = this.options.dimensions;
		this.width = d.width;
		this.height = d.height;

		// Vertical lines
		let nx = Math.floor(d.width / d.size);
		for (let i = 1; i < nx; i++) {
			let x = i * d.size;
			this.addChild(this._drawLine([x, 0, x, d.height], color, alpha));
		}

		// Horizontal lines
		let ny = Math.ceil(d.height / d.size);
		for (let i = 1; i < ny; i++) {
			let y = i * d.size;
			this.addChild(this._drawLine([0, y, d.width, y], color, alpha));
		}
		return this;
	}

	/* -------------------------------------------- */

	_drawLine(points, lineColor, lineAlpha) {
		let line = new PIXI.Graphics();
		line.lineStyle(1, lineColor, lineAlpha)
			.moveTo(points[0], points[1])
			.lineTo(points[2], points[3]);
		return line;
	}

	/* -------------------------------------------- */
	/*  Grid Measurement Methods
  /* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y) - return the top-left of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the top-left coordinate of the square which contains (x, y)
	 */
	getTopLeft(x, y) {
		let [x0, y0] = this.getGridPositionFromPixels(x, y);
		return this.getPixelsFromGridPosition(x0, y0);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x, y), return the center of the grid square which contains that point
	 * @return {Array}    An Array [x, y] of the central point of the square which contains (x, y)
	 */
	getCenter(x, y) {
		const gs = canvas.dimensions.size;
		return this.getTopLeft(x, y).map(c => c + gs / 2);
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of pixel coordinates, return the grid position as an Array
	 * @param {Number} x    The x-coordinate pixel position
	 * @param {Number} y    The y-coordinate pixel position
	 * @return {Array}      An array representing the position in grid units, [row,col]
	 */
	getGridPositionFromPixels(x, y) {
		let gs = canvas.dimensions.size;
		return [Math.floor(y / gs), Math.floor(x / gs)];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of grid coordinates, return the pixel position as an Array
	 * @param {Number} row    The row coordinate grid position
	 * @param {Number} col    The column coordinate grid position
	 * @return {Array}        An array representing the position in pixels, [x,y]
	 */
	getPixelsFromGridPosition(row, col) {
		let gs = canvas.dimensions.size;
		return [col * gs, row * gs];
	}

	/* -------------------------------------------- */

	/**
	 * Given a pair of coordinates (x1,y1), return the grid coordinates (x2,y2) which represent the snapped position
	 * @param {Number} x          The exact target location x
	 * @param {Number} y          The exact target location y
	 * @param {Number} interval   An interval of grid spaces at which to snap, default is 1.
	 */
	getSnappedPosition(x, y, interval = 1) {
		let [x0, y0] = this._getNearestVertex(x, y),
			dx = 0,
			dy = 0;
		if (interval !== 1) {
			let delta = canvas.dimensions.size / interval;
			dx = Math.round((x - x0) / delta) * delta;
			dy = Math.round((y - y0) / delta) * delta;
		}
		return {
			x: x0 + dx,
			y: y0 + dy,
		};
	}

	/* -------------------------------------------- */

	/**
	 * Shift a pixel position [x,y] by some number of grid units dx and dy
	 * @param {Number} x    The starting x-coordinate in pixels
	 * @param {Number} y    The starting y-coordinate in pixels
	 * @param {Number} dx   The number of grid positions to shift horizontally
	 * @param {Number} dy   The number of grid positions to shift vertically
	 */
	shiftPosition(x, y, dx, dy) {
		let [row, col] = canvas.grid.grid.getGridPositionFromPixels(x, y);
		return canvas.grid.grid.getPixelsFromGridPosition(row + dy, col + dx);
	}

	/* -------------------------------------------- */

	_getNearestVertex(x, y) {
		const gs = canvas.dimensions.size;
		return [Math.round(x / gs) * gs, Math.round(y / gs) * gs];
	}

	/* -------------------------------------------- */

	/**
	 * Highlight a grid position for a certain coordinates
	 * @param {GridHighlight} layer The highlight layer to use
	 * @param {Number} x            The x-coordinate of the highlighted position
	 * @param {Number} y            The y-coordinate of the highlighted position
	 * @param {Number} color        The hex fill color of the highlight
	 * @param {Number} border       The hex border color of the highlight
	 * @param {Number} alpha        The opacity of the highlight
	 */
	highlightGridPosition(
		layer,
		{ x, y, color = 0x33bbff, border = null, alpha = 0.25 } = {}
	) {
		if (!layer.highlight(x, y)) return;
		let s = canvas.dimensions.size;
		layer.beginFill(color, alpha);
		if (border) layer.lineStyle(2, border, Math.min(alpha * 1.5, 1.0));
		layer.drawRect(x, y, s, s);
	}

	/* -------------------------------------------- */

	/**
	 * Measure the distance between two pixel coordinates
	 * See BaseGrid.measureDistance for more details
	 */
	measureDistance(p0, p1, { gridSpaces = true } = {}) {
		if (!gridSpaces) return super.measureDistance(p0, p1, { gridSpaces });
		let gs = canvas.dimensions.size,
			ray = new Ray(p0, p1),
			nx = Math.abs(Math.ceil(ray.dx / gs)),
			ny = Math.abs(Math.ceil(ray.dy / gs));

		// Get the number of straight and diagonal moves
		let nDiagonal = Math.min(nx, ny),
			nStraight = Math.abs(ny - nx);

		// Return linear distance for all moves
		return (nStraight + nDiagonal) * canvas.dimensions.distance;
	}

	/* -------------------------------------------- */

	/**
	 * Get the grid row and column positions which are neighbors of a certain position
	 * @param {Number} row  The grid row coordinate against which to test for neighbors
	 * @param {Number} col  The grid column coordinate against which to test for neighbors
	 * @return {Array}      An array of grid positions which are neighbors of the row and column
	 */
	getNeighbors(row, col) {
		let offsets = [
			[-1, -1],
			[-1, 0],
			[-1, 1],
			[0, -1],
			[0, 1],
			[1, -1],
			[1, 0],
			[1, 1],
		];
		return offsets.map(o => [row + o[0], col + o[1]]);
	}
}

/**
 * WebRTC Client using the EasyRTC framework for its implementation.
 * Whenever a new remote stream is received by this implementation, a call to `this.webrtc.onUserStreamChange()`
 * will be made to notify of the new or deleted stream.
 *
 * @implements {WebRTCInterface}
 * @param {WebRTC} webrtc             The WebRTC object
 * @param {WebRTCSettings} settings   The WebRTC Settings object
 */
class EasyRTCClient extends WebRTCInterface {
	constructor(webrtc, settings) {
		super(webrtc, settings);

		/**
		 * Cached copy of the room joined
		 * @type {String}
		 * @private
		 */
		this._room = null;

		/**
		 * A cached mapping of easyRtcId peer ids to FVTT user ids
		 * We need to save the username of the peers because once their stream is closed because they left the room,
		 * then we can't find their username anymore as that data gets deleted before the callback.
		 * @type {Object}
		 * @private
		 */
		this._usernameCache = {};

		/**
		 * An array of easyRtcId peers that rejected our calls
		 * If we call a peer and the call gets rejected, we might end up in an infinite loop as the roomOccupant
		 * listener gets called again after the call is cancelled, and we might try to call that peer again. This can
		 * happen if we open multiple instances of FVTT with the same user.
		 * @type {Array}
		 * @private
		 */
		this._callRejections = [];
	}

	/* -------------------------------------------- */

	/**
	 * Initialize the WebRTC implementation.
	 * This Will only be called once by the main setupGame() initialization function.
	 * @return {Promise.boolean}
	 */
	async initialize() {
		easyrtc.enableDebug(this.settings.debugClient);
		easyrtc.setUsername(game.user.id);
		easyrtc.setVideoDims(320, 240, undefined);
		easyrtc.setAutoInitUserMedia(false);
		easyrtc.setRoomOccupantListener(this._onRoomOccupantsChange.bind(this));
		easyrtc.setDisconnectListener(this._onDisconnect.bind(this));
		easyrtc.setOnError(this._onError.bind(this));
		easyrtc.setAcceptChecker(this._answerIncomingCall.bind(this));
		easyrtc.setStreamAcceptor(this._onStreamAdded.bind(this));
		easyrtc.setOnStreamClosed(this._onStreamClosed.bind(this));
		easyrtc.setPeerOpenListener(this._onPeerOpen.bind(this));
		easyrtc.setPeerClosedListener(this._onPeerClosed.bind(this));
		return true;
	}

	/* -------------------------------------------- */
	/*  Connection and local Media creation         */
	/* -------------------------------------------- */

	/**
	 * Connect to the signalling server.
	 * Any existing connections will be dropped and any existing calls hung up.
	 * Once a connection to the server is established and the user authenticated, join a room and automatically
	 * establish a call with other users in that same room.
	 * If a local master media stream has been created, add a copy of that stream to every peer.
	 * Whether to include audio or video in that cloned stream, or whether to enable or disable the audio and video of
	 * the remote stream from that peer will automatically be determined based on the saved settings.
	 * This will be called again in case a server configuration changed.
	 *
	 * In case of using FVTT server, we can't use the same socket as game.socket because the server side can close
	 * the socket in case of errors (such as disconnection/reconnection attempt where it would say that we are
	 * 'already connected' and disconnect us forcibly) and thus it could destroy the actual game's socket, so we use
	 * a different path for it instead with easyrtc.useThisSocketConnection(game.socket)
	 *
	 * @param {string} host            Server host address. Set to `null` to use current FVTT server
	 * @param {string} room            Name of the room to join on the signalling server
	 * @param {string} username        Username to authenticate to the server (if needed)
	 * @param {string} password        Password to authenticate the user (if needed)
	 * @return {Promise.boolean}       Returns success/failure to connect
	 */
	async connect({ host, room, username, password } = {}) {
		return new Promise(async resolve => {
			await this.disconnect();

			// Get connection credentials to send to the server
			let credential = { username, password };
			if (host == null) {
				host = window.location.origin;
				// TODO: switch to session based cookie authentication and ignore username/password
				credential = { password: password || '' };
			}

			// Configure the socket target and connection credentials
			easyrtc.setSocketUrl(host, {
				path: '/easyrtc',
				reconnectionAttempts: 2,
				timeout: 10000,
				forceNew: true,
			});
			easyrtc.setCredential(credential);

			// Choose the room to join, starting with a default room.
			this._room = room || 'default';

			// Leave any rooms that were previously joined, and join the chosen one
			Object.keys(easyrtc.getRoomsJoined()).forEach(easyrtc.leaveRoom);
			easyrtc.joinRoom(this._room, null, null, null);

			// Connect to the server
			easyrtc.connect(
				'FoundryVTT',
				this._loginSuccess.bind(this, resolve),
				this._loginFailure.bind(this, resolve)
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Connection success callback
	 * @private
	 */
	_loginSuccess(resolve, easyRtcId) {
		game.webrtc.debug(
			'Login successful, I am ' + easyrtc.cleanId(easyRtcId)
		);
		this._setupCustomTURN();
		resolve(true);
	}

	/* -------------------------------------------- */

	/**
	 * Connection failure callback
	 * @private
	 */
	_loginFailure(resolve, errorCode, message) {
		game.webrtc.debug('Login ERROR ', errorCode, message);
		this.webrtc.onError(message);
		resolve(false);
	}

	/* -------------------------------------------- */

	/**
	 * Setup the custom TURN relay to be used in subsequent calls if there is one configured
	 * If configured, setup custom TURN configuration for future calls. Turn credentials are mandatory in WebRTC.
	 * @private
	 */
	_setupCustomTURN() {
		if (
			this.settings.turnType === 'custom' &&
			this.settings.turnUrl !== '' &&
			this.settings.turnUsername !== '' &&
			this.settings.turnPassword !== ''
		) {
			// Create a TURN configuration, replacing the server-provided ones with custom settings
			const config = duplicate(easyrtc.getServerIce());
			config.iceServers = config.iceServers.filter(
				ice => !(ice.url || ice.urls[0]).startsWith('turn')
			);
			config.iceServers.push({
				urls: ['turn:' + this.settings.turnUrl],
				url: 'turn:' + this.settings.turnUrl,
				username: this.settings.turnUsername,
				credential: this.settings.turnPassword,
			});
			easyrtc.setIceUsedInCalls(config);
		}

		// Reset to server values in case setting changed
		else {
			easyrtc.setIceUsedInCalls(easyrtc.getServerIce());
		}
	}

	/* -------------------------------------------- */

	/**
	 * Disconnect from the signalling server, any existing calls will be terminated.
	 * This is also called whenever the server configuration is changed.
	 *
	 * @return {Promise.boolean}       Returns success/failure to connect
	 */
	async disconnect() {
		return new Promise(resolve => {
			easyrtc.setDisconnectListener(() => {
				easyrtc.setDisconnectListener(this._onDisconnect.bind(this));
				resolve(true);
			});
			easyrtc.hangupAll();
			easyrtc.disconnect();
		});
	}

	/* -------------------------------------------- */

	/**
	 * Initialize a local media stream
	 * Capture the local audio and video and returns the stream associated with them.
	 *
	 * If @temporary is `false` (default), then this will initialize the master stream, not the actual streams being
	 * sent to individual users. However, if a master stream was already created, it will automatically get closed and
	 * every individual streams derived from it that are being sent to connected users will be removed from the calls.
	 * Each established or subsequent calls will receive a copy of the created stream (A/V depending on user permissions)
	 *
	 * If @temporary is `true` then this only applies to a temporary stream and does not affect the master stream or any
	 * streams in existing calls.
	 * Note that this assumes only one temporary stream can be created at a time.
	 *
	 * @param {string|null} audioSrc       ID of the audio source to capture from or null to disable Audio
	 * @param {string|null} videoSrc       ID of the video source to capture from or null to disable Video
	 * @param {boolean} temporary          Whether to create a temporary stream or the master stream
	 * @return {Promise.MediaStream}       Returns the local stream or `null` if none could be created
	 */
	async initLocalStream(audioSrc, videoSrc, temporary = false) {
		return new Promise(async resolve => {
			// Define the stream name and close other local streams
			const streamName = temporary ? 'temporary' : null;
			const settings = this.settings.users[game.user.id];
			await this.closeLocalStream(temporary);

			// Configure data channels
			easyrtc.enableDataChannels(false);
			easyrtc.enableAudio(audioSrc != null);
			easyrtc.enableVideo(videoSrc != null);

			// Assign media sources, or return early if none are applied
			if (!audioSrc && !videoSrc) return resolve(null);
			easyrtc.setVideoSource(videoSrc);
			easyrtc.setAudioSource(audioSrc);

			// Define success handler
			const onSuccess = async () => {
				// Get the users own stream
				const stream = easyrtc.getLocalStream(streamName);
				if (temporary) return resolve(stream);

				// Enable or disable camera and microphone
				easyrtc.enableCamera(!settings.hidden, streamName);
				easyrtc.enableMicrophone(!settings.muted, streamName);

				// Call the hook before we start creating streams for already connected peers
				Hooks.callAll('rtcLocalStreamOpened', this.webrtc, stream);

				// Add the stream to each peer
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (
						easyrtc.getConnectStatus(peer) === easyrtc.NOT_CONNECTED
					)
						continue;
					let peerStream = this._createStreamForPeer(peer);
					if (peerStream) {
						easyrtc.addStreamToCall(
							peer,
							peerStream.streamName,
							null
						);
						// addStreamToCall should cause a renegotiation but it won't happen if we just closed our stream which
						// means we removed it from the call then we add a similar one to it right away. The problem is that the
						// other side risks not seeing the change in the stream if that happens so we force a renegotiation with
						// the other peer.
						easyrtc.renegotiate(peer);
					}
				}
				resolve(stream);
			};

			// Define failure handler
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug(
					'Error capturing media ',
					errorCode,
					errorText
				);
				if (temporary) return resolve(null);

				// If master stream, renegotiate with every connected peer now that we have no more stream to send
				const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
				for (let peer of peers) {
					if (
						easyrtc.getConnectStatus(peer) !== easyrtc.NOT_CONNECTED
					)
						easyrtc.renegotiate(peer);
				}
				resolve(null);
			};

			// Init the media source with the appropriate name
			easyrtc.initMediaSource(onSuccess, onFailure, streamName);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Closes a local media stream.
	 * If the master stream is closed, any subsequent WebRTC calls will not have any streams sent to the peer.
	 *
	 * If @temporary is `false` (default), the master stream will be destroyed and all local streams removed from any
	 * existing calls. If @temporary is `true`, closes the temporary stream
	 *
	 * @param {boolean} temporary     Whether to create a temporary stream or the master stream
	 * @return {Promise}
	 */
	async closeLocalStream(temporary = false) {
		const streamName = temporary ? 'temporary' : null;
		easyrtc.closeLocalStream(streamName);
		if (temporary) return;
		const streamNames = easyrtc.getLocalMediaIds();
		for (let streamName of streamNames) {
			if (streamName === 'temporary') continue;
			easyrtc.closeLocalStream(streamName);
		}
		Hooks.callAll('rtcLocalStreamClosed', this.webrtc);
	}

	/* -------------------------------------------- */

	/**
	 * Assigns a stream to a video element
	 *
	 * @param {MediaStream} stream        The stream to assign
	 * @param {HTMLVideoElement} video    The video element to configure
	 */
	assignStreamToVideo(stream, video) {
		easyrtc.setVideoObjectSrc(video, stream);
	}

	/* -------------------------------------------- */

	/**
	 * Sets the audio output on a video element
	 *
	 * Note: This feature is not supported by Firefox by default as it depends on the setSinkId
	 * API which is available behind the media.setsinkid.enabled settings in Firefox
	 * See https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId
	 *
	 * @param {HTMLVideoElement} video    The video element to configure
	 * @param {String} audioSinkId        ID of the audio output device
	 */
	setAudioOutput(video, audioSinkId) {
		easyrtc.setAudioOutput(video, audioSinkId);
	}

	/* -------------------------------------------- */
	/*  Peer Management Methods                     */
	/* -------------------------------------------- */

	/**
	 * Create a MediaStream to be used with a specific peer
	 * By cloning the master stream and sending different streams for each individual peer,
	 * we can better control each peer's connection, allowing us to mute ourselves for only
	 * specific peers for example, in case some user isn't allowed to view or hear us.
	 * @private
	 */
	_createStreamForPeer(peer) {
		const master = easyrtc.getLocalStream();
		if (!master) return null;

		// Use the user's ID as the stream name to create the local named stream
		const userId = this._usernameCache[peer] || easyrtc.idToName(peer);
		const createTracks = {
			audioTracks: master.getAudioTracks(),
			videoTracks: master.getVideoTracks(),
		};
		const streamName = userId;
		easyrtc.closeLocalStream(streamName);

		// Close the stream in case it's been opened already.
		game.webrtc.debug('Creating new stream for user ', userId);
		if (
			Hooks.call('rtcCreateStreamForUser', userId, createTracks) === false
		)
			return null;
		const stream = easyrtc.buildLocalMediaStream(
			streamName,
			createTracks.audioTracks,
			createTracks.videoTracks
		);
		game.webrtc.onLocalStreamCreated(userId, stream);
		return stream;
	}

	/* -------------------------------------------- */

	/**
	 * Return an info object about a specific peer
	 * @param {String} easyRtcId   The EasyRTC ID of the peer
	 * @return {Object}            An object of the format {id, pc, local, remote}, or null
	 * @private
	 */
	_getPeerInfo(easyRtcId) {
		if (!easyRtcId) return null;
		const pc = easyrtc.getPeerConnectionByUserId(easyRtcId);
		if (!pc) return null;
		const info = {
			id: easyrtc.idToName(easyRtcId),
			pc: pc,
			local: null,
			remote: null,
		};

		// Note: While getLocalStreams() and getRemoteStreams() have been deprecated according to MDN
		// easyrtc uses the webrtc-adapter project which ensures they will always be available
		const remote = pc.getRemoteStreams();
		if (remote && remote.length > 0) info.remote = remote[0];
		const local = pc.getLocalStreams();
		if (local && local.length > 0) info.local = local[0];
		return info;
	}

	/* -------------------------------------------- */

	/**
	 * Returns the EasyRtcId of a user
	 * There should only be one remote peer per user
	 * @param {string} userId     The ID of the user
	 * @return {string|null}      The EasyRtcId of the peer
	 */
	_userIdToEasyRtcId(userId) {
		const ids = easyrtc.usernameToIds(userId, null);
		if (ids && ids.length > 0) return ids[0].easyrtcid;
		return null;
	}

	/* -------------------------------------------- */

	/**
	 * Retrieve the stream for a user.
	 * Calling this with game.user.id is the proper way of retrieving the local master stream without re-initializing it.
	 * Any other user will return the remote stream of that user or null if no stream could be found.
	 * @param {string} userId       ID of the user
	 * @return {MediaStream}        The remote stream of the user
	 */
	getStreamForUser(userId) {
		if (userId === game.userId) return easyrtc.getLocalStream();
		const rtcid = this._userIdToEasyRtcId(userId);
		const info = this._getPeerInfo(rtcid);
		return info ? info.remote : null;
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of connected streams
	 * The result would be an array of objects in the form of {id, pc, local, remote} where id is the user's ID, pc is
	 * the RTCPeerConnection object associated to the peer, local is the local stream added to the call and remote is
	 * the remote user's stream.
	 *
	 * @return {Array.Object}
	 */
	getConnectedStreams() {
		const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
		return peers.reduce((streams, peer) => {
			const info = this._getPeerInfo(peer) || [];
			return streams.concat(info);
		}, []);
	}

	/* -------------------------------------------- */
	/*  Device Discovery                            */
	/* -------------------------------------------- */

	/**
	 * Get the list of available video sources.
	 * The expected result is an object with the device id as key and its human-readable label as value.
	 * @return {Promise.Object}
	 */
	async getVideoSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getVideoSourceList(list =>
					resolve(this._deviceInfoToObject(list))
				);
			} catch (err) {
				resolve({});
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of available audio sources.
	 * The expected result is an object with the device id as key and its human-readable label as value.
	 * @return {Promise.Object}
	 */
	async getAudioSources() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSourceList(list =>
					resolve(this._deviceInfoToObject(list))
				);
			} catch (err) {
				resolve({});
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Get the list of available audio output devices
	 * The expected result is an object with the device id as key and its human-readable label as value
	 *
	 * Note: This feature is not supported by Firefox by default as it depends on the enumerateDevices
	 * API which doesn't list output devices on Firefox 63+ unless the media.setsinkid.enabled settings
	 * is enabled.
	 * See https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices
	 *
	 * @return {Promise.Object}
	 */
	async getAudioSinks() {
		return new Promise(resolve => {
			try {
				easyrtc.getAudioSinkList(list =>
					resolve(this._deviceInfoToObject(list))
				);
			} catch (err) {
				resolve({});
			}
		});
	}

	/* -------------------------------------------- */

	/**
	 * Transform the device info array from easyrtc into an object with {id: label} keys
	 * @param {Array} list    The list of devices
	 * @private
	 */
	_deviceInfoToObject(list) {
		return list.reduce((obj, device) => {
			obj[device.id] =
				device.label || game.i18n.localize('WEBRTC.UnknownDevice');
			return obj;
		}, {});
	}

	/* -------------------------------------------- */
	/*  Room Management                             */
	/* -------------------------------------------- */

	/**
	 * Callback whenever there is a change in the list of occupants in a room.
	 * It can also be called if a peer's state changes, such as when a call is established or ended.
	 *
	 * Cache the username associated with each peer.
	 * Only one of the two can initiate a call to the other, and it will be the one with the higher user id.
	 * If both try at the same time, it could fail due to sending connection information while the call is in the wrong
	 * state because of the race condition.
	 *
	 * @param {string} roomName
	 * @param {Object} otherPeople
	 * @param {Object} myInfo
	 * @private
	 */
	async _onRoomOccupantsChange(roomName, otherPeople, myInfo) {
		game.webrtc.debug('Room Occupancy : ', roomName, otherPeople, myInfo);
		for (let easyRtcId of Object.keys(otherPeople)) {
			const userId = easyrtc.idToName(easyRtcId);
			const user = game.users.get(userId);
			game.webrtc.debug(
				'RTC ID ',
				easyRtcId,
				' is user : ',
				userId,
				user ? user.name : 'unknown user'
			);
			if (!user) continue;
			this._usernameCache[easyRtcId] = userId;
			if (
				userId.localeCompare(game.user.id) === 1 &&
				!this.settings.users[userId].blocked
			) {
				this._performCall(easyRtcId).catch(() => {});
			}
		}
	}

	/* -------------------------------------------- */

	/**
	 * Call a peer and establish a connection with them
	 * @param {string} easyRtcId      The peer ID to call
	 * @return {Promise.<boolean>}    Returns false if no call was made or true if the call is successful.
	 *                                raises an Exception in case of failure to establish the call.
	 * @private
	 */
	async _performCall(easyRtcId) {
		return new Promise((resolve, reject) => {
			// Determine whether to make the call (if it has not already been rejected)
			let makeCall =
				!this._callRejections.includes(easyRtcId) &&
				easyrtc.getConnectStatus(easyRtcId) === easyrtc.NOT_CONNECTED;

			// Get the peers to call
			const userId = easyrtc.idToName(easyRtcId);
			const allPeers = makeCall
				? easyrtc.usernameToIds(userId, null)
				: [];

			// Make sure we don't already have an existing connection with the same user
			for (let peer of allPeers) {
				if (
					easyrtc.getConnectStatus(peer.easyrtcid) !==
					easyrtc.NOT_CONNECTED
				) {
					game.webrtc.debug(
						`Not making the call to ${easyRtcId}, already in a call with same user.`
					);
					makeCall = false;
					break;
				}
			}

			// If we do not need to make the call, return early
			if (!makeCall) return resolve(false);

			// Get the peer's stream
			const stream = this._createStreamForPeer(
				easyrtc.idToName(easyRtcId)
			);

			// Define success, failure, and acceptance callbacks
			const onSuccess = () => {
				game.webrtc.debug('Success to make call ', arguments);
				resolve(true);
			};
			const onFailure = (errorCode, errorText) => {
				game.webrtc.debug(
					'Failure to make call ',
					errorCode,
					errorText
				);
				reject(errorText);
				if (stream) easyrtc.closeLocalStream(stream.streamName);
			};
			const onAccept = accepted => {
				game.webrtc.debug(
					'Call was ',
					accepted ? 'Accepted' : 'Rejected',
					arguments
				);
				if (!accepted) this._callRejections.push(easyRtcId);
			};

			// Perform the call
			game.webrtc.debug('Calling user ', easyRtcId);
			easyrtc.call(
				easyRtcId,
				onSuccess,
				onFailure,
				onAccept,
				stream ? [stream.streamName] : null
			);
		});
	}

	/* -------------------------------------------- */

	/**
	 * Callback used to check if an incoming call should be accepted or not
	 * @param {string} easyRtcId     The peer ID of the caller
	 * @param {Function} acceptor    Function to call with whether or not to accept the call and the media streams to use
	 * @private
	 */
	_answerIncomingCall(easyRtcId, acceptor) {
		const userId = easyrtc.idToName(easyRtcId);
		const user = game.users.get(userId);
		let accept = user !== undefined && !this.settings.users[userId].blocked;
		const allPeers = accept ? easyrtc.usernameToIds(userId, null) : [];

		// Verify that we don't already have an existing call with someone else using the same user ID
		if (
			allPeers.some(
				peer =>
					easyrtc.getConnectStatus(peer.easyrtcid) !==
					easyrtc.NOT_CONNECTED
			)
		) {
			accept = false;
		}

		// Create the stream for an accepted call
		const stream = accept
			? this._createStreamForPeer(easyrtc.idToName(easyRtcId))
			: null;

		// Call any provided callback function
		game.webrtc.debug(
			(accept ? 'Accepting' : 'Rejecting') + ' call from ',
			arguments
		);
		acceptor(accept, stream ? [stream.streamName] : null);
	}

	/* -------------------------------------------- */

	/**
	 * Called when a remote stream is added to an existing call
	 * @private
	 */
	_onStreamAdded(callerEasyRtcId, stream) {
		let userId =
			this._usernameCache[callerEasyRtcId] ||
			easyrtc.idToName(callerEasyRtcId);
		game.webrtc.debug('New stream received for user : ', userId);
		this.webrtc.onUserStreamChange(userId, stream);
	}

	/* -------------------------------------------- */

	/**
	 * Called when a remote stream is removed from an existing call
	 * @private
	 */
	_onStreamClosed(easyRtcId, stream, streamName) {
		let userId =
			this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug(
			'Stream closed from ' + easyRtcId + ' for user : ',
			userId
		);
		this.webrtc.onUserStreamChange(userId, null);
	}

	/* -------------------------------------------- */

	/**
	 * Generic error callback.
	 * Filter out bad ice candidate errors since they can happen often for various reasons and reporting them can only
	 * serve to confuse players.
	 * @private
	 */
	_onError({ errorCode, errorText }) {
		game.webrtc.debug('easyRTC Error : ', ...arguments);
		if (errorCode !== easyrtc.errCodes.ICECANDIDATE_ERR)
			this.webrtc.onError(errorText);
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection to the signalling server is lost
	 * @private
	 */
	_onDisconnect() {
		game.webrtc.debug('easyRTC disconnected', ...arguments);
		this.webrtc.onDisconnect();
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection with a peer has been established
	 * @private
	 */
	_onPeerOpen(easyRtcId) {
		let userId =
			this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug('Connection established with peer ', userId);
	}

	/* -------------------------------------------- */

	/**
	 * Called when the connection with a peer has been lost and the ICE machine was unable to re-establish it.
	 * In case of irrecoverable connection loss with the peer, hanging up the call will cause a roomOccupantListener
	 * signal to be sent and we will automatically try to reconnect to the user.
	 * First make sure that they are still in the room so we don't try to hangup with an easyRtcId that is invalid.
	 * @private
	 */
	_onPeerClosed(easyRtcId) {
		let userId =
			this._usernameCache[easyRtcId] || easyrtc.idToName(easyRtcId);
		game.webrtc.debug('Connection lost with peer ', userId);
		if (
			(easyrtc.getRoomOccupantsAsArray(this._room) || []).includes(
				easyRtcId
			)
		)
			easyrtc.hangup(easyRtcId);
	}

	/* -------------------------------------------- */

	/**
	 * Notify of settings changes
	 * This can be used to act according
	 * @param {Object} changed     Object consisting of the changed settings in the form {key: value}
	 */
	onSettingsChanged(changed) {
		// Change the debugging setting
		if (changed.debugClient !== undefined)
			easyrtc.enableDebug(this.settings.debugClient);

		// Change the turn server - renegotiate with all peers
		if (changed.turn !== undefined) {
			this._setupCustomTURN();
			const peers = easyrtc.getRoomOccupantsAsArray(this._room) || [];
			for (let peer of peers) {
				if (easyrtc.getConnectStatus(peer) !== easyrtc.NOT_CONNECTED)
					easyrtc.renegotiate(peer);
			}
		}

		// Change the set of users
		const changedUsers = changed.users || {};
		for (let [userId, user] of Object.entries(changedUsers)) {
			if (user.blocked === undefined) continue;
			const easyRtcId = this._userIdToEasyRtcId(userId);
			if (!easyRtcId) continue;
			if (user.blocked) easyrtc.hangup(easyRtcId);
			else this._performCall(easyRtcId).catch(() => {});
		}
	}
}

CONFIG.WebRTC.clientClass = EasyRTCClient;
