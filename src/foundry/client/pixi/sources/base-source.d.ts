/**
 * A helper class used by the Sight Layer to represent a source of vision or illumination.
 */
declare abstract class PointSource {
  /**
   * @param object - The PlaceableObject which is the origin of this PointSource.
   */
  constructor(object: PlaceableObject);

  /**
   * The object responsible for this source.
   */
  object: PlaceableObject;

  /**
   * The type of source represented by this data structure.
   * Each subclass must implement this attribute.
   * @remarks This is undefined in PointSource.
   */
  static sourceType: string | undefined;

  /**
   * A flag for whether this source is currently rendered or not.
   * @defaultValue `false`
   */
  active: boolean;

  /**
   * The animation configuration applied to this source
   * @defaultValue `{}`
   */
  animation: PointSource.PointSourceAnimationConfiguration;

  /**
   * The object of data which configures how this source is rendered
   * @defaultValue `{}`
   */
  data: Partial<PointSource.Data>;

  /**
   * The maximum radius of emission for this source
   * @defaultValue `0`
   */
  radius: number;

  /**
   * The restricted line-of-sight polygon that is generated by the origin and radius of this source.
   * @defaultValue `undefined`
   */
  los: PointSourcePolygon | undefined;

  /**
   * PIXI Geometry generated to draw meshes.
   * @defaultValue `null`
   * @internal
   */
  _sourceGeometry: PIXI.Geometry | null;

  /**
   * A Graphics object with pre-computed geometry used for masking based on line-of-sight.
   * @defaultValue `new PIXI.LegacyGraphics()`
   */
  losMask: PIXI.Graphics;

  /**
   * Additional information which controls whether certain behaviors of the source must be enforced
   * @defaultValue `{}`
   */
  protected _flags: {
    renderFOV?: boolean;
  } & Record<string, boolean>;

  /**
   * To track meshes initialization
   * @defaultValue `false`
   */
  protected _meshesInit: boolean;

  /**
   * The offset in pixels applied to create soft edges.
   * @defaultValue `-8`
   */
  static EDGE_OFFSET: number;

  /**
   * The x-coordinate of the point source origin.
   */
  get x(): number | undefined;

  /**
   * The y-coordinate of the point source origin.
   */
  get y(): number | undefined;

  /**
   * The type of source represented by this data structure.
   */
  get sourceType(): (typeof PointSource)["sourceType"];

  /**
   * The elevation of the object bound to this base source, if any.
   * Returns the canvas primary background elevation otherwise.
   */
  get elevation(): number;

  /**
   * If the source is animated or not.
   */
  get isAnimated(): boolean;

  /**
   * A point is contained with the area of the source if it is within both the FOV circle and the LOS polygon.
   * @param point - The point to test
   * @returns Is the point contained
   */
  containsPoint(point: Point): boolean;

  /**
   * Steps that must be performed when the base source is destroyed.
   */
  destroy(): void;

  fovTexture?: PIXI.RenderTexture | undefined;

  abstract initialize(data?: Partial<PointSource.Data>): this;

  /**
   * Refresh the state and uniforms of the BaseSource
   */
  abstract refreshSource(): void;

  /**
   * Create or update the source geometry with a polygon shape
   * Triangulate the form and create buffers
   * @param polygon- The pixi polygon
   */
  protected _updateLosGeometry(polygon: PIXI.Polygon): void;

  /**
   * Configure the parameters of the polygon that is generated for this source.
   */
  protected abstract _getPolygonConfiguration(): PointSourcePolygonConfig;

  /**
   * Create the LOS polygon for this Light Source instance using provided parameters.
   */
  protected _createPolygon(): PointSourcePolygon | PIXI.Polygon;

  /**
   * Create or update the source geometry and create meshes if necessary
   * @param polygon - A pixi polygon
   */
  protected _initializeMeshes(polygon: PIXI.Polygon): void;

  /**
   * Create a new Mesh for this source using a provided shader class
   * @param shaderCls - The subclass of AdaptiveLightingShader being used for this Mesh
   * @returns The created Mesh
   */
  protected _createMesh(shaderCls: ConstructorOf<AdaptiveLightingShader>): PIXI.Mesh;

  /**
   * Create all meshes needed with this PointSource
   */
  abstract _createMeshes(): void;

  /**
   * Update the position and size of the mesh each time it is drawn.
   * @param mesh - The Mesh being updated
   * @returns The updated Mesh
   */
  protected _updateMesh(mesh: PIXI.Mesh): PIXI.Mesh;

  /**
   * Animate the BaseSource, if an animation is enabled and if it currently has rendered containers.
   * @param dt - Delta time.
   */
  animate(dt: number): void;

  /**
   * Get power of 2 size pertaining to base-source radius and performance modes
   * @returns The computed power of 2 size
   * @deprecated since v10, will be removed in v11.
   */
  getPowerOf2Size(): number;

  /**
   * Is the angle of emission for this source limited?
   * @defaultValue `false`
   * @deprecated since v10, will be removed in v12
   * @remarks `PointSource#limited is deprecated in favor of PointSourcePolygon#isConstrained.`
   */
  limited: boolean;
}

declare namespace PointSource {
  interface PointSourceAnimationConfiguration {
    /** The human-readable (localized) label for the animation */
    label?: string;
    /** The animation function that runs every frame */
    animation?: Function;
    /** A custom illumination shader used by this animation */
    illuminationShader?: AdaptiveIlluminationShader;
    /** A custom coloration shader used by this animation */
    colorationShader?: AdaptiveColorationShader;
    /** A custom background shader used by this animation */
    backgroundShader?: AdaptiveBackgroundShader;
    /** The animation seed */
    seed?: number;
    /** The animation time */
    time?: number;
  }

  interface Data {
    /** The x-coordinate of the source location */
    x?: number;

    /** The y-coordinate of the source location */
    y?: number;

    /** Whether or not the source is constrained by walls */
    walls?: boolean;
  }
}
