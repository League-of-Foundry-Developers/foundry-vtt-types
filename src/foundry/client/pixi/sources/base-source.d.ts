/**
 * A helper class used by the Sight Layer to represent a source of vision or illumination.
 */
declare abstract class PointSource {
  /**
   * @param object - The object responsible for the PointSource
   */
  constructor(object: PlaceableObject);

  /**
   * The object responsible for this source.
   */
  object: PlaceableObject;

  /**
   * The type of source represented by this data structure.
   * Each subclass must implement this attribute.
   * @remarks This is undefined in PointSource.
   */
  static sourceType: string | undefined;

  /**
   * The default Geometry stored in the GPU for all Point Source meshes.
   */
  static GEOMETRY: PIXI.Geometry;

  /**
   * A flag for whether this source is currently active (rendered) or not
   * @defaultValue `false`
   */
  active: boolean;

  /**
   * The object of data which configures how this source is rendered
   * @defaultValue `{}`
   */
  data: Partial<PointSource.Data>;

  /**
   * The maximum radius of emission for this source
   * @defaultValue `0`
   */
  radius: number;

  /**
   * The restricted line-of-sight polygon that is generated by the origin and radius of this source.
   * @defaultValue `undefined`
   */
  los: PointSourcePolygon | undefined;

  /**
   * A Graphics object with pre-computed geometry used for masking based on line-of-sight.
   * @defaultValue `new PIXI.LegacyGraphics()`
   */
  losMask: PIXI.Graphics;

  /**
   * Is the angle of emission for this source limited?
   * @defaultValue `false`
   */
  limited: boolean;

  /**
   * Boolean flags which control whether certain behaviors of the source must be enforced
   * @defaultValue `{}`
   */
  protected _flags: {
    renderFOV?: boolean;
  } & Record<string, boolean>;

  /**
   * The x-coordinate of the point source origin.
   */
  get x(): number | undefined;

  /**
   * The y-coordinate of the point source origin.
   */
  get y(): number | undefined;

  /**
   * The type of source represented by this data structure.
   */
  get sourceType(): typeof PointSource["sourceType"];

  /**
   * A point is contained with the area of the source if it is within both the FOV circle as well as the LOS polygon.
   * @param point - The point to test
   * @returns Is the point contained
   */
  containsPoint(point: Point): boolean;

  /**
   * Steps that must be performed when the base source is destroyed.
   */
  destroy(): void;

  fovTexture?: PIXI.RenderTexture | undefined;

  abstract initialize(data?: Partial<PointSource.Data>): this;

  /**
   * Get power of 2 size pertaining to base-source radius and performance modes
   * @returns The computed power of 2 size
   */
  getPowerOf2Size(): number;

  /**
   * Create a new Mesh for this source using a provided shader class
   * @param shaderCls - The subclass of AdaptiveLightingShader being used for this Mesh
   * @returns The created Mesh
   */
  protected _createMesh(shaderCls: ConstructorOf<AdaptiveLightingShader>): PIXI.Mesh;

  /**
   * Update the position and size of the mesh each time it is drawn.
   * @param mesh - The Mesh being updated
   * @returns The updated Mesh
   */
  protected _updateMesh(mesh: PIXI.Mesh): PIXI.Mesh;

  /**
   * Render this source to a texture which can be used for masking and blurring.
   */
  protected _renderTexture(): PIXI.RenderTexture;

  /**
   * Create a container that should be rendered to the fov texture for this source
   * @returns The drawn container for the render texture
   */
  protected _drawRenderTextureContainer(): PIXI.Container;
}

declare namespace PointSource {
  interface Data {
    /** The x-coordinate of the source location */
    x?: number;

    /** The y-coordinate of the source location */
    y?: number;

    /** Whether or not the source is constrained by walls */
    walls?: boolean;
  }
}
